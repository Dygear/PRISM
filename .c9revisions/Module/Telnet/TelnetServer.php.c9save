{"ts":1363211555530,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * PHPInSimMod - Telnet Module\n * @package PRISM\n * @subpackage Telnet\n*/\n\nrequire_once(ROOTPATH . '/modules/prism_telnet_screen.php');\n\n/**\n * The TelnetServer class does all connection handling and terminal negotiations and input handling.\n * Any telnet input is then passed to the registered callback function.\n*/\nclass TelnetServer extends TelnetScreen\n{\n\tprivate $socket\t\t\t= null;\n\tprivate $ip\t\t\t\t= '';\n\tprivate $port\t\t\t= 0;\n\t\n\tprivate $lineBuffer\t\t= array();\n\tprivate $lineBufferPtr\t= 0;\n\tprivate $inputBuffer\t= '';\n\tprivate $inputBufferLen\t= 0;\n\tprivate $inputBufferMaxLen\t= 23;\n\t\n\t// send queue used for backlog, in case we can't send a reply in one go\n\tprivate $sendQ\t\t\t= '';\n\tprivate $sendQLen\t\t= 0;\n\n\tprivate $sendWindow\t\t= STREAM_WRITE_BYTES;\t// dynamic window size\n\t\n\tprivate $lastActivity\t= 0;\n\tprivate $mustClose\t\t= false;\n\t\n\t// Editing related\n\tprivate $echoChar\t\t= null;\n\tprivate $inputCallback\t= null;\n\t\n\tprivate $charMap\t\t= array();\n\t\n\tpublic function __construct(&$sock, &$ip, &$port)\n\t{\n\t\t$this->socket\t\t= $sock;\n\t\t$this->ip\t\t\t= $ip;\n\t\t$this->port\t\t\t= $port;\n\t\t\n\t\t$this->lastActivity\t= time();\n\t\t\n\t\t// Start terminal state negotiation\n\t\t$this->setTelnetOption(TELNET_ACTION_DO, TELNET_OPT_BINARY);\n\t\t$this->setTelnetOption(TELNET_ACTION_WILL, TELNET_OPT_ECHO);\n\t\t$this->setTelnetOption(TELNET_ACTION_DO, TELNET_OPT_SGA);\n\t\t$this->setTelnetOption(TELNET_ACTION_DO, TELNET_OPT_LINEMODE);\n\t\t$this->setTelnetOption(TELNET_ACTION_DO, TELNET_OPT_NAWS);\n\t\t$this->setTelnetOption(TELNET_ACTION_DO, TELNET_OPT_TTYPE);\n\n\t\t$this->modeState |= TELNET_MODE_INSERT;\n\t}\n\t\n\tpublic function __destruct()\n\t{\n\t\tif ($this->sendQLen > 0)\n\t\t\t$this->sendQReset();\n\n\t\tif (is_resource($this->socket))\n\t\t{\n\t\t\tfclose($this->socket);\n\t\t}\n\t}\n\t\n\tpublic function &getSocket()\n\t{\n\t\treturn $this->socket;\n\t}\n\t\n\tpublic function &getRemoteIP()\n\t{\n\t\treturn $this->ip;\n\t}\n\t\n\tpublic function &getRemotePort()\n\t{\n\t\treturn $this->port;\n\t}\n\t\n\tpublic function &getLastActivity()\n\t{\n\t\treturn $this->lastActivity;\n\t}\n\t\n\tpublic function getMustClose()\n\t{\n\t\treturn $this->mustClose;\n\t}\n\t\n\t/**\n\t * Sets which character should be echoed when in server echo mode\n\t * $echoChar = null\t\t\t- echo what the user types\n\t * $echoChar = ''\t\t\t- echo an empty char == echo nothing at all\n\t * $echoChar = '<somechar>'\t- echo <somechar>\n\t*/\n\tprotected function setEchoChar($echoChar)\n\t{\n\t\t$this->echoChar = $echoChar;\n\t}\n\t\n\t/*\n\t * $func\t  = function that will handle the user's keyboard input\n\t * $editMode  = either 0 or anything else (TELNET_MODE_LINEEDIT)\n\t * \t\t\t\tThis indicates where the function expects a single char or a whole line\n\t*/\n\tpublic function registerInputCallback($class, $func = null, $editMode = 0)\n\t{\n\t\tif (!$class || !$func)\n\t\t{\n\t\t\t$this->inputCallback = null;\n\t\t\t$editMode = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$this->inputCallback = array($class, $func);\n//\t\t\tconsole('SETTING CALLBACK FUNCTION : '.$func);\n\t\t}\n\t\t\n\t\tif ($editMode == 0)\n\t\t{\n\t\t\t$this->modeState &= ~TELNET_MODE_LINEEDIT;\n\t\t\t$this->setCursorProperties(TELNET_CURSOR_HIDE);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$this->modeState |= TELNET_MODE_LINEEDIT;\n\t\t\t$this->setCursorProperties(0);\n\t\t}\n\t}\n\t\n\tprotected function shutdown()\n\t{\n\t\t$this->mustClose = true;\n\t\t$this->registerInputCallback(null);\n\t}\n\n\tprivate function setTelnetOption($action, $option)\n\t{\n\t\t$this->write(TELNET_IAC.$action.$option);\n\t}\n\t\n\tpublic function read(&$data)\n\t{\n\t\t$this->lastActivity\t= time();\n\t\treturn fread($this->socket, STREAM_READ_BYTES);\n\t}\n\t\n\tpublic function addInputToBuffer(&$raw)\n\t{\n//\t\tfor ($a=0; $a<strlen($raw); $a++)\n//\t\t\tprintf('%02x', ord($raw[$a]));\n////\t\t\tprintf('%02x', ord($this->translateClientChar($raw[$a])));\n//\t\techo \"\\n\";\n\t\t\n\t\t// Add raw input to buffer\n\t\t$this->inputBuffer .= $raw;\n\t\t$this->inputBufferLen += strlen($raw);\n\t}\n\t\n\tpublic function processInput()\n\t{\n\t\t// Here we first check if a telnet command came in.\n\t\t// Otherwise we just pass the input to the window handler\n\t\tfor ($a=0; $a<$this->inputBufferLen; $a++)\n\t\t{\n\t\t\t// Check if next bytes in the buffer is a command\n\t\t\tif ($this->inputBuffer[$a] == TELNET_IAC)\n\t\t\t{\n\t\t\t\t$startIndex = $a;\n\t\t\t\t$a++;\n\t\t\t\tswitch ($this->inputBuffer[$a])\n\t\t\t\t{\n\t\t\t\t\t// IAC ACTION OPTION (3 bytes)\n\t\t\t\t\tcase TELNET_ACTION_WILL :\n\t\t\t\t\t\tswitch($this->inputBuffer[$a+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TELNET_OPT_BINARY :\n\t\t\t\t\t\t\t\t//console('client WILL BINARY');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_BINARY;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_SGA :\n\t\t\t\t\t\t\t\t//console('client WILL SGA');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_SGA;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_LINEMODE :\n\t\t\t\t\t\t\t\t//console('client WILL Linemode');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_LINEMODE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_NAWS :\n\t\t\t\t\t\t\t\t//console('client WILL NAWS');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_NAWS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TERMINAL_SPEED :\n\t\t\t\t\t\t\t\t//console('client WILL terminal speed');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_TERMINAL_SPEED;\n\t\t\t\t\t\t\t\t$this->setTelnetOption(TELNET_ACTION_DONT, TELNET_OPT_TERMINAL_SPEED);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TTYPE :\n\t\t\t\t\t\t\t\t//console('client WILL TTYPE');\n\t\t\t\t\t\t\t\t$this->write(TELNET_IAC.TELNET_OPT_SB.TELNET_OPT_TTYPE.chr(1).TELNET_IAC.TELNET_OPT_SE);\n\t\t\t\t\t\t\t\t//$this->modeState |= TELNET_MODE_NAWS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_NEW_ENVIRON :\n\t\t\t\t\t\t\t\t//console('client WILL NEW-ENVIRON');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_NEW_ENVIRON;\n\t\t\t\t\t\t\t\t$this->setTelnetOption(TELNET_ACTION_DO, TELNET_OPT_NEW_ENVIRON);\n\t\t\t\t\t\t\t\t$this->write(TELNET_IAC.TELNET_OPT_SB.TELNET_OPT_NEW_ENVIRON.chr(1).TELNET_IAC.TELNET_OPT_SE);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$a++;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase TELNET_ACTION_WONT :\n\t\t\t\t\t\tswitch($this->inputBuffer[$a+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TELNET_OPT_BINARY :\n\t\t\t\t\t\t\t\t//console('client WON\\'T BINERY');\n\t\t\t\t\t\t\t\t$this->modeState &= ~TELNET_MODE_BINARY;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_SGA :\n\t\t\t\t\t\t\t\t//console('client WON\\'T SGA');\n\t\t\t\t\t\t\t\t$this->modeState &= ~TELNET_MODE_SGA;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_LINEMODE :\n\t\t\t\t\t\t\t\t//console('client WON\\'T Linemode');\n\t\t\t\t\t\t\t\t$this->modeState &= ~TELNET_MODE_LINEMODE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_NAWS :\n\t\t\t\t\t\t\t\t//console('client WON\\'T NAWS');\n\t\t\t\t\t\t\t\t$this->modeState &= ~TELNET_MODE_NAWS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TERMINAL_SPEED :\n\t\t\t\t\t\t\t\t//console('client WON\\'T terminal speed');\n\t\t\t\t\t\t\t\t$this->modeState &= ~TELNET_MODE_TERMINAL_SPEED;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TTYPE :\n\t\t\t\t\t\t\t\t//console('client WON\\'T TTYPE');\n\t\t\t\t\t\t\t\t//$this->modeState &= ~TELNET_MODE_NAWS;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_NEW_ENVIRON :\n\t\t\t\t\t\t\t\t//console('client WON\\'T NEW-ENVIRON');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_NEW_ENVIRON;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$a++;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase TELNET_ACTION_DO :\n\t\t\t\t\t\tswitch($this->inputBuffer[$a+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TELNET_OPT_ECHO :\n\t\t\t\t\t\t\t\t//console('Server DO echo');\n\t\t\t\t\t\t\t\t$this->modeState |= TELNET_MODE_ECHO;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TTYPE :\n\t\t\t\t\t\t\t\t//console('Server DO ttype');\n\t\t\t\t\t\t\t\t//$this->modeState |= TELNET_MODE_ECHO;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$a++;\n\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\tcase TELNET_ACTION_DONT :\n\t\t\t\t\t\tswitch($this->inputBuffer[$a+1])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TELNET_OPT_ECHO :\n\t\t\t\t\t\t\t\t//console('Server DONT echo');\n\t\t\t\t\t\t\t\t$this->modeState &= ~TELNET_MODE_ECHO;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TTYPE :\n\t\t\t\t\t\t\t\t//console('Server DONT ttype');\n\t\t\t\t\t\t\t\t//$this->modeState &= ~TELNET_MODE_ECHO;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$a++;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// AIC OPTION (2 bytes)\n\t\t\t\t\tcase TELNET_OPT_NOP :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_DM :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_BRK :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_IP :\n\t\t\t\t\t\t$this->shutdown();\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_AO :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_AYT :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_EC :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_EL :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_GA :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_EOF :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_SUSP :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_ABORT :\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t// Suboptions (variable length)\n\t\t\t\t\tcase TELNET_OPT_SB :\n\t\t\t\t\t\t// Find the next IAC SE\n\t\t\t\t\t\tif (($pos = strpos($this->inputBuffer, TELNET_IAC.TELNET_OPT_SE, $a)) === false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn true;\t\t// we need more data.\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t$a++;\n\t\t\t\t\t\t$dist = $pos - $a;\n\t\t\t\t\t\t$subVars = substr($this->inputBuffer, $a, $dist);\n\t\t\t\t\t\t// Detect the command type\n\t\t\t\t\t\tswitch ($subVars[0])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase TELNET_OPT_LINEMODE :\n\t\t\t\t\t\t\t\tswitch ($subVars[1])\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase LINEMODE_MODE :\n\t\t\t\t\t\t\t\t\t\t//console('SB LINEMODE MODE sub command');\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcase LINEMODE_FORWARDMASK :\n\t\t\t\t\t\t\t\t\t\t//console('SB LINEMODE FORWARDMASK sub command');\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tcase LINEMODE_SLC :\n\t\t\t\t\t\t\t\t\t\t//console('SB LINEMODE SLC sub command ('.strlen($subVars).')');\n\t\t\t\t\t\t\t\t\t\t$this->writeCharMap(substr($subVars, 2));\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_NAWS :\n\t\t\t\t\t\t\t\t//console('SB NAWS sub command ('.strlen($subVars).')');\n\t\t\t\t\t\t\t\t$this->unescapeIAC($subVars);\n\t\t\t\t\t\t\t\t$screenInfo = unpack('Ctype/nwidth/nheight', $subVars);\n\t\t\t\t\t\t\t\t$this->setWinSize($screenInfo['width'], $screenInfo['height']);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_TTYPE :\n\t\t\t\t\t\t\t\t$this->unescapeIAC($subVars);\n\t\t\t\t\t\t\t\t$ttype = substr($subVars, 2);\n\t\t\t\t\t\t\t\tif (stripos($ttype, 'xterm') !== false)\n\t\t\t\t\t\t\t\t\t$this->setTType(TELNET_TTYPE_XTERM);\n\t\t\t\t\t\t\t\telse if (stripos($ttype, 'ansi') !== false)\n\t\t\t\t\t\t\t\t\t$this->setTType(TELNET_TTYPE_ANSI);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t$this->setTType(TELNET_TTYPE_OTHER);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//console('SB TTYPE sub command ('.$this->getTType().')');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TELNET_OPT_NEW_ENVIRON :\n\t\t\t\t\t\t\t\t$this->unescapeIAC($subVars);\n\n\t\t\t\t\t\t\t\tswitch(ord($subVars[1]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcase 0 :\t\t// IS\n\t\t\t\t\t\t\t\t\t\t$values = substr($subVars, 2);\n\t\t\t\t\t\t\t\t\t\tconsole('SB NEW_ENVIRON sub IS command ('.strlen($values).')');\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 1 :\t\t// SEND\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2 :\t\t// INFO\n\t\t\t\t\t\t\t\t\t\t$values = substr($subVars, 2);\n\t\t\t\t\t\t\t\t\t\tconsole('SB NEW_ENVIRON sub INFO command ('.strlen($values).')');\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//console('SB NEW_ENVIRON sub command ('.strlen($subVars).')');\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$a += $dist + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tcase TELNET_OPT_SE :\n\t\t\t\t\t\t// Hmm not possible?\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\t// Command escape char\n\t\t\t\t\tcase TELNET_IAC :\t\t\t// Escaped AIC - treat as single 0xFF; send straight to linebuffer\n\t\t\t\t\t\t$this->charToLineBuffer($this->inputBuffer[$a]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tconsole('UNKNOWN TELNET COMMAND ('.ord($this->inputBuffer[$a]).')');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// We have processed a full command - prune it from the buffer\n\t\t\t\tif ($startIndex == 0)\n\t\t\t\t{\n\t\t\t\t\t$this->inputBuffer = substr($this->inputBuffer, $a + 1);\n\t\t\t\t\t$this->inputBufferLen = strlen($this->inputBuffer);\n\t\t\t\t\t$a = -1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$this->inputBuffer = substr($this->inputBuffer, 0, $startIndex).substr($this->inputBuffer, $a + 1);\n\t\t\t\t\t$this->inputBufferLen = strlen($this->inputBuffer);\n\t\t\t\t}\n\t\t\t\t//console('command');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Translate char (eg, 7f -> 08)\n\t\t\t\t$char = $this->translateClientChar($this->inputBuffer[$a]);\n\t\t\t\t\n\t\t\t\t// Check char for special meaning\n\t\t\t\t$special = false;\n\t\t\t\tif ($this->modeState & TELNET_MODE_LINEEDIT)\n\t\t\t\t{\n\t\t\t\t\t// LINE-EDIT PROCESSING\n\t\t\t\t\tswitch ($char)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase KEY_IP :\n\t\t\t\t\t\t\t$special = true;\n\t\t\t\t\t\t\t$this->shutdown();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcase KEY_BS :\n\t\t\t\t\t\t\t$special = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// See if there are any characters to (backwards) delete at all\n\t\t\t\t\t\t\tif ($this->lineBufferPtr > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->lineBufferPtr--;\n\t\t\t\t\t\t\t\tarray_splice($this->lineBuffer, $this->lineBufferPtr, 1);\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Update the client\n\t\t\t\t\t\t\t\t$rewrite = '';\n\t\t\t\t\t\t\t\t$x = $this->lineBufferPtr;\n\t\t\t\t\t\t\t\twhile (isset($this->lineBuffer[$x]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ($this->echoChar !== null)\n\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->echoChar;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->lineBuffer[$x];\n\t\t\t\t\t\t\t\t\t$x++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t$cursorBack = KEY_ESCAPE.'['.(strlen($rewrite)+1).'D';\n\t\t\t\t\t\t\t\t$this->write(KEY_ESCAPE.'[D'.$rewrite.' '.$cursorBack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\n\t\t\t\t\t\tcase KEY_TAB :\n\t\t\t\t\t\t\t$special = true;\n\t\t\t\t\t\t\t$this->handleKey(KEY_TAB);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcase KEY_DELETE :\n\t\t\t\t\t\t\t$special = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ($this->getTType() == TELNET_TTYPE_XTERM &&\n\t\t\t\t\t\t\t\t($this->modeState & TELNET_MODE_LINEMODE) == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// BACKSPACE\n\t\t\t\t\t\t\t\tif ($this->lineBufferPtr > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$this->lineBufferPtr--;\n\t\t\t\t\t\t\t\t\tarray_splice($this->lineBuffer, $this->lineBufferPtr, 1);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Update the client\n\t\t\t\t\t\t\t\t\t$rewrite = '';\n\t\t\t\t\t\t\t\t\t$x = $this->lineBufferPtr;\n\t\t\t\t\t\t\t\t\twhile (isset($this->lineBuffer[$x]))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ($this->echoChar !== null)\n\t\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->echoChar;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->lineBuffer[$x];\n\t\t\t\t\t\t\t\t\t\t$x++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$cursorBack = KEY_ESCAPE.'['.(strlen($rewrite)+1).'D';\n\t\t\t\t\t\t\t\t\t$this->write(KEY_ESCAPE.'[D'.$rewrite.' '.$cursorBack);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// DELETE\n\t\t\t\t\t\t\t\t// See if we're not at the end of the line buffer\n\t\t\t\t\t\t\t\tif (isset($this->lineBuffer[$this->lineBufferPtr]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tarray_splice($this->lineBuffer, $this->lineBufferPtr, 1);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Update the client\n\t\t\t\t\t\t\t\t\t$rewrite = '';\n\t\t\t\t\t\t\t\t\t$x = $this->lineBufferPtr;\n\t\t\t\t\t\t\t\t\twhile (isset($this->lineBuffer[$x]))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ($this->echoChar !== null)\n\t\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->echoChar;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->lineBuffer[$x];\n\t\t\t\t\t\t\t\t\t\t$x++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$cursorBack = KEY_ESCAPE.'['.(strlen($rewrite)+1).'D';\n\t\t\t\t\t\t\t\t\t$this->write($rewrite.' '.$cursorBack);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcase KEY_ESCAPE :\n\t\t\t\t\t\t\t// Always skip at least escape char from lineBuffer.\n\t\t\t\t\t\t\t// Below we further adjust the $a pointer where needed.\n\t\t\t\t\t\t\t$special = true;\n\t\n\t\t\t\t\t\t\t// Look ahead in inputBuffer to detect escape sequence\n\t\t\t\t\t\t\tif (!isset($this->inputBuffer[$a+1]) || \n\t\t\t\t\t\t\t\t($this->inputBuffer[$a+1] != '[' && $this->inputBuffer[$a+1] != 'O'))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$this->handleKey(KEY_ESCAPE);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$input = substr($this->inputBuffer, $a);\n\t\t\t\t\t\t\t$matches = array();\n\t\t\t\t\t\t\tif (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)D).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR LEFT\n\t\t\t\t\t\t\t\tif ($this->lineBufferPtr > 0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$this->write($matches[1]);\n\t\t\t\t\t\t\t\t\t$a += strlen($matches[1]) - 1;\n\t\t\t\t\t\t\t\t\t$this->lineBufferPtr -= ((int) $matches[2] > 1) ? (int) $matches[2] : 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)C).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR RIGHT\n\t\t\t\t\t\t\t\tif (isset($this->lineBuffer[$this->lineBufferPtr]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t$this->write($matches[1]);\n\t\t\t\t\t\t\t\t\t$a += strlen($matches[1]) - 1;\n\t\t\t\t\t\t\t\t\t$this->lineBufferPtr += ((int) $matches[2] > 1) ? (int) $matches[2] : 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)A).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR UP\n\t\t\t\t\t\t\t\t$this->handleKey(KEY_CURUP);\n\t\t\t\t\t\t\t\t//$this->write($matches[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)B).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR DOWN\n\t\t\t\t\t\t\t\t$this->handleKey(KEY_CURDOWN);\n\t\t\t\t\t\t\t\t//$this->write($matches[1]);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// CTRL-Arrow keys\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)D).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR LEFT CTRL\n\t\t\t\t\t\t\t\t//$char = KEY_CURLEFT_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)C).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR RIGHT CTRL\n\t\t\t\t\t\t\t\t//$char = KEY_CURRIGHT_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)A).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR UP CTRL\n\t\t\t\t\t\t\t\t//$char = KEY_CURUP_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)B).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR DOWN CTRL\n\t\t\t\t\t\t\t\t//$char = KEY_CURDOWN_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Other keys\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[3~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Alternate DEL keycode\n\t\t\t\t\t\t\t\t// See if we're not at the end of the line buffer\n\t\t\t\t\t\t\t\tif (isset($this->lineBuffer[$this->lineBufferPtr]))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tarray_splice($this->lineBuffer, $this->lineBufferPtr, 1);\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// Update the client\n\t\t\t\t\t\t\t\t\t$rewrite = '';\n\t\t\t\t\t\t\t\t\t$x = $this->lineBufferPtr;\n\t\t\t\t\t\t\t\t\twhile (isset($this->lineBuffer[$x]))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ($this->echoChar !== null)\n\t\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->echoChar;\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t$rewrite .= $this->lineBuffer[$x];\n\t\t\t\t\t\t\t\t\t\t$x++;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t$cursorBack = KEY_ESCAPE.'['.(strlen($rewrite)+1).'D';\n\t\t\t\t\t\t\t\t\t$this->write($rewrite.' '.$cursorBack);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[2~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// INSERT\n\t\t\t\t\t\t\t\t$this->modeState ^= TELNET_MODE_INSERT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[1~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// HOME\n\t\t\t\t\t\t\t\t// Move cursor to start of edit-line\n\t\t\t\t\t\t\t\t$diff = $this->lineBufferPtr;\n\t\t\t\t\t\t\t\t$this->lineBufferPtr = 0;\n\t\t\t\t\t\t\t\t$this->write(KEY_ESCAPE.'['.$diff.'D');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[4~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// END\n\t\t\t\t\t\t\t\t// Move cursor to end of edit-line\n\t\t\t\t\t\t\t\t$bufLen = count($this->lineBuffer);\n\t\t\t\t\t\t\t\t$diff = $bufLen - $this->lineBufferPtr;\n\t\t\t\t\t\t\t\t$this->lineBufferPtr = $bufLen;\n\t\t\t\t\t\t\t\t$this->write(KEY_ESCAPE.'['.$diff.'C');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[Z).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// SHIFT-TAB\n\t\t\t\t\t\t\t\t$this->handleKey(KEY_SHIFTTAB);\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Move inputBuffer pointer ahead to cover multibyte char?\n\t\t\t\t\t\t\tif (count($matches) > 1)\n\t\t\t\t\t\t\t\t$a += strlen($matches[1]) - 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Regular characers.\n\t\t\t\t\tif ($special)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// We must detect the Enter key here\n\t\t\t\t\t$enterChar = $this->isEnter($a);\n\t\t\t\t\t\n\t\t\t\t\tif ($this->modeState & TELNET_MODE_LINEEDIT)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Line processing\n\t\t\t\t\t\tif ($enterChar === null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Store char in linfe buffer\n\t\t\t\t\t\t\t$this->charToLineBuffer($this->inputBuffer[$a]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Detect whole lines when Enter encountered\n\t\t\t\t\t\t\t$this->charToLineBuffer($enterChar, true);\n\t\t\t\t\t\t\tdo\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$line = $this->getLine();\n\t\t\t\t\t\t\t\tif ($line === false)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// Send line to the current input callback function (if there is one)\n\t\t\t\t\t\t\t\t$method = $this->inputCallback[1];\n\t\t\t\t\t\t\t\t$this->inputCallback[0]->$method($line);\n\t\t\t\t\t\t\t} while(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// SINGLE KEY PROCESSING\n\t\t\t\t\tswitch ($char)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase KEY_IP :\n\t\t\t\t\t\t\t$special = true;\n\t\t\t\t\t\t\t$this->shutdown();\n\t\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t\tcase KEY_BS :\n\t\t\t\t\t\tcase KEY_TAB :\n\t\t\t\t\t\tcase KEY_DELETE :\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\n\t\t\t\t\t\tcase KEY_ESCAPE :\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Look ahead in inputBuffer to detect escape sequence\n\t\t\t\t\t\t\tif (!isset($this->inputBuffer[$a+1]) || \n\t\t\t\t\t\t\t\t($this->inputBuffer[$a+1] != '[' && $this->inputBuffer[$a+1] != 'O'))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t$input = substr($this->inputBuffer, $a);\n\t\t\t\t\t\t\t$matches = array();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Arrow keys\n\t\t\t\t\t\t\tif (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)D).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR LEFT\n\t\t\t\t\t\t\t\t$char = KEY_CURLEFT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)C).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR RIGHT\n\t\t\t\t\t\t\t\t$char = KEY_CURRIGHT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)A).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR UP\n\t\t\t\t\t\t\t\t$char = KEY_CURUP;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[(\\d?)B).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR DOWN\n\t\t\t\t\t\t\t\t$char = KEY_CURDOWN;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// CTRL-Arrow keys\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)D).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR LEFT\n\t\t\t\t\t\t\t\t$char = KEY_CURLEFT_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)C).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR RIGHT\n\t\t\t\t\t\t\t\t$char = KEY_CURRIGHT_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)A).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR UP\n\t\t\t\t\t\t\t\t$char = KEY_CURUP_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\O(\\d?)B).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// CURSOR DOWN\n\t\t\t\t\t\t\t\t$char = KEY_CURDOWN_CTRL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Other special keys\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[3~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Alternate DEL keycode\n\t\t\t\t\t\t\t\t$char = KEY_DELETE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[2~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// INSERT\n\t\t\t\t\t\t\t\t$char = KEY_INSERT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[1~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// HOME\n\t\t\t\t\t\t\t\t$char = KEY_HOME;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[4~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// END\n\t\t\t\t\t\t\t\t$char = KEY_END;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[5~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// PgUp\n\t\t\t\t\t\t\t\t$char = KEY_PAGEUP;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[6~).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// PgDn\n\t\t\t\t\t\t\t\t$char = KEY_PAGEDOWN;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'OP).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// F1 (windows)\n\t\t\t\t\t\t\t\t$char = KEY_F1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'OQ).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// F2 (windows)\n\t\t\t\t\t\t\t\t$char = KEY_F2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'OR).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// F3 (windows)\n\t\t\t\t\t\t\t\t$char = KEY_F3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'OS).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// F4 (windows)\n\t\t\t\t\t\t\t\t$char = KEY_F4;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[([0-9]{2})~).*$/', $input, $matches) &&\n\t\t\t\t\t\t\t\t\t$matches[2] > 10 && $matches[2] < 25 && $matches[2] != 16 && $matches[2] != 22)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Fxx\n\t\t\t\t\t\t\t\t$char = chr(1).chr($matches[2]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if (preg_match('/^('.KEY_ESCAPE.'\\[Z).*$/', $input, $matches))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// SHIFT-TAB\n\t\t\t\t\t\t\t\t$char = KEY_SHIFTTAB;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconsole(substr($input, 1));\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Move inputBuffer pointer ahead to cover multibyte char?\n\t\t\t\t\t\t\tif (count($matches) > 1)\n\t\t\t\t\t\t\t\t$a += strlen($matches[1]) - 1;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($special)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\t\t// Single key processing (if there is a callback at all)\n\t\t\t\t\tif ($this->inputCallback[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tif ($this->isEnter($a) !== null)\n\t\t\t\t\t\t\t$char = KEY_ENTER;\n\t\t\t\t\t\t\n\t\t\t\t\t\t$method = $this->inputCallback[1];\n\t\t\t\t\t\t$this->inputCallback[0]->$method($char);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$this->inputBuffer = substr($this->inputBuffer, $a + 1);\n\t\t$this->inputBufferLen = strlen($this->inputBuffer);\n\n\t\treturn true;\n\t}\n\t\n\t// Get a whole line from input\n\tpublic function getLine($forceFlush = false)\n\t{\n\t\t// Detect carriage return / line feed / whatever you want to call it\n\t\t$count = count($this->lineBuffer);\n\t\tif (!$count)\n\t\t\treturn false;\n\t\t\n\t\t$line = '';\n\t\t$haveLine = false;\n\t\tfor ($a=0; $a<$count; $a++)\n\t\t{\n\t\t\tif ($this->modeState & TELNET_MODE_LINEMODE)\n\t\t\t{\n\t\t\t\tif ($this->lineBuffer[$a] == \"\\r\")\n\t\t\t\t{\n\t\t\t\t\t$haveLine = true;\n\t\t\t\t\tbreak;\t\t\t\t// break out of the main char by char loop\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (isset($this->lineBuffer[$a+1]) && \n\t\t\t\t\t$this->lineBuffer[$a].$this->lineBuffer[$a+1] == \"\\r\\n\")\n\t\t\t\t{\n\t\t\t\t\t$a++;\n\t\t\t\t\t$haveLine = true;\n\t\t\t\t\tbreak;\t\t\t\t// break out of the main char by char loop\n\t\t\t\t}\n\t\t\t}\n\t\t\t$line .= $this->lineBuffer[$a];\n\t\t}\n\t\t\n\t\tif ($haveLine || $forceFlush)\n\t\t{\n\t\t\t// Send return to client if in echo mode (and later on, if in simple mode)\n//\t\t\tif ($this->modeState & TELNET_MODE_ECHO)\n//\t\t\t\t$this->write(\"\\r\\n\");\n\t\t\t\n\t\t\t// Splice line out of line buffer\n\t\t\tarray_splice($this->lineBuffer, 0, $a+1);\n\t\t\t\n\t\t\t$this->lineBuffer = array();\n\t\t\t$this->lineBufferPtr = 0;\n\t\t\treturn $line;\n\t\t}\n\n\t\treturn false;\n\t}\n\t\n\tprivate function isEnter(&$a)\n\t{\n\t\tif ($this->modeState & TELNET_MODE_LINEMODE)\n\t\t{\n\t\t\tif ($this->inputBuffer[$a] == \"\\r\")\n\t\t\t\treturn \"\\r\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($this->inputBuffer[$a] == \"\\r\" && !isset($this->inputBuffer[$a+1]))\n\t\t\t{\n\t\t\t\treturn \"\\r\\n\";\n\t\t\t}\n\t\t\telse if (isset($this->inputBuffer[$a+1]) && \n\t\t\t\t$this->inputBuffer[$a].$this->inputBuffer[$a+1] == \"\\r\\n\")\n\t\t\t{\n\t\t\t\t$a++;\n\t\t\t\treturn \"\\r\\n\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tpublic function setLineBuffer($chars)\n\t{\n\t\t$this->lineBuffer = array();\n\t\t$this->lineBufferPtr = 0;\n\t\tfor ($a=0; $a<strlen($chars); $a++)\n\t\t\t$this->lineBuffer[$this->lineBufferPtr++] = $chars[$a];\n\t}\n\t\n\tpublic function setInputBufferMaxLen($maxLength)\n\t{\n\t\t$this->inputBufferMaxLen = (int) $maxLength;\n\t\tif ($this->inputBufferMaxLen < 1)\n\t\t\t$this->inputBufferMaxLen = 1;\n\t}\n\t\n\tprivate function charToLineBuffer($char, $isEnter = false)\n\t{\n\t\t// If buffer 'full', just return and ignore the new char\n\t\tif (count($this->lineBuffer) == $this->inputBufferMaxLen)\n\t\t\treturn;\n\n\t\t// Add the new char\t\t\t\n\t\tif ($isEnter)\n\t\t{\n\t\t\tfor ($a=0; $a<strlen($char); $a++)\n\t\t\t\t$this->lineBuffer[] = $char[$a];\n\t\t}\n\t\telse if ($this->modeState & TELNET_MODE_INSERT)\n\t\t{\n\t\t\tfor ($a=0; $a<strlen($char); $a++)\n\t\t\t\tarray_splice($this->lineBuffer, $this->lineBufferPtr++, 0, array($char[$a]));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor ($a=0; $a<strlen($char); $a++)\n\t\t\t\t$this->lineBuffer[$this->lineBufferPtr++] = $char[$a];\n\t\t}\n\t\t\n\t\t// Must we update the client?\n\t\tif ($this->modeState & TELNET_MODE_ECHO)\n\t\t{\n\t\t\tif ($char == KEY_TAB || ($char = filter_var($char, FILTER_UNSAFE_RAW, FILTER_FLAG_STRIP_LOW | FILTER_FLAG_STRIP_HIGH)) != '')\n\t\t\t{\n\t\t\t\t$rewrite = $cursorBack = '';\n\n\t\t\t\t// Are we in insert mode and do we have to move any chars?\n\t\t\t\tif ($this->modeState & TELNET_MODE_INSERT && isset($this->lineBuffer[$this->lineBufferPtr]))\n\t\t\t\t{\n\t\t\t\t\t// Write the remaining chars and return cursor to original pos\n\t\t\t\t\t$x = $this->lineBufferPtr;\n\t\t\t\t\twhile (isset($this->lineBuffer[$x]))\n\t\t\t\t\t\t$rewrite .= $this->lineBuffer[$x++];\n\t\t\t\t\t$cursorBack = KEY_ESCAPE.'['.(strlen($rewrite)).'D';\n\t\t\t\t}\n\n\t\t\t\tif ($this->echoChar !== null)\n\t\t\t\t\t$this->write($this->echoChar.$rewrite.$cursorBack);\n\t\t\t\telse\n\t\t\t\t\t$this->write($char.$rewrite.$cursorBack);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate function translateClientChar($char)\n\t{\n\t\tforeach ($this->charMap as $func => $data)\n\t\t{\n\t\t\tif ($data[0] == $char)\n\t\t\t{\n\t\t\t\t$tr = $this->getFunctionChar($func);\n\t\t\t\tif ($tr)\n\t\t\t\t\treturn $tr;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $char;\n\t}\n\t\n\tprivate function translateServerChar($char)\n\t{\n\t\t$this->charMap;\n\t}\n\t\n\tprivate function writeCharMap($mapData)\n\t{\n\t\t// Unescape IACIAC\n\t\t$this->unescapeIAC($mapData);\n\t\t\n\t\t// We must have a number of octect triplets\n\t\t$len = strlen($mapData);\n\t\tif (($len % 3) != 0)\n\t\t\treturn false;\n\t\t\n\t\t$a = 0;\n\t\t$this->charMap = array();\n\t\twhile ($a<$len)\n\t\t{\n\t\t\t$func\t\t= $mapData[$a++];\n\t\t\t$options\t= $mapData[$a++];\n\t\t\t$ascii\t\t= $mapData[$a++];\n\t\t\t\n\t\t\t//console(printf());\n\t\t\t$this->charMap[$func] = array($ascii, $options);\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate function unescapeIAC(&$data)\n\t{\n\t\t$new = '';\n\t\tfor ($a=0; $a<strlen($data); $a++)\n\t\t{\n\t\t\tif ($data[$a] == TELNET_IAC &&\n\t\t\t\tisset($data[$a+1]) &&\n\t\t\t\t$data[$a+1] == TELNET_IAC)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t$new .= $data[$a];\n\t\t}\n\t\t$data = $new;\n\t}\n\t\n\t// Get the default ascii character that belongs to a certain SLC function\n\tprivate function getFunctionChar($func)\n\t{\n\t\tswitch ($func)\n\t\t{\n\t\t\tcase LINEMODE_SLC_SYNCH :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_BRK :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_IP :\n\t\t\t\treturn KEY_IP;\t\t\t// ctrl-c\n\t\t\t\n\t\t\tcase LINEMODE_SLC_AO :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_AYT :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EOR :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_ABORT :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EOF :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_SUSP :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EC :\n\t\t\t\treturn KEY_BS;\t\t\t// backspace\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EL :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EW :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_RP :\n\t\t\t\tbreak;\n\n\t\t\tcase LINEMODE_SLC_LNEXT :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_XON :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_XOFF :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_FORW1 :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_FORW2 :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_MCL :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_MCR :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_MCWL :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_MCWR :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_MCBOL :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_MCEOL :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_INSRT :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_OVER :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_ECR :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EWR :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EBOL :\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase LINEMODE_SLC_EEOL :\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic function write($data, $sendQPacket = FALSE)\n\t{\n\t\t$bytes = 0;\n\t\t$dataLen = strlen($data);\n\t\tif ($dataLen == 0)\n\t\t\treturn 0;\n\t\t\n\t\tif (!is_resource($this->socket))\n\t\t\treturn $bytes;\n\t\n\t\tif ($sendQPacket == TRUE)\n\t\t{\n\t\t\t// This packet came from the sendQ. We just try to send this and don't bother too much about error checking.\n\t\t\t// That's done from the sendQ flushing code.\n\t\t\t$bytes = @fwrite($this->socket, $data);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($this->sendQLen == 0)\n\t\t\t{\n\t\t\t\t// It's Ok to send packet\n\t\t\t\t$bytes = @fwrite($this->socket, $data);\n\t\t\t\t$this->lastActivity = time();\n\t\t\n\t\t\t\tif (!$bytes || $bytes != $dataLen)\n\t\t\t\t{\n\t\t\t\t\t// Could not send everything in one go - send the remainder to sendQ\n\t\t\t\t\t$this->addPacketToSendQ (substr($data, $bytes));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Remote is lagged\n\t\t\t\t$this->addPacketToSendQ($data);\n\t\t\t}\n\t\t}\n\t\n\t\treturn $bytes;\n\t}\n\n\tpublic function &getSendQLen()\n\t{\n\t\treturn $this->sendQLen;\n\t}\n\t\n\tprivate function addPacketToSendQ($data)\n\t{\n\t\t$this->sendQ\t\t\t.= $data;\n\t\t$this->sendQLen\t\t\t+= strlen($data);\n\t}\n\n\tpublic function flushSendQ()\n\t{\n\t\t// Send chunk of data\n\t\t$bytes = $this->write(substr($this->sendQ, 0, $this->sendWindow), TRUE);\n\t\t\n\t\t// Dynamic window sizing\n\t\tif ($bytes == $this->sendWindow)\n\t\t\t$this->sendWindow += STREAM_WRITE_BYTES;\n\t\telse\n\t\t{\n\t\t\t$this->sendWindow -= STREAM_WRITE_BYTES;\n\t\t\tif ($this->sendWindow < STREAM_WRITE_BYTES)\n\t\t\t\t$this->sendWindow = STREAM_WRITE_BYTES;\n\t\t}\n\n\t\t// Update the sendQ\n\t\t$this->sendQ = substr($this->sendQ, $bytes);\n\t\t$this->sendQLen -= $bytes;\n\n\t\t// Cleanup / reset timers\n\t\tif ($this->sendQLen == 0)\n\t\t{\n\t\t\t// All done flushing - reset queue variables\n\t\t\t$this->sendQReset();\n\t\t} \n\t\telse if ($bytes > 0)\n\t\t{\n\t\t\t// Set when the last packet was flushed\n\t\t\t$this->lastActivity\t\t= time();\n\t\t}\n\t\t//console('Bytes sent : '.$bytes.' - Bytes left : '.$this->sendQLen);\n\t}\n\t\n\tprivate function sendQReset()\n\t{\n\t\t$this->sendQ\t\t\t= '';\n\t\t$this->sendQLen\t\t\t= 0;\n\t\t$this->lastActivity\t\t= time();\n\t}\n}\n\n?>"]],"start1":0,"start2":0,"length1":0,"length2":31181}]],"length":31181}

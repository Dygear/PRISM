{"ts":1363202439941,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * PHPInSimMod - Packet Module\n * @package PRISM\n * @subpackage Packet\n */\n\n/* Start of PRISM PACKET HEADER */\nabstract class Struct\n{\n\tpublic function __conStruct($rawPacket = NULL)\n\t{\n\t\tif ($rawPacket !== NULL)\n\t\t\t$this->unpack($rawPacket);\n\t\treturn $this;\n\t}\n\tpublic function __invoke()\n\t{\n\t\t$argv = func_get_args();\n\t\t$argi = 0;\n\t\t$argc = count($argv);\n\t\tforeach ($this as $property => $value)\n\t\t{\n\t\t\t$RP = new ReflectionProperty(get_class($this), $property);\n\t\t\tif ($RP->isPublic())\n\t\t\t\t$object->$property = $argv[$argi++];\n\t\t\tif ($argc == $argi)\n\t\t\t\tcontinue;\n\t\t}\n\t}\n\tpublic function __toString()\n\t{\n\t\treturn $this->printPacketDetails();\n\t}\n\t// Magic Methods (Object Overloading)\n\tpublic function &__get($name)\n\t{\n\t\t$return = FALSE;\n\t\tif (!property_exists(get_class($this), $name))\n\t\t\treturn $return;\n\t\telse\n\t\t\treturn $this->$name;\n\t}\n\tpublic function &__call($name, $arguments)\n\t{\n\t\tif (property_exists(get_class($this), $name))\n\t\t\t$this->$name = array_shift($arguments);\n\t\treturn $this;\n\t}\n\tpublic function __isset($name)\n\t{\n\t\treturn isset($this->$name);\n\t}\n\tpublic function __unset($name)\n\t{\n\t\tif (isset($this->$name))\n\t\t\t$this->$name = NULL;\n\t}\n\t// Normal Methods\n\tpublic function send($hostId = NULL)\n\t{\n\t\tglobal $PRISM;\n\t\t$PRISM->hosts->sendPacket($this, $hostId);\n\t\treturn $this;\n\t}\n\tpublic function printPacketDetails($pre = '')\n\t{\n\t\tglobal $TYPEs;\n\t\t$packFormat = $this->parsePackFormat();\n\t\t$propertyNumber = -1;\n\t\t$str = $pre . get_class($this) . ' {' . PHP_EOL;\n\t\tforeach ($this as $property => $value)\n\t\t{\n\t\t\t$pkFnkFormat = $packFormat[++$propertyNumber];\n\t\t\tif (gettype($this->$property) == 'array')\n\t\t\t{\n\t\t\t\t$str .= \"{$pre}\\tArray\\t{$property}\\t= {\" . PHP_EOL;\n\t\t\t\tforeach ($this->$property as $k => $v)\n\t\t\t\t{\n\t\t\t\t\tif ($v instanceof Struct)\n\t\t\t\t\t{\n\t\t\t\t\t\t$str .= $pre . $v->printPacketDetails($pre . \"\\t\\t\\t\") . PHP_EOL;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$str .= \"{$pre}\\t\\t\\t{$k}\\t{$v}\" . PHP_EOL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$str .= \"{$pre}\\t}\" . PHP_EOL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telseif ($property == 'Type')\n\t\t\t{\n\t\t\t\t$str .= \"{$pre}\\t{$pkFnkFormat}\\t{$property}\\t= {$TYPEs[$this->Type]} ({$this->$property})\" . PHP_EOL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$str .= \"{$pre}\\t{$pkFnkFormat}\\t{$property}\\t= {$this->$property}\" . PHP_EOL;\n\t\t\t}\n\t\t}\n\t\treturn \"{$str}{$pre}}\" . PHP_EOL;\n\t}\n\tpublic function unpack($rawPacket)\n\t{\n\t\tforeach (unpack($this::UNPACK, $rawPacket) as $property => $value)\n\t\t{\n\t\t\t$this->$property = $value;\n\t\t}\n\n\t\treturn $this;\n\t}\n\tpublic function pack()\n\t{\n\t\t$return = '';\n\t\t$packFormat = $this->parsePackFormat();\n\t\t$propertyNumber = -1;\n\t\tforeach ($this as $property => $value)\n\t\t{\n\t\t\t$pkFnkFormat = $packFormat[++$propertyNumber];\n\t\t\tif ($pkFnkFormat == 'x')\n\t\t\t\t$return .= pack('C', 0); # NULL & 0 are the same thing in Binary (00000000) and Hex (x00), so NULL == 0.\n\t\t\telse if (is_array($pkFnkFormat))\n\t\t\t{\n\t\t\t\tlist($type, $elements) = $pkFnkFormat;\n\t\t\t\tif (($j = count($value)) > $elements)\n\t\t\t\t\t$j = $elements;\n\t\t\t\tfor ($i = 0; $i < $j; ++$i, --$j)\n\t\t\t\t{\n\t\t\t\t\tvar_dump($value, $type, $elements, $i, $j, $value[$i]);\n\t\t\t\t\t$return .= pack($type, $value[$i]);\n\t\t\t\t}\n\t\t\t\tif ($j > 0);\n\t\t\t\t\t$return .= pack(\"x{$j}\");\t# Fills the rest of the space with null data.\n\t\t\t}\n\t\t\telse\n\t\t\t\t$return .= pack($pkFnkFormat, $value);\n\t\t}\n\t\treturn $return;\n\t}\n\tpublic function parseUnpackFormat()\n\t{\n\t\t$return = array();\n\t\tforeach (explode('/', $this::UNPACK) as $element)\n\t\t{\n\t\t\tfor ($i = 1; is_numeric($element{$i}); ++$i) {}\n\t\t\t$dataType = substr($element, 0, $i);\n\t\t\t$dataName = substr($element, $i);\n\t\t\t$return[$dataName] = $dataType;\n\t\t}\n\t\treturn $return;\n\t}\n\tpublic function parsePackFormat()\n\t{\n\t\t$format = $this::PACK; # It does not like using $this::PACK directly.\n\t\t$elements = array();\n\t\tfor ($i = 0, $j = 1, $k = strLen($format); $i < $k; ++$i, ++$j) # i = Current Character; j = Look ahead for numbers.\n\t\t{\n\t\t\t# Is current is string and next is no number\n\t\t\tif (is_string($format{$i}) && !isset($format[$j]) || !is_numeric($format[$j]))\n\t\t\t\t$elements[] = $format{$i};\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (isset($format{$j}) && is_numeric($format{$j}))\n\t\t\t\t\t++$j;\t# Will be the last number of the current element.\n\n\t\t\t\t$number = substr($format, $i + 1, $j - ($i + 1));\n\n\t\t\t\tif ($format{$i} == 'a' || $format{$i} == 'A') # In these cases it's a string type where dealing with.\n\t\t\t\t\t$elements[] = $format{$i}.$number;\n\t\t\t\telse # In these cases, we should get an array.\n\t\t\t\t\t$elements[] = array($format{$i}, $number);\n\n\t\t\t\t$i = $j - 1; # Movies the pointer to the end of this element.\n\t\t\t}\n\t\t}\n\t\treturn $elements;\n\t}\n}\n\n/* End of PRISM PACKET HEADER */\n\n#ifndef _ISPACKETS_H_\n#define _ISPACKETS_H_\n/////////////////////\n\n// InSim for Live for Speed : 0.5Z\n\n// InSim allows communication between up to 8 external programs and LFS.\n\n// TCP or UDP packets can be sent in both directions, LFS reporting various\n// things about its state, and the external program requesting info and\n// controlling LFS with special packets, text commands or keypresses.\n\n// NOTE : This text file was written with a TAB size equal to 4 spaces.\n\n\n// NOTE : This text file was written with a TAB size equal to 4 spaces.\n// ====================\n\n/* const int INSIM_VERSION = 5; */\ndefine('INSIM_VERSION', 5);\n\n// CHANGES\n// =======\n\n// Version 0.5Z (compatible so no change to INSIM_VERSION)\n\n// NLP / MCI packets are now output at regular intervals\n// CCI_LAG bit added to the CompCar Structure\n\n// Version 0.5Z30 (INSIM_VERSION increased to 5)\n\n// NLP / MCI minimum time interval reduced to 40 ms (was 50 ms)\n// IS_CON (CONtact) reports contact between two cars (if ISF_CON is enabled)\n// IS_MTC (Msg To Connection) now has a variable length (up to 128 characters)\n// IS_MTC can be sent to all (UCID = 255) and sound effect can be specified\n// ISS_SHIFTU_HIGH is no longer used (no distinction between high and low view)\n// FIX : Clutch axis / button was not reported after a change in Controls screen\n\n// Version 0.5Z32\n\n// OG_SHIFT and OG_CTRL bits added to OutGaugePack\n// Lap timing info added to IS_RST (Timing byte)\n// IS_VTC now cancels game votes even if the majority has not been reached\n\n// Version 0.6A1\n\n// IS_OBH reports information about any object hit\n// IS_HLV reports incidents that would violate HLVC\n// IS_PLC sets allowed cars for individual players\n// IS_AXM to add / remove / clear autocross objects\n// IS_ACR to report (attempted) admin commands\n\n\n// TYPES : (all multi-byte types are PC style - lowest byte first)\n// =====\n\n// type\t\t\tmachine byte type\t\t\tphp pack / unpack type\n// char\t\t\t1-byte character\t\t\tc\n// byte\t\t\t1-byte unsigned integer\t\tC\n// word\t\t\t2-byte unsigned integer\t\tv\n// short\t\t2-byte signed integer\t\ts\n// unsigned\t\t4-byte unsigned integer\t\tV\n// int\t\t\t4-byte signed integerz\t\tl\n// float\t\t4-byte float\t\t\t\tf\n/* string\t\tvar-byte array of charaters\ta\t\t*/\n\n// RaceLaps (rl) : (various meanings depending on range)\n\n// 0       : practice\n// 1-99    : number of laps...   laps  = rl\n// 100-190 : 100 to 1000 laps... laps  = (rl - 100) * 10 + 100\n// 191-238 : 1 to 48 hours...    hours = rl - 190\n\n\n// InSim PACKETS\n// =============\n\n// All InSim packets use a four byte header\n\n// Size : total packet size - a multiple of 4\n// Type : packet identifier from the ISP_ enum (see below)\n// ReqI : non zero if the packet is a packet request or a reply to a request\n// Data : the first data byte\n\n\n// INITIALISING InSim\n// ==================\n\n// To initialise the InSim system, type into LFS : /insim xxxxx\n// where xxxxx is the TCP and UDP port you want LFS to open.\n\n// OR start LFS with the command line option : LFS /insim=xxxxx\n// This will make LFS listen for packets on that TCP and UDP port.\n\n\n// TO START COMMUNICATION\n// ======================\n\n// TCP : Connect to LFS using a TCP connection, then send this packet :\n// UDP : No connection required, just send this packet to LFS :\n\nclass IS_ISI extends Struct // InSim Init - packet to initialise the InSim system\n{\n\tconst PACK = 'CCCxvvxCva16a16';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/vUDPPort/vFlags/CSp0/CPrefix/vInterval/a16Admin/a16IName';\n\n\tprotected $Size = 44;\t\t\t\t# 44\n\tprotected $Type = ISP_ISI;\t\t\t# always ISP_ISI\n\tpublic $ReqI;\t\t\t\t\t\t# If non-zero LFS will send an IS_VER packet\n\tprotected $Zero = NULL;\t\t\t\t# 0\n\n\tpublic $UDPPort;\t\t\t\t\t# Port for UDP replies from LFS (0 to 65535)\n\tpublic $Flags;\t\t\t\t\t\t# Bit flags for options (see below)\n\n\tprotected $Sp0 = NULL;\t\t\t\t# 0\n\tpublic $Prefix;\t\t\t\t\t\t# Special host message prefix character\n\tpublic $Interval;\t\t\t\t\t# Time in ms between NLP or MCI (0 = none)\n\n\tpublic $Admin;\t\t\t\t\t\t# Admin password (if set in LFS)\n\tpublic $IName;\t\t\t\t\t\t# A short name for your program\n}; function IS_ISI() { return new IS_ISI; }\n\n// NOTE 1) UDPPort field when you connect using UDP :\n\n// zero     : LFS sends all packets to the port of the incoming packet\n// non-zero : LFS sends all packets to the specified UDPPort\n\n// NOTE 2) UDPPort field when you connect using TCP :\n\n// zero     : LFS sends NLP / MCI packets using your TCP connection\n// non-zero : LFS sends NLP / MCI packets to the specified UDPPort\n\n// NOTE 3) Flags field (set the relevant bits to turn on the option) :\n\ndefine('ISF_RES_0',\t\t1);\t\t// bit  0 : spare\ndefine('ISF_RES_1',\t\t2);\t\t// bit  1 : spare\ndefine('ISF_LOCAL',\t\t4);\t\t// bit  2 : guest or single player\ndefine('ISF_MSO_COLS',\t8);\t\t// bit  3 : keep colours in MSO text\ndefine('ISF_NLP',\t\t16);\t// bit  4 : receive NLP packets\ndefine('ISF_MCI',\t\t32);\t// bit  5 : receive MCI packets\ndefine('ISF_CON',\t\t64);\t// bit  6 : receive CON packets\ndefine('ISF_OBH',\t\t128);\t// bit  7 : receive OBH packets\ndefine('ISF_HLV',\t\t256);\t// bit  8 : receive HLV packets\ndefine('ISF_AXM_LOAD',\t512);\t// bit  9 : receive AXM when loading a layout\ndefine('ISF_AXM_EDIT',\t1024);\t// bit 10 : receive AXM when changing objects\n$ISF = array(ISF_RES_0 => 'ISF_RES_0', ISF_RES_1 => 'ISF_RES_1', ISF_LOCAL => 'ISF_LOCAL', ISF_MSO_COLS => 'ISF_MSO_COLS', ISF_NLP => 'ISF_NLP', ISF_MCI => 'ISF_MCI', ISF_CON => 'ISF_CON', ISF_OBH => 'ISF_OBH', ISF_HLV => 'ISF_HLV', ISF_AXM_LOAD => 'ISF_AXM_LOAD', ISF_AXM_EDIT => 'ISF_AXM_EDIT');\n\n// In most cases you should not set both ISF_NLP and ISF_MCI flags\n// because all IS_NLP information is included in the IS_MCI packet.\n\n// The ISF_LOCAL flag is important if your program creates buttons.\n// It should be set if your program is not a host control system.\n// If set, then buttons are created in the local button area, so\n// avoiding conflict with the host buttons and allowing the user\n// to switch them with SHIFT+B rather than SHIFT+I.\n\n// NOTE 4) Prefix field, if set when initialising InSim on a host :\n\n// Messages typed with this prefix will be sent to your InSim program\n// on the host (in IS_MSO) and not displayed on anyone's screen.\n\n\n// ENUMERATIONS FOR PACKET TYPES\n// =============================\n\n// the second byte of any packet is one of these\ndefine('ISP_NONE',\t0);\t//  0\t\t\t\t\t: not used\ndefine('ISP_ISI',\t1);\t//  1 - inStruction\t\t: insim initialise\ndefine('ISP_VER',\t2);\t//  2 - info\t\t\t: version info\ndefine('ISP_TINY',\t3);\t//  3 - both ways\t\t: multi purpose\ndefine('ISP_SMALL',\t4);\t//  4 - both ways\t\t: multi purpose\ndefine('ISP_STA',\t5);\t//  5 - info\t\t\t: state info\ndefine('ISP_SCH',\t6);\t//  6 - inStruction\t\t: single character\ndefine('ISP_SFP',\t7);\t//  7 - inStruction\t\t: state flags pack\ndefine('ISP_SCC',\t8);\t//  8 - inStruction\t\t: set car camera\ndefine('ISP_CPP',\t9);\t//  9 - both ways\t\t: cam pos pack\ndefine('ISP_ISM',\t10);// 10 - info\t\t\t: start multiplayer\ndefine('ISP_MSO',\t11);// 11 - info\t\t\t: message out\ndefine('ISP_III',\t12);// 12 - info\t\t\t: hidden /i message\ndefine('ISP_MST',\t13);// 13 - inStruction\t\t: type message or /command\ndefine('ISP_MTC',\t14);// 14 - inStruction\t\t: message to a connection\ndefine('ISP_MOD',\t15);// 15 - inStruction\t\t: set screen mode\ndefine('ISP_VTN',\t16);// 16 - info\t\t\t: vote notification\ndefine('ISP_RST',\t17);// 17 - info\t\t\t: race start\ndefine('ISP_NCN',\t18);// 18 - info\t\t\t: new connection\ndefine('ISP_CNL',\t19);// 19 - info\t\t\t: connection left\ndefine('ISP_CPR',\t20);// 20 - info\t\t\t: connection renamed\ndefine('ISP_NPL',\t21);// 21 - info\t\t\t: new player (joined race)\ndefine('ISP_PLP',\t22);// 22 - info\t\t\t: player pit (keeps slot in race)\ndefine('ISP_PLL',\t23);// 23 - info\t\t\t: player leave (spectate - loses slot)\ndefine('ISP_LAP',\t24);// 24 - info\t\t\t: lap time\ndefine('ISP_SPX',\t25);// 25 - info\t\t\t: split x time\ndefine('ISP_PIT',\t26);// 26 - info\t\t\t: pit stop start\ndefine('ISP_PSF',\t27);// 27 - info\t\t\t: pit stop finish\ndefine('ISP_PLA',\t28);// 28 - info\t\t\t: pit lane enter / leave\ndefine('ISP_CCH',\t29);// 29 - info\t\t\t: camera changed\ndefine('ISP_PEN',\t30);// 30 - info\t\t\t: penalty given or cleared\ndefine('ISP_TOC',\t31);// 31 - info\t\t\t: take over car\ndefine('ISP_FLG',\t32);// 32 - info\t\t\t: flag (yellow or blue)\ndefine('ISP_PFL',\t33);// 33 - info\t\t\t: player flags (help flags)\ndefine('ISP_FIN',\t34);// 34 - info\t\t\t: finished race\ndefine('ISP_RES',\t35);// 35 - info\t\t\t: result confirmed\ndefine('ISP_REO',\t36);// 36 - both ways\t\t: reorder (info or inStruction)\ndefine('ISP_NLP',\t37);// 37 - info\t\t\t: node and lap packet\ndefine('ISP_MCI',\t38);// 38 - info\t\t\t: multi car info\ndefine('ISP_MSX',\t39);// 39 - inStruction\t\t: type message\ndefine('ISP_MSL',\t40);// 40 - inStruction\t\t: message to local computer\ndefine('ISP_CRS',\t41);// 41 - info\t\t\t: car reset\ndefine('ISP_BFN',\t42);// 42 - both ways\t\t: delete buttons / receive button requests\ndefine('ISP_AXI',\t43);// 43 - info\t\t\t: autocross layout information\ndefine('ISP_AXO',\t44);// 44 - info\t\t\t: hit an autocross object\ndefine('ISP_BTN',\t45);// 45 - inStruction\t\t: show a button on local or remote screen\ndefine('ISP_BTC',\t46);// 46 - info\t\t\t: sent when a user clicks a button\ndefine('ISP_BTT',\t47);// 47 - info\t\t\t: sent after typing into a button\ndefine('ISP_RIP',\t48);// 48 - both ways\t\t: replay information packet\ndefine('ISP_SSH',\t49);// 49 - both ways\t\t: screenshot\ndefine('ISP_CON',\t50);// 50 - info\t\t\t: contact (collision report)\ndefine('ISP_OBH',\t51);// 51 - info\t\t\t: contact car + object (collision report)\ndefine('ISP_HLV',\t52);// 52 - info\t\t\t: report incidents that would violate HLVC\ndefine('ISP_PLC',\t53);// 53 - instruction\t\t: player cars\ndefine('ISP_AXM',\t54);// 54 - both ways\t\t: autocross multiple objects\ndefine('ISP_ACR',\t55);// 55 - info\t\t\t: admin command report\n$ISP = array(ISP_NONE => 'ISP_NONE', ISP_ISI => 'ISP_ISI', ISP_VER => 'ISP_VER', ISP_TINY => 'ISP_TINY', ISP_SMALL => 'ISP_SMALL', ISP_STA => 'ISP_STA', ISP_SCH => 'ISP_SCH', ISP_SFP => 'ISP_SFP', ISP_SCC => 'ISP_SCC', ISP_CPP => 'ISP_CPP', ISP_ISM => 'ISP_ISM', ISP_MSO => 'ISP_MSO', ISP_III => 'ISP_III', ISP_MST => 'ISP_MST', ISP_MTC => 'ISP_MTC', ISP_MOD => 'ISP_MOD', ISP_VTN => 'ISP_VTN', ISP_RST => 'ISP_RST', ISP_NCN => 'ISP_NCN', ISP_MTC => 'ISP_MTC', ISP_CNL => 'ISP_CNL', ISP_CPR => 'ISP_CPR', ISP_NPL => 'ISP_NPL', ISP_PLP => 'ISP_PLP', ISP_PLL => 'ISP_PLL', ISP_LAP => 'ISP_LAP', ISP_SPX => 'ISP_SPX', ISP_PIT => 'ISP_PIT', ISP_PSF => 'ISP_PSF', ISP_PLA => 'ISP_PLA', ISP_CCH => 'ISP_CCH', ISP_PEN => 'ISP_PEN', ISP_TOC => 'ISP_TOC', ISP_FLG => 'ISP_FLG', ISP_PFL => 'ISP_PFL', ISP_FIN => 'ISP_FIN', ISP_RES => 'ISP_RES', ISP_REO => 'ISP_REO', ISP_NLP => 'ISP_NLP', ISP_MCI => 'ISP_MCI', ISP_MSX => 'ISP_MSX', ISP_MSL => 'ISP_MSL', ISP_CRS => 'ISP_CRS', ISP_BFN => 'ISP_BFN', ISP_AXI => 'ISP_AXI', ISP_AXO => 'ISP_AXO', ISP_BTN => 'ISP_BTN', ISP_BTC => 'ISP_BTC', ISP_BTT => 'ISP_BTT', ISP_RIP => 'ISP_RIP', ISP_SSH => 'ISP_SSH', ISP_CON => 'ISP_CON', ISP_OBH => 'ISP_OBH', ISP_HLV => 'ISP_HLV', ISP_PLC => 'ISP_PLC', ISP_AXM => 'ISP_AXM', ISP_ACR => 'ISP_ACR');\n\n// the fourth byte of an IS_TINY packet is one of these\ndefine('TINY_NONE',\t0);\t//  0 - keep alive\t\t: see \"maintaining the connection\"\ndefine('TINY_VER',\t1);\t//  1 - info request\t: get version\ndefine('TINY_CLOSE',2);\t//  2 - inStruction\t\t: close insim\ndefine('TINY_PING',\t3);\t//  3 - ping request\t: external progam requesting a reply\ndefine('TINY_REPLY',4);\t//  4 - ping reply\t\t: reply to a ping request\ndefine('TINY_VTC',\t5);\t//  5 - both ways\t\t: game vote cancel (info or request)\ndefine('TINY_SCP',\t6);\t//  6 - info request\t: send camera pos\ndefine('TINY_SST',\t7);\t//  7 - info request\t: send state info\ndefine('TINY_GTH',\t8);\t//  8 - info request\t: get time in hundredths (i.e. SMALL_RTP)\ndefine('TINY_MPE',\t9);\t//  9 - info\t\t\t: multi player end\ndefine('TINY_ISM',\t10);// 10 - info request\t: get multiplayer info (i.e. ISP_ISM)\ndefine('TINY_REN',\t11);// 11 - info\t\t\t: race end (return to game setup screen)\ndefine('TINY_CLR',\t12);// 12 - info\t\t\t: all players cleared from race\ndefine('TINY_NCN',\t13);// 13 - info request\t: get all connections\ndefine('TINY_NPL',\t14);// 14 - info request\t: get all players\ndefine('TINY_RES',\t15);// 15 - info request\t: get all results\ndefine('TINY_NLP',\t16);// 16 - info request\t: send an IS_NLP\ndefine('TINY_MCI',\t17);// 17 - info request\t: send an IS_MCI\ndefine('TINY_REO',\t18);// 18 - info request\t: send an IS_REO\ndefine('TINY_RST',\t19);// 19 - info request\t: send an IS_RST\ndefine('TINY_AXI',\t20);// 20 - info request\t: send an IS_AXI - AutoX Info\ndefine('TINY_AXC',\t21);// 21 - info\t\t\t: autocross cleared\ndefine('TINY_RIP',\t22);// 22 - info request\t: send an IS_RIP - Replay Information Packet\n$TINY = array(TINY_NONE => 'TINY_NONE', TINY_VER => 'TINY_VER', TINY_CLOSE => 'TINY_CLOSE', TINY_PING => 'TINY_PING', TINY_REPLY => 'TINY_REPLY', TINY_VTC => 'TINY_VTC', TINY_SCP => 'TINY_SCP', TINY_SST => 'TINY_SST', TINY_GTH => 'TINY_GTH', TINY_MPE => 'TINY_MPE', TINY_ISM => 'TINY_ISM', TINY_REN => 'TINY_REN', TINY_CLR => 'TINY_CLR', TINY_NCN => 'TINY_NCN', TINY_NPL => 'TINY_NPL', TINY_RES => 'TINY_RES', TINY_NLP => 'TINY_NLP', TINY_MCI => 'TINY_MCI', TINY_REO => 'TINY_REO', TINY_RST => 'TINY_RST', TINY_AXI => 'TINY_AXI', TINY_AXC => 'TINY_AXC', TINY_RIP => 'TINY_RIP');\n\n// the fourth byte of an IS_SMALL packet is one of these\ndefine('SMALL_NONE',0);\t//  0\t\t\t\t\t: not used\ndefine('SMALL_SSP',\t1);\t//  1 - inStruction\t\t: start sending positions\ndefine('SMALL_SSG',\t2);\t//  2 - inStruction\t\t: start sending gauges\ndefine('SMALL_VTA',\t3);\t//  3 - report\t\t\t: vote action\ndefine('SMALL_TMS',\t4);\t//  4 - inStruction\t\t: time stop\ndefine('SMALL_STP',\t5);\t//  5 - inStruction\t\t: time step\ndefine('SMALL_RTP',\t6);\t//  6 - info\t\t\t: race time packet (reply to GTH)\ndefine('SMALL_NLI',\t7);\t//  7 - inStruction\t\t: set node lap interval\n$SMALL = array(SMALL_NONE => 'SMALL_NONE', SMALL_SSP => 'SMALL_SSP', SMALL_SSG => 'SMALL_SSG', SMALL_VTA => 'SMALL_VTA', SMALL_TMS => 'SMALL_TMS', SMALL_STP => 'SMALL_STP', SMALL_RTP => 'SMALL_RTP', SMALL_NLI => 'SMALL_NLI');\n\n\n// GENERAL PURPOSE PACKETS - IS_TINY (4 bytes) and IS_SMALL (8 bytes)\n// =======================\n\n// To avoid defining several packet Structures that are exactly the same, and to avoid\n// wasting the ISP_ enumeration, IS_TINY is used at various times when no additional data\n// other than SubT is required.  IS_SMALL is used when an additional integer is needed.\n\n// IS_TINY - used for various requests, replies and reports\n\nclass IS_TINY extends Struct // General purpose 4 byte packet\n{\n\tconst PACK = 'CCCC';\n\tconst UNPACK = 'CSize/CType/CReqI/CSubT';\n\n\tprotected $Size = 4;\t\t\t\t# always 4\n\tprotected $Type = ISP_TINY;\t\t\t# always ISP_TINY\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless it is an info request or a reply to an info request\n\tpublic $SubT;\t\t\t\t\t\t# subtype, from TINY_ enumeration (e.g. TINY_RACE_END)\n}; function IS_TINY() { return new IS_TINY; }\n\n// IS_SMALL - used for various requests, replies and reports\n\nclass IS_SMALL extends Struct // General purpose 8 byte packet\n{\n\tconst PACK = 'CCCCV';\n\tconst UNPACK = 'CSize/CType/CReqI/CSubT/VUVal';\n\n\tprotected $Size = 8;\t\t\t\t# always 8\n\tprotected $Type = ISP_SMALL;\t\t# always ISP_SMALL\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless it is an info request or a reply to an info request\n\tpublic $SubT;\t\t\t\t\t\t# subtype, from SMALL_ enumeration (e.g. SMALL_SSP)\n\n\tpublic $UVal;\t\t\t\t\t\t# value (e.g. for SMALL_SSP this would be the OutSim packet rate)\n}; function IS_SMALL() { return new IS_SMALL; }\n\n\n// VERSION REQUEST\n// ===============\n\n// It is advisable to request version information as soon as you have connected, to\n// avoid problems when connecting to a host with a later or earlier version.  You will\n// be sent a version packet on connection if you set ReqI in the IS_ISI packet.\n\n// This version packet can be sent on request :\n\nclass IS_VER extends Struct // VERsion\n{\n\tconst PACK = 'CCCxa8a6v';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/a8Version/a6Product/vInSimVer';\n\n\tprotected $Size = 20;\t\t\t\t# 20\n\tprotected $Type = ISP_VER;\t\t\t# ISP_VERSION\n\tpublic $ReqI;\t\t\t\t\t\t# ReqI as received in the request packet\n\tprotected $Zero;\n\n\tpublic $Version;\t\t\t\t\t# LFS version, e.g. 0.3G\n\tpublic $Product;\t\t\t\t\t# Product : DEMO or S1\n\tpublic $InSimVer = INSIM_VERSION;\t# InSim Version : increased when InSim packets change\n}; function IS_VER() { return new IS_VER; }\n\n// To request an InSimVersion packet at any time, send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_VER\t\t(request an IS_VER)\n\n\n// CLOSING InSim\n// =============\n\n// You can send this IS_TINY to close the InSim connection to your program :\n\n// ReqI : 0\n// SubT : TINY_CLOSE\t(close this connection)\n\n// Another InSimInit packet is then required to start operating again.\n\n// You can shut down InSim completely and stop it listening at all by typing /insim=0\n// into LFS (or send a MsgTypePack to do the same thing).\n\n\n// MAINTAINING THE CONNECTION - IMPORTANT\n// ==========================\n\n// If InSim does not receive a packet for 70 seconds, it will close your connection.\n// To open it again you would need to send another InSimInit packet.\n\n// LFS will send a blank IS_TINY packet like this every 30 seconds :\n\n// ReqI : 0\n// SubT : TINY_NONE\t\t(keep alive packet)\n\n// You should reply with a blank IS_TINY packet :\n\n// ReqI : 0\n// SubT : TINY_NONE\t\t(has no effect other than resetting the timeout)\n\n// NOTE : If you want to request a reply from LFS to check the connection\n// at any time, you can send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_PING\t\t(request a TINY_REPLY)\n\n// LFS will reply with this IS_TINY :\n\n// ReqI : non-zero\t\t(as received in the request packet)\n// SubT : TINY_REPLY\t(reply to ping)\n\n\n// STATE REPORTING AND REQUESTS\n// ============================\n\n// LFS will send a StatePack any time the info in the StatePack changes.\n\nclass IS_STA extends Struct // STAte\n{\n\tconst PACK = 'CCCxfvCCCCCCCCxxa6CC';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/fReplaySpeed/vFlags/CInGameCam/CViewPLID/CNumP/CNumConns/CNumFinished/CRaceInProg/CQualMins/CRaceLaps/CSpare2/CSpare3/a6Track/CWeather/CWind';\n\n\tprotected $Size = 28;\t\t\t\t# 28\n\tprotected $Type = ISP_STA;\t\t\t# ISP_STA\n\tpublic $ReqI;\t\t\t\t\t\t# ReqI if replying to a request packet\n\tprotected $Zero;\n\n\tpublic $ReplaySpeed;\t\t\t\t# 4-byte float - 1.0 is normal speed\n\n\tpublic $Flags;\t\t\t\t\t\t# ISS state flags (see below)\n\tpublic $InGameCam;\t\t\t\t\t# Which type of camera is selected (see below)\n\tpublic $ViewPLID;\t\t\t\t\t# Unique ID of viewed player (0 = none)\n\n\tpublic $NumP;\t\t\t\t\t\t# Number of players in race\n\tpublic $NumConns;\t\t\t\t\t# Number of connections including host\n\tpublic $NumFinished;\t\t\t\t# Number finished or qualified\n\tpublic $RaceInProg;\t\t\t\t\t# 0 - no race / 1 - race / 2 - qualifying\n\n\tpublic $QualMins;\n\tpublic $RaceLaps;\t\t\t\t\t# see \"RaceLaps\" near the top of this document\n\tprotected $Spare2;\n\tprotected $Spare3;\n\n\tpublic $Track;\t\t\t\t\t\t# short name for track e.g. FE2R\n\tpublic $Weather;\t\t\t\t\t# 0,1,2...\n\tpublic $Wind;\t\t\t\t\t\t# 0=off 1=weak 2=strong\n}; function IS_STA() { return new IS_STA; }\n\n// InGameCam is the in game selected camera mode (which is\n// still selected even if LFS is actually in SHIFT+U mode).\n// For InGameCam's values, see \"View identifiers\" below.\n\n// ISS state flags\n\ndefine('ISS_GAME',\t\t\t1);\t\t// in game (or MPR)\ndefine('ISS_REPLAY',\t\t2);\t\t// in SPR\ndefine('ISS_PAUSED',\t\t4);\t\t// paused\ndefine('ISS_SHIFTU',\t\t8);\t\t// SHIFT+U mode\ndefine('ISS_16',\t\t\t16);\t// UNUSED\ndefine('ISS_SHIFTU_FOLLOW',\t32);\t// FOLLOW view\ndefine('ISS_SHIFTU_NO_OPT',\t64);\t// SHIFT+U buttons hidden\ndefine('ISS_SHOW_2D',\t\t128);\t// showing 2d display\ndefine('ISS_FRONT_END',\t\t256);\t// entry screen\ndefine('ISS_MULTI',\t\t\t512);\t// multiplayer mode\ndefine('ISS_MPSPEEDUP',\t\t1024);\t// multiplayer speedup option\ndefine('ISS_WINDOWED',\t\t2048);\t// LFS is running in a window\ndefine('ISS_SOUND_MUTE',\t4096);\t// sound is switched off\ndefine('ISS_VIEW_OVERRIDE',\t8192);\t// override user view\ndefine('ISS_VISIBLE',\t\t16384);\t// InSim buttons visible\n$ISS = array(ISS_GAME => 'ISS_GAME', ISS_REPLAY => 'ISS_REPLAY', ISS_PAUSED => 'ISS_PAUSED', ISS_SHIFTU => 'ISS_SHIFTU', ISS_16 => 'ISS_16', ISS_SHIFTU_FOLLOW => 'ISS_SHIFTU_FOLLOW', ISS_SHIFTU_NO_OPT => 'ISS_SHIFTU_NO_OPT', ISS_SHOW_2D => 'ISS_SHOW_2D', ISS_FRONT_END => 'ISS_FRONT_END', ISS_MULTI => 'ISS_MULTI', ISS_MPSPEEDUP => 'ISS_MPSPEEDUP', ISS_WINDOWED => 'ISS_WINDOWED', ISS_SOUND_MUTE => 'ISS_SOUND_MUTE', ISS_VIEW_OVERRIDE => 'ISS_VIEW_OVERRIDE', ISS_VISIBLE => 'ISS_VISIBLE');\n\n// To request a StatePack at any time, send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_SST\t\t(Send STate)\n\n// Setting states\n\n// These states can be set by a special packet :\n\n// ISS_SHIFTU_NO_OPT\t- SHIFT+U buttons hidden\n// ISS_SHOW_2D\t\t\t- showing 2d display\n// ISS_MPSPEEDUP\t\t- multiplayer speedup option\n// ISS_SOUND_MUTE\t\t- sound is switched off\n\nclass IS_SFP extends Struct // State Flags Pack\n{\n\tconst PACK = 'CCCxvCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/vFlag/COffOn/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_SFP;\t\t\t# ISP_SFP\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tprotected $Zero;\n\n\tpublic $Flag;\t\t\t\t\t\t# the state to set\n\tpublic $OffOn;\t\t\t\t\t\t# 0 = off / 1 = on\n\tprotected $Sp3;\t\t\t\t\t\t# spare\n}; function IS_SFP() { return new IS_SFP; }\n\n// Other states must be set by using keypresses or messages (see below)\n\n\n// SCREEN MODE\n// ===========\n\n// You can send this packet to LFS to set the screen mode :\n\nclass IS_MOD extends Struct // MODe : send to LFS to change screen mode\n{\n\tconst PACK = 'CCxxVVVV';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/VBits16/VRR/VWidth/VHeight';\n\n\tprotected $Size = 20;\t\t\t\t# 20\n\tprotected $Type = ISP_MOD;\t\t\t# ISP_MOD\n\tpublic $ReqI;\t\t\t\t\t\t# 0\n\tpublic $Zero;\n\n\tpublic $Bits16;\t\t\t\t\t\t# set to choose 16-bit\n\tpublic $RR;\t\t\t\t\t\t\t# refresh rate - zero for default\n\tpublic $Width;\t\t\t\t\t\t# 0 means go to window\n\tpublic $Height;\t\t\t\t\t\t# 0 means go to window\n}; function IS_MOD() { return new IS_MOD; }\n\n// The refresh rate actually selected by LFS will be the highest available rate\n// that is less than or equal to the specified refresh rate.  Refresh rate can\n// be specified as zero in which case the default refresh rate will be used.\n\n// If Width and Height are both zero, LFS will switch to windowed mode.\n\n\n// TEXT MESSAGES AND KEY PRESSES\n// ==============================\n\n// You can send 64-byte text messages to LFS as if the user had typed them in.\n// Messages that appear on LFS screen (up to 128 bytes) are reported to the\n// external program.  You can also send simulated keypresses to LFS.\n\n// MESSAGES OUT (FROM LFS)\n// ------------\n\nclass IS_MSO extends Struct // MSg Out - system messages and user messages\n{\n\tconst PACK = 'CCxxCCCCa128';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CUCID/CPLID/CUserType/CTextStart/a128Msg';\n\n\tprotected $Size = 136;\t\t\t\t# 136\n\tprotected $Type = ISP_MSO;\t\t\t# ISP_MSO\n\tprotected $ReqI = NULL;\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $UCID = 0;\t\t\t\t\t# connection's unique id (0 = host)\n\tpublic $PLID = 0;\t\t\t\t\t# player's unique id (if zero, use UCID)\n\tpublic $UserType;\t\t\t\t\t# set if typed by a user (see User Values below)\n\tpublic $TextStart;\t\t\t\t\t# first character of the actual text (after player name)\n\n\tpublic $Msg;\n}; function IS_MSO() { return new IS_MSO; }\n\n// User Values (for UserType byte)\n\ndefine('MSO_SYSTEM',\t0);\t\t// 0 - system message\ndefine('MSO_USER',\t\t1);\t\t// 1 - normal visible user message\ndefine('MSO_PREFIX',\t2);\t\t// 2 - hidden message starting with special prefix (see ISI)\ndefine('MSO_O',\t\t\t3);\t\t// 3 - hidden message typed on local pc with /o command\ndefine('MSO_NUM',\t\t4);\n$MSO = array(MSO_SYSTEM => 'MSO_SYSTEM', MSO_USER => 'MSO_USER', MSO_PREFIX => 'MSO_PREFIX', MSO_O => 'MSO_O', MSO_NUM => 'MSO_NUM');\n\n// NOTE : Typing \"/o MESSAGE\" into LFS will send an IS_MSO with UserType = MSO_O\n\nclass IS_III extends Struct // InsIm Info - /i message from user to host's InSim\n{\n\tconst PACK = 'CCxxCCxxa64';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CUCID/CPLID/CSp2/CSp3/a64Msg';\n\n\tprotected $Size = 72;\t\t\t\t# 72\n\tprotected $Type = ISP_III;\t\t\t# ISP_III\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $UCID = 0;\t\t\t\t\t# connection's unique id (0 = host)\n\tpublic $PLID = 0;\t\t\t\t\t# player's unique id (if zero, use UCID)\n\tprotected $Sp2 = NULL;\n\tprotected $Sp3 = NULL;\n\n\tpublic $Msg;\n}; function IS_III() { return new IS_III; }\n\nclass IS_ACR extends Struct // Admin Command Report - any user typed an admin command\n{\n\tconst PACK = 'CCxxCCxxa64';\n\tconst UNPACK = 'CSize/CType/xReqI/xZero/CUCID/CAdmin/CResult/xSp3/a64Text';\n\n\tprotected $Size = 72;\t\t\t\t# 72\n\tprotected $Type = ISP_ACR;\t\t\t# ISP_ACR\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $UCID;\t\t\t\t\t\t# connection's unique id (0 = host)\n\tpublic $Admin;\t\t\t\t\t\t# set if user is an admin\n\tpublic $Result;\t\t\t\t\t\t# 1 - processed / 2 - rejected / 3 - unknown command\n\tprivate $Sp3;\n\n\tpublic $Text;\n}; function IS_ACR() { return new IS_ACR; }\n\n// MESSAGES IN (TO LFS)\n// -----------\n\nclass IS_MST extends Struct\t\t// MSg Type - send to LFS to type message or command\n{\n\tconst PACK = 'CCxxa64';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/a64Msg';\n\n\tprotected $Size = 68;\t\t\t\t# 68\n\tprotected $Type = ISP_MST;\t\t\t# ISP_MST\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $Msg;\t\t\t\t\t\t# last byte must be zero\n\n\tpublic function pack()\n\t{\n\t\tif (strLen($this->Msg) > 63)\n\t\t{\n\t\t\tforeach(explode(\"\\n\", wordwrap($this->Msg, 63, \"\\n\", TRUE)) as $Msg)\n\t\t\t\t$this->Msg($Msg)->Send();\n\t\t\treturn;\n\t\t}\n\t\treturn parent::pack();\n\t}\n}; function IS_MST() { return new IS_MST; }\n\nclass IS_MSX extends Struct\t\t// MSg eXtended - like MST but longer (not for commands)\n{\n\tconst PACK = 'CCxxa96';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/a96Msg';\n\n\tprotected $Size = 100;\t\t\t\t# 100\n\tprotected $Type = ISP_MSX;\t\t\t# ISP_MSX\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $Msg;\t\t\t\t\t\t# last byte must be zero\n\n\tpublic function pack()\n\t{\n\t\tif (strLen($this->Msg) > 95)\n\t\t{\n\t\t\tforeach(explode(\"\\n\", wordwrap($this->Msg, 95, \"\\n\", TRUE)) as $Msg)\n\t\t\t\t$this->Msg($Msg)->Send();\n\t\t}\n\t\treturn parent::pack();\n\t}\n}; function IS_MSX() { return new IS_MSX; }\n\nclass IS_MSL extends Struct\t\t// MSg Local - message to appear on local computer only\n{\n\tconst PACK = 'CCxCa128';\n\tconst UNPACK = 'CSize/CType/CReqI/CSound/a128Msg';\n\n\tprotected $Size = 132;\t\t\t\t# 132\n\tprotected $Type = ISP_MSL;\t\t\t# ISP_MSL\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tpublic $Sound = SND_SILENT;\t\t\t# sound effect (see Message Sounds below)\n\n\tpublic $Msg;\t\t\t\t\t\t# last byte must be zero\n\n\tpublic function pack()\n\t{\n\t\tif (strLen($this->Msg) > 127)\n\t\t{\n\t\t\tforeach(explode(\"\\n\", wordwrap($this->Msg, 127, \"\\n\", TRUE)) as $Msg)\n\t\t\t\t$this->Msg($Msg)->Send();\n\t\t}\n\t\treturn parent::pack();\n\t}\n}; function IS_MSL() { return new IS_MSL; }\n\nclass IS_MTC extends Struct\t\t// Msg To Connection - hosts only - send to a connection / a player / all\n{\n\tconst PACK = 'CCxCCCxxa128';\n\tconst UNPACK = 'CSize/CType/CReqI/CSound/CUCID/CPLID/CSp2/CSp3/a128Text';\n\n\tprotected $Size = 136;\t\t\t\t# 8 + TEXT_SIZE (TEXT_SIZE = 4, 8, 12... 128)\n\tprotected $Type = ISP_MTC;\t\t\t# ISP_MTC\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tpublic $Sound = NULL;\t\t\t\t# sound effect (see Message Sounds below)\n\n\tpublic $UCID = 0;\t\t\t\t\t# connection's unique id (0 = host / 255 = all)\n\tpublic $PLID = 0;\t\t\t\t\t# player's unique id (if zero, use UCID)\n\tprotected $Sp2 = NULL;\n\tprotected $Sp3 = NULL;\n\n\tpublic $Text;\t\t\t\t\t\t# up to 128 characters of text - last byte must be zero\n\n\tpublic function pack()\n\t{\n\t\tif (strLen($this->Text) > 127)\n\t\t{\n\t\t\tforeach(explode(\"\\n\", wordwrap($this->Text, 127, \"\\n\", TRUE)) as $Text)\n\t\t\t\t$this->Text($Text)->Send();\n\t\t}\n\t\treturn parent::pack();\n\t}\n}; function IS_MTC() { return new IS_MTC; }\n\n// Message Sounds (for Sound byte)\n\ndefine('SND_SILENT', \t0);\ndefine('SND_MESSAGE',\t1);\ndefine('SND_SYSMESSAGE',2);\ndefine('SND_INVALIDKEY',3);\ndefine('SND_ERROR', \t4);\ndefine('SND_NUM',\t\t5);\n$SND = array(SND_SILENT => 'SND_SILENT', SND_MESSAGE => 'SND_MESSAGE', SND_SYSMESSAGE => 'SND_SYSMESSAGE', SND_INVALIDKEY => 'SND_INVALIDKEY', SND_ERROR => 'SND_ERROR', SND_NUM => 'SND_NUM');\n\n// You can send individual key presses to LFS with the IS_SCH packet.\n// For standard keys (e.g. V and H) you should send a capital letter.\n// This does not work with some keys like F keys, arrows or CTRL keys.\n// You can also use IS_MST with the /press /shift /ctrl /alt commands.\n\nclass IS_SCH extends Struct\t\t// Single CHaracter\n{\n\tconst PACK = 'CCxxCCxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CCharB/CFlags/CSpare2/CSpare3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_SCH;\t\t\t# ISP_SCH\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $CharB;\t\t\t\t\t\t# key to press\n\tpublic $Flags;\t\t\t\t\t\t# bit 0 : SHIFT / bit 1 : CTRL\n\tprotected $Spare2 = NULL;\n\tprotected $Spare3 = NULL;\n}; function IS_SCH() { return new IS_SCH; }\n\n\n// MULTIPLAYER NOTIFICATION\n// ========================\n\n// LFS will send this packet when a host is started or joined :\n\nclass IS_ISM extends Struct\t\t// InSim Multi\n{\n\tconst PACK = 'CCCxCxxxa32';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CHost/CSp1/CSp2/CSp3/a32HName';\n\n\tprotected $Size = 40;\t\t\t\t# 40\n\tprotected $Type = ISP_ISM;\t\t\t# ISP_ISM\n\tprotected $ReqI = 0;\t\t\t\t# usually 0 / or if a reply : ReqI as received in the TINY_ISM\n\tprotected $Zero = NULL;\n\n\tpublic $Host;\t\t\t\t\t\t# 0 = guest / 1 = host\n\tprotected $Sp1 = NULL;\n\tprotected $Sp2 = NULL;\n\tprotected $Sp3 = NULL;\n\n\tpublic $HName;\t\t\t\t\t\t# the name of the host joined or started\n}; function IS_ISM() { return new IS_ISM; }\n\n// On ending or leaving a host, LFS will send this IS_TINY :\n\n// ReqI : 0\n// SubT : TINY_MPE\t\t(MultiPlayerEnd)\n\n// To request an IS_ISM packet at any time, send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_ISM\t\t(request an IS_ISM)\n\n// NOTE : If LFS is not in multiplayer mode, the host name in the ISM will be empty.\n\n\n// VOTE NOTIFY AND CANCEL\n// ======================\n\n// LFS notifies the external program of any votes to restart or qualify\n\n// The Vote Actions are defined as :\n\ndefine('VOTE_NONE',\t\t0);\t\t// 0 - no vote\ndefine('VOTE_END',\t\t1);\t\t// 1 - end race\ndefine('VOTE_RESTART',\t2);\t\t// 2 - restart\ndefine('VOTE_QUALIFY',\t3);\t\t// 3 - qualify\ndefine('VOTE_NUM',\t\t4);\n$VOTE = array(VOTE_NONE => 'VOTE_NONE', VOTE_END => 'VOTE_END', VOTE_RESTART => 'VOTE_RESTART', VOTE_QUALIFY => 'VOTE_QUALIFY', VOTE_NUM => 'VOTE_NUM');\n\nclass IS_VTN extends Struct\t\t// VoTe Notify\n{\n\tconst PACK = 'CCxxCCxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CUCID/CAction/CSpare2/CSpare3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_VTN;\t\t\t# ISP_VTN\n\tpublic $ReqI;\t\t\t\t\t\t# 0\n\tprotected $Zero;\n\n\tpublic $UCID;\t\t\t\t\t\t# connection's unique id\n\tpublic $Action;\t\t\t\t\t\t# VOTE_X (Vote Action as defined above)\n\tprotected $Spare2;\n\tprotected $Spare3;\n}; function IS_VTN() { return new IS_VTN; }\n\n// When a vote is cancelled, LFS sends this IS_TINY\n\n// ReqI : 0\n// SubT : TINY_VTC\t\t(VoTe Cancelled)\n\n// When a vote is completed, LFS sends this IS_SMALL\n\n// ReqI : 0\n// SubT : SMALL_VTA  \t(VoTe Action)\n// UVal : action \t\t(VOTE_X - Vote Action as defined above)\n\n// You can inStruct LFS host to cancel a vote using an IS_TINY\n\n// ReqI : 0\n// SubT : TINY_VTC\t\t(VoTe Cancel)\n\n\n// ALLOWED CARS\n// ============\n\n// You can send a packet to limit the cars that can be used by a given connection\n// The resulting set of selectable cars is a subset of the cars set to be available\n// on the host (by the /cars command)\n\n// For example :\n// Cars = 0          ... no cars can be selected on the specified connection\n// Cars = 0xffffffff ... all the host's available cars can be selected\n\nclass IS_PLC extends Struct // PLayer Cars\n{\n\tconst PACK = 'CCCxCxxxV';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CUCID/CSp1/CSp2/CSp3/VCars';\n\n\tprotected $Size = 12;\t\t\t\t# 12\n\tprotected $Type = ISP_PLC;\t\t\t# ISP_PLC\n\tpublic $ReqI;\t\t\t\t\t\t# 0\n\tprotected $Zero = NULL;\n\n\tpublic $UCID;\t\t\t\t\t\t# connection's unique id (0 = host / 255 = all)\n\tprotected $Sp1;\n\tprotected $Sp2;\n\tprotected $Sp3;\n\n\tpublic $Cars;\t\t\t\t\t\t# allowed cars - see below\n}; function IS_PLC() { return new IS_PLC; }\n\n// XF GTI\t\t\t-       1\n// XR GT\t\t\t-       2\n// XR GT TURBO\t\t-       4\n// RB4 GT\t\t\t-       8\n// FXO TURBO\t\t-    0x10\n// LX4\t\t\t\t-    0x20\n// LX6\t\t\t\t-    0x40\n// MRT5\t\t\t\t-    0x80\n// UF 1000\t\t\t-   0x100\n// RACEABOUT\t\t-   0x200\n// FZ50\t\t\t\t-   0x400\n// FORMULA XR\t\t-   0x800\n// XF GTR\t\t\t-  0x1000\n// UF GTR\t\t\t-  0x2000\n// FORMULA V8\t\t-  0x4000\n// FXO GTR\t\t\t-  0x8000\n// XR GTR\t\t\t- 0x10000\n// FZ50 GTR\t\t\t- 0x20000\n// BMW SAUBER F1.06\t- 0x40000\n// FORMULA BMW FB02\t- 0x80000\n\n\n// RACE TRACKING\n// =============\n\n// In LFS there is a list of connections AND a list of players in the race\n// Some packets are related to connections, some players, some both\n\n// If you are making a multiplayer InSim program, you must maintain two lists\n// You should use the unique identifier UCID to identify a connection\n\n// Each player has a unique identifier PLID from the moment he joins the race, until he\n// leaves.  It's not possible for PLID and UCID to be the same thing, for two reasons :\n\n// 1) there may be more than one player per connection if AI drivers are used\n// 2) a player can swap between connections, in the case of a driver swap (IS_TOC)\n\n// When all players are cleared from race (e.g. /clear) LFS sends this IS_TINY\n\n// ReqI : 0\n// SubT : TINY_CLR\t\t(CLear Race)\n\n// When a race ends (return to game setup screen) LFS sends this IS_TINY\n\n// ReqI : 0\n// SubT : TINY_REN  \t(Race ENd)\n\n// You can inStruct LFS host to cancel a vote using an IS_TINY\n\n// ReqI : 0\n// SubT : TINY_VTC\t\t(VoTe Cancel)\n\n// The following packets are sent when the relevant events take place :\n\nclass IS_RST extends Struct // Race STart\n{\n\tconst PACK = 'CCCxCCCCa6CCvvvvvv';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CRaceLaps/CQualMins/CNumP/CTiming/a6Track/CWeather/CWind/vFlags/vNumNodes/vFinish/vSplit1/vSplit2/vSplit3';\n\n\tprotected $Size = 28;\t\t\t\t# 28\n\tprotected $Type = ISP_RST;\t\t\t# ISP_RST\n\tpublic $ReqI = TRUE;\t\t\t\t# 0 unless this is a reply to an TINY_RST request\n\tprotected $Zero = NULL;\n\n\tpublic $RaceLaps;\t\t\t\t\t# 0 if qualifying\n\tpublic $QualMins;\t\t\t\t\t# 0 if race\n\tpublic $NumP;\t\t\t\t\t\t# number of players in race\n\tpublic $Timing;\t\t\t\t\t\t# lap timing (see below)\n\n\tpublic $Track;\t\t\t\t\t\t# short track name\n\tpublic $Weather;\n\tpublic $Wind;\n\n\tpublic $Flags;\t\t\t\t\t\t# race flags (must pit, can reset, etc - see below)\n\tpublic $NumNodes;\t\t\t\t\t# total number of nodes in the path\n\tpublic $Finish;\t\t\t\t\t\t# node index - finish line\n\tpublic $Split1;\t\t\t\t\t\t# node index - split 1\n\tpublic $Split2;\t\t\t\t\t\t# node index - split 2\n\tpublic $Split3;\t\t\t\t\t\t# node index - split 3\n}; function IS_RST() { return new IS_RST; }\n\n// Lap timing info (for Timing byte)\n\n// bits 6 and 7 (Timing & 0xc0) :\n\n// 0x40 : standard timing\n// 0x80 : custom timing\n// 0xc0 : no lap timing\n\n// bits 0 and 1 (Timing & 0x03) : number of checkpoints if lap timing is enabled\n\n// To request an IS_RST packet at any time, send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_RST\t\t(request an IS_RST)\n\nclass IS_NCN extends Struct // New ConN\n{\n\tconst PACK = 'CCCCa24a24CCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CUCID/a24UName/a24PName/CAdmin/CTotal/CFlags/CSp3';\n\n\tprotected $Size = 56;\t\t\t\t# 56\n\tprotected $Type = ISP_NCN;\t\t\t# ISP_NCN\n\tpublic $ReqI = NULL;\t\t\t\t# 0 unless this is a reply to a TINY_NCN request\n\tpublic $UCID;\t\t\t\t\t\t# new connection's unique id (0 = host)\n\n\tpublic $UName;\t\t\t\t\t\t# username\n\tpublic $PName;\t\t\t\t\t\t# nickname\n\n\tpublic $Admin;\t\t\t\t\t\t# 1 if admin\n\tpublic $Total;\t\t\t\t\t\t# number of connections including host\n\tpublic $Flags;\t\t\t\t\t\t# bit 2 : remote\n\tprotected $Sp3;\n}; function IS_NCN() { return new IS_NCN; }\n\nclass IS_CNL extends Struct // ConN Leave\n{\n\tconst PACK = 'CCxCCCxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CUCID/CReason/CTotal/CSp2/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_CNL;\t\t\t# ISP_CNL\n\tpublic $ReqI;\t\t\t\t\t\t# 0\n\tpublic $UCID;\t\t\t\t\t\t# unique id of the connection which left\n\n\tpublic $Reason;\t\t\t\t\t\t# leave reason (see below)\n\tpublic $Total;\t\t\t\t\t\t# number of connections including host\n\tprotected $Sp2;\n\tprotected $Sp3;\n}; function IS_CNL() { return new IS_CNL; }\n\nclass IS_CPR extends Struct // Conn Player Rename\n{\n\tconst PACK = 'CCxCa24a8';\n\tconst UNPACK = 'CSize/CType/CReqI/CUCID/a24PName/A8Plate';\n\n\tprotected $Size = 36;\t\t\t\t# 36\n\tprotected $Type = ISP_CPR;\t\t\t# ISP_CPR\n\tpublic $ReqI = NULL;\t\t\t\t# 0\n\tpublic $UCID;\t\t\t\t\t\t# unique id of the connection\n\n\tpublic $PName;\t\t\t\t\t\t# new name\n\tpublic $Plate;\t\t\t\t\t\t# number plate - NO ZERO AT END!\n}; function IS_CPR() { return new IS_CPR; }\n\nclass IS_NPL extends Struct // New PLayer joining race (if PLID already exists, then leaving pits)\n{\n\tconst PACK = 'CCCCCCva24a8a4a16C4CCCCVCCxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/CUCID/CPType/vFlags/a24PName/A8Plate/a4CName/a16SName/C4Tyres/CH_Mass/CH_TRes/CModel/CPass/VSpare/CSetF/CNumP/CSp2/CSp3';\n\n\tprotected $Size = 76;\t\t\t\t# 76\n\tprotected $Type = ISP_NPL;\t\t\t# ISP_NPL\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless this is a reply to an TINY_NPL request\n\tpublic $PLID;\t\t\t\t\t\t# player's newly assigned unique id\n\n\tpublic $UCID;\t\t\t\t\t\t# connection's unique id\n\tpublic $PType;\t\t\t\t\t\t# bit 0 : female / bit 1 : AI / bit 2 : remote\n\tpublic $Flags;\t\t\t\t\t\t# player flags\n\n\tpublic $PName;\t\t\t\t\t\t# nickname\n\tpublic $Plate;\t\t\t\t\t\t# number plate - NO ZERO AT END!\n\n\tpublic $CName;\t\t\t\t\t\t# car name\n\tpublic $SName;\t\t\t\t\t\t# skin name - MAX_CAR_TEX_NAME\n\tpublic $Tyres = array();\t\t\t# compounds\n\n\tpublic $H_Mass;\t\t\t\t\t\t# added mass (kg)\n\tpublic $H_TRes;\t\t\t\t\t\t# intake restriction\n\tpublic $Model;\t\t\t\t\t\t# driver model\n\tpublic $Pass;\t\t\t\t\t\t# passengers byte\n\n\tprotected $Spare;\n\n\tpublic $SetF;\t\t\t\t\t\t# setup flags (see below)\n\tpublic $NumP;\t\t\t\t\t\t# number in race (same when leaving pits, 1 more if new)\n\tprotected $Sp2;\n\tprotected $Sp3;\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\t$pkClass = unpack($this::UNPACK, $rawPacket);\n\n\t\tfor ($Tyre = 1; $Tyre <= 4; ++$Tyre)\n\t\t{\n\t\t\t$pkClass['Tyres'][] = $pkClass[\"Tyres{$Tyre}\"];\n\t\t\tunset($pkClass[\"Tyres{$Tyre}\"]);\n\t\t}\n\n\t\tforeach ($pkClass as $property => $value)\n\t\t{\n\t\t\t$this->$property = $value;\n\t\t}\n\n\t\treturn $this;\n\t}\n\n\tpublic function isFemale() { return ($this->PType & 1); }\n\tpublic function isAI() { return ($this->PType & 2); }\n\tpublic function isRemote(){ return ($this->PType & 4); }\n}; function IS_NPL() { return new IS_NPL; }\n\n// NOTE : PType bit 0 (female) is not reported on dedicated host as humans are not loaded\n// You can use the driver model byte instead if required (and to force the use of helmets)\n\n// Setup flags (for SetF byte)\n\ndefine('SETF_SYMM_WHEELS',\t1);\ndefine('SETF_TC_ENABLE',\t2);\ndefine('SETF_ABS_ENABLE',\t4);\n$SETF = array(SETF_SYMM_WHEELS => 'SETF_SYMM_WHEELS', SETF_TC_ENABLE => 'SETF_TC_ENABLE', SETF_ABS_ENABLE => 'SETF_ABS_ENABLE');\n\n// More...\n\nclass IS_PLP extends Struct // PLayer Pits (go to settings - stays in player list)\n{\n\tconst PACK = 'CCxC';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = ISP_PLP;\t\t\t# ISP_PLP\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n}; function IS_PLP() { return new IS_PLP; }\n\nclass IS_PLL extends Struct // PLayer Leave race (spectate - removed from player list)\n{\n\tconst PACK = 'CCxC';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = ISP_PLL;\t\t\t# ISP_PLL\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n}; function IS_PLL() { return new IS_PLL; }\n\nclass IS_CRS extends Struct // Car ReSet\n{\n\tconst PACK = 'CCxC';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = ISP_CRS;\t\t\t# ISP_CRS\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n}; function IS_CRS() { return new IS_CRS; }\n\nclass IS_LAP extends Struct // LAP time\n{\n\tconst PACK = 'CCxCVVvvxCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/VLTime/VETime/vLapsDone/vFlags/CSp0/CPenalty/CNumStops/CSp3';\n\n\tprotected $Size = 20;\t\t\t\t# 20\n\tprotected $Type = ISP_LAP;\t\t\t# ISP_LAP\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $LTime;\t\t\t\t\t\t# lap time (ms)\n\tpublic $ETime;\t\t\t\t\t\t# total time (ms)\n\n\tpublic $LapsDone;\t\t\t\t\t# laps completed\n\tpublic $Flags;\t\t\t\t\t\t# player flags\n\n\tprotected $Sp0;\n\tpublic $Penalty;\t\t\t\t\t# current penalty value (see below)\n\tpublic $NumStops;\t\t\t\t\t# number of pit stops\n\tprotected $Sp3;\n}; function IS_LAP() { return new IS_LAP; }\n\nclass IS_SPX extends Struct // SPlit X time\n{\n\tconst PACK = 'CCxCVVCCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/VSTime/VETime/CSplit/CPenalty/CNumStops/CSp3';\n\n\tprotected $Size = 16;\t\t\t\t# 16\n\tprotected $Type = ISP_SPX;\t\t\t# ISP_SPX\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $STime;\t\t\t\t\t\t# split time (ms)\n\tpublic $ETime;\t\t\t\t\t\t# total time (ms)\n\n\tpublic $Split;\t\t\t\t\t\t# split number 1, 2, 3\n\tpublic $Penalty;\t\t\t\t\t# current penalty value (see below)\n\tpublic $NumStops;\t\t\t\t\t# number of pit stops\n\tprotected $Sp3;\n}; function IS_SPX() { return new IS_SPX; }\n\nclass IS_PIT extends Struct // PIT stop (stop at pit garage)\n{\n\tconst PACK = 'CCxCvvxCCxC4VV';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/vLapsDone/vFlags/CSp0/CPenalty/CNumStops/CSp3/C4Tyres/VWork/VSpare';\n\n\tprotected $Size = 24;\t\t\t\t# 24\n\tprotected $Type = ISP_PIT;\t\t\t# ISP_PIT\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $LapsDone;\t\t\t\t\t# laps completed\n\tpublic $Flags;\t\t\t\t\t\t# player flags\n\n\tprotected $Sp0;\n\tpublic $Penalty;\t\t\t\t\t# current penalty value (see below)\n\tpublic $NumStops;\t\t\t\t\t# number of pit stops\n\tprotected $Sp3;\n\n\tpublic $Tyres = array();\t\t\t# tyres changed\n\n\tpublic $Work;\t\t\t\t\t\t# pit work\n\tprotected $Spare;\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\tfor ($Tyre = 1; $Tyre <= 4; ++$Tyre)\n\t\t{\n\t\t\t$Property = \"Tyres{$Tyre}\";\n\t\t\t$this->Tyres[] = $this->$Property;\n\t\t\tunset($this->$Property);\n\t\t}\n\n\t\treturn $this;\n\t}\n\n}; function IS_PIT() { return new IS_PIT; }\n\nclass IS_PSF extends Struct // Pit Stop Finished\n{\n\tconst PACK = 'CCxCVV';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/VSTime/VSpare';\n\n\tprotected $Size = 12;\t\t\t\t# 12\n\tprotected $Type = ISP_PSF;\t\t\t# ISP_PSF\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $STime;\t\t\t\t\t\t# stop time (ms)\n\tprotected $Spare;\n}; function IS_PSF() { return new IS_PSF; }\n\nclass IS_PLA extends Struct // Pit LAne\n{\n\tconst PACK = 'CCxCCxxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/CFact/CSp1/CSp2/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_PLA;\t\t\t# ISP_PLA\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $Fact;\t\t\t\t\t\t# pit lane fact (see below)\n\tprotected $Sp1;\n\tprotected $Sp2;\n\tprotected $Sp3;\n}; function IS_PLA() { return new IS_PLA; }\n\n// IS_CCH : Camera CHange\n\n// To track cameras you need to consider 3 points\n\n// 1) The default camera : VIEW_DRIVER\n// 2) Player flags : CUSTOM_VIEW means VIEW_CUSTOM at start or pit exit\n// 3) IS_CCH : sent when an existing driver changes camera\n\nclass IS_CCH extends Struct // Camera CHange\n{\n\tconst PACK = 'CCxCCxxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/CCamera/CSp1/CSp2/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_CCH;\t\t\t# ISP_CCH\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $Camera;\t\t\t\t\t\t# view identifier (see below)\n\tprotected $Sp1;\n\tprotected $Sp2;\n\tprotected $Sp3;\n}; function IS_CCH() { return new IS_CCH; }\n\nclass IS_PEN extends Struct // PENalty (given or cleared)\n{\n\tconst PACK = 'CCxCCCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/COldPen/CNewPen/CReason/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_PEN;\t\t\t# ISP_PEN\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $OldPen;\t\t\t\t\t\t# old penalty value (see below)\n\tpublic $NewPen;\t\t\t\t\t\t# new penalty value (see below)\n\tpublic $Reason;\t\t\t\t\t\t# penalty reason (see below)\n\tprotected $Sp3;\n}; function IS_PEN() { return new IS_PEN; }\n\nclass IS_TOC extends Struct // Take Over Car\n{\n\tconst PACK = 'CCxCCCxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/COldUCID/CNewUCID/CSp2/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_TOC;\t\t\t# ISP_TOC\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $OldUCID;\t\t\t\t\t# old connection's unique id\n\tpublic $NewUCID;\t\t\t\t\t# new connection's unique id\n\tprotected $Sp2;\n\tprotected $Sp3;\n}; function IS_TOC() { return new IS_TOC; }\n\nclass IS_FLG extends Struct // FLaG (yellow or blue flag changed)\n{\n\tconst PACK = 'CCxCCCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/COffOn/CFlag/CCarBehind/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_FLG;\t\t\t# ISP_FLG\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $OffOn;\t\t\t\t\t\t# 0 = off / 1 = on\n\tpublic $Flag;\t\t\t\t\t\t# 1 = given blue / 2 = causing yellow\n\tpublic $CarBehind;\t\t\t\t\t# unique id of obStructed player\n\tprotected $Sp3;\n}; function IS_FLG() { return new IS_FLG; }\n\nclass IS_PFL extends Struct // Player FLags (help flags changed)\n{\n\tconst PACK = 'CCxCvv';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/vFlags/vSpare';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_PFL;\t\t\t# ISP_PFL\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $Flags;\t\t\t\t\t\t# player flags (see below)\n\tprotected $Spare;\n}; function IS_PFL() { return new IS_PFL; }\n\nclass IS_FIN extends Struct // FINished race notification (not a final result - use IS_RES)\n{\n\tconst PACK = 'CCxCVVxCCxvv';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/VTTime/VBTime/CSpA/CNumStops/CConfirm/CSpB/vLapsDone/vFlags';\n\n\tprotected $Size = 20;\t\t\t\t# 20\n\tprotected $Type = ISP_FIN;\t\t\t# ISP_FIN\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id (0 = player left before result was sent)\n\n\tpublic $TTime;\t\t\t\t\t\t# race time (ms)\n\tpublic $BTime;\t\t\t\t\t\t# best lap (ms)\n\n\tprotected $SpA;\n\tpublic $NumStops;\t\t\t\t\t# number of pit stops\n\tpublic $Confirm;\t\t\t\t\t# confirmation flags : disqualified etc - see below\n\tprotected $SpB;\n\n\tpublic $LapsDone;\t\t\t\t\t# laps completed\n\tpublic $Flags;\t\t\t\t\t\t# player flags : help settings etc - see below\n}; function IS_FIN() { return new IS_FIN; }\n\nclass IS_RES extends Struct // RESult (qualify or confirmed finish)\n{\n\tconst PACK = 'CCxCa24a24a8a4VVxCCxvvCCv';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/a24UName/a24PName/A8Plate/a4CName/VTTime/VBTime/CSpA/CNumStops/CConfirm/CSpB/vLapsDone/vFlags/CResultNum/CNumRes/vPSeconds';\n\n\tprotected $Size = 84;\t\t\t\t# 84\n\tprotected $Type = ISP_RES;\t\t\t# ISP_RES\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless this is a reply to a TINY_RES request\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id (0 = player left before result was sent)\n\n\tpublic $UName;\t\t\t\t\t\t# username\n\tpublic $PName;\t\t\t\t\t\t# nickname\n\tpublic $Plate;\t\t\t\t\t\t# number plate - NO ZERO AT END!\n\tpublic $CName;\t\t\t\t\t\t# skin prefix\n\n\tpublic $TTime;\t\t\t\t\t\t# race time (ms)\n\tpublic $BTime;\t\t\t\t\t\t# best lap (ms)\n\n\tprotected $SpA;\n\tpublic $NumStops;\t\t\t\t\t# number of pit stops\n\tpublic $Confirm;\t\t\t\t\t# confirmation flags : disqualified etc - see below\n\tprotected $SpB;\n\n\tpublic $LapsDone;\t\t\t\t\t# laps completed\n\tpublic $Flags;\t\t\t\t\t\t# player flags : help settings etc - see below\n\n\tpublic $ResultNum;\t\t\t\t\t# finish or qualify pos (0 = win / 255 = not added to table)\n\tpublic $NumRes;\t\t\t\t\t\t# total number of results (qualify doesn't always add a new one)\n\tpublic $PSeconds;\t\t\t\t\t# penalty time in seconds (already included in race time)\n}; function IS_RES() { return new IS_RES; }\n\n// IS_REO : REOrder - this packet can be sent in either direction\n\n// LFS sends one at the start of every race or qualifying session, listing the start order\n\n// You can send one to LFS before a race start, to specify the starting order.\n// It may be a good idea to avoid conflict by using /start=fixed (LFS setting).\n// Alternatively, you can leave the LFS setting, but make sure you send your IS_REO\n// AFTER you receive the SMALL_VTA (VoTe Action).  LFS does its default grid reordering at\n// the same time as it sends the SMALL_VTA and you can override this by sending an IS_REO.\n\nclass IS_REO extends Struct // REOrder (when race restarts after qualifying)\n{\n\tconst PACK = 'CCCCC32';\n\tconst UNPACK = 'CSize/CType/CReqI/CNumP/C32PLID';\n\n\tprotected $Size = 36;\t\t\t\t# 36\n\tprotected $Type = ISP_REO;\t\t\t# ISP_REO\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless this is a reply to an TINY_REO request\n\tpublic $NumP;\t\t\t\t\t\t# number of players in race\n\n\tpublic $PLID;\t\t\t\t\t\t# all PLIDs in new order\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\t$pkClass = unpack($this::UNPACK, $rawPacket);\n\n\t\t$pkClass['PLID'] = array();\n\t\tfor ($Pos = 1; $Pos <= 32; ++$Pos)\n\t\t{\n\t\t\tif ($pkClass[\"PLID{$Pos}\"] != 0)\n\t\t\t\t$pkClass['PLID'][$Pos] = $pkClass[\"PLID{$Pos}\"];\n\t\t\tunset($pkClass[\"PLID{$Pos}\"]);\n\t\t}\n\n\t\tforeach ($pkClass as $property => $value)\n\t\t{\n\t\t\t$this->$property = $value;\n\t\t}\n\n\t\treturn $this;\n\t}\n}; function IS_REO() { return new IS_REO; }\n\n// To request an IS_REO packet at any time, send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_REO\t\t(request an IS_REO)\n\n// Pit Lane Facts\n\ndefine('PITLANE_EXIT',\t\t0);\t// 0 - left pit lane\ndefine('PITLANE_ENTER',\t\t1);\t// 1 - entered pit lane\ndefine('PITLANE_NO_PURPOSE',2);\t// 2 - entered for no purpose\ndefine('PITLANE_DT',\t\t3);\t// 3 - entered for drive-through\ndefine('PITLANE_SG',\t\t4);\t// 4 - entered for stop-go\ndefine('PITLANE_NUM',\t\t5);\n$PITLANE = array(PITLANE_EXIT => 'PITLANE_EXIT', PITLANE_ENTER => 'PITLANE_ENTER', PITLANE_NO_PURPOSE => 'PITLANE_NO_PURPOSE', PITLANE_DT => 'PITLANE_DT', PITLANE_SG => 'PITLANE_SG', PITLANE_NUM => 'PITLANE_NUM');\n\n// Pit Work Flags\n\ndefine('PSE_NOTHING',\t(1 << 1));\t// bit 0 (1)\ndefine('PSE_STOP',\t\t(1 << 2));\t// bit 1 (2)\ndefine('PSE_FR_DAM',\t(1 << 3));\t// bit 2 (4)\ndefine('PSE_FR_WHL',\t(1 << 4));\t// etc...\ndefine('PSE_LE_FR_DAM',\t(1 << 6));\ndefine('PSE_LE_FR_WHL',\t(1 << 7));\ndefine('PSE_RI_FR_DAM', (1 << 8));\ndefine('PSE_RI_FR_WHL',\t(1 << 9));\ndefine('PSE_RE_DAM',\t(1 << 10));\ndefine('PSE_RE_WHL',\t(1 << 11));\ndefine('PSE_LE_RE_DAM',\t(1 << 12));\ndefine('PSE_LE_RE_WHL',\t(1 << 13));\ndefine('PSE_RI_RE_DAM',\t(1 << 14));\ndefine('PSE_RI_RE_WHL',\t(1 << 15));\ndefine('PSE_BODY_MINOR',(1 << 16));\ndefine('PSE_BODY_MAJOR',(1 << 17));\ndefine('PSE_SETUP',\t\t(1 << 18));\ndefine('PSE_REFUEL',\t(1 << 19));\ndefine('PSE_NUM',\t\t20);\n$PSE = array(PSE_NOTHING => 'PSE_NOTHING', PSE_STOP => 'PSE_STOP', PSE_FR_DAM => 'PSE_FR_DAM', PSE_FR_WHL => 'PSE_FR_WHL', PSE_LE_FR_DAM => 'PSE_LE_FR_DAM', PSE_LE_FR_WHL => 'PSE_LE_FR_WHL', PSE_RI_FR_DAM => 'PSE_RI_FR_DAM', PSE_RI_FR_WHL => 'PSE_RI_FR_WHL', PSE_RE_DAM => 'PSE_RE_DAM', PSE_RE_WHL => 'PSE_RE_WHL', PSE_LE_RE_DAM => 'PSE_LE_RE_DAM', PSE_LE_RE_WHL => 'PSE_LE_RE_WHL', PSE_RI_RE_DAM => 'PSE_RI_RE_DAM', PSE_RI_RE_WHL => 'PSE_RI_RE_WHL', PSE_BODY_MINOR => 'PSE_BODY_MINOR', PSE_BODY_MAJOR => 'PSE_BODY_MAJOR', PSE_SETUP => 'PSE_SETUP', PSE_REFUEL => 'PSE_REFUEL', PSE_NUM => 'PSE_NUM');\n\n// View identifiers\n\ndefine('VIEW_FOLLOW',\t0);\t// 0 - arcade\ndefine('VIEW_HELI',\t\t1);\t// 1 - helicopter\ndefine('VIEW_CAM',\t\t2);\t// 2 - tv camera\ndefine('VIEW_DRIVER',\t3);\t// 3 - cockpit\ndefine('VIEW_CUSTOM',\t4);\t// 4 - custom\ndefine('VIEW_MAX',\t\t5);\ndefine('VIEW_ANOTHER',255); // viewing another car\n$VIEW = array(VIEW_FOLLOW => 'VIEW_FOLLOW', VIEW_HELI => 'VIEW_HELI', VIEW_CAM => 'VIEW_CAM', VIEW_DRIVER => 'VIEW_DRIVER', VIEW_CUSTOM => 'VIEW_CUSTOM', VIEW_MAX => 'VIEW_MAX', VIEW_ANOTHER => 'VIEW_ANOTHER');\n\n// Leave reasons\n\ndefine('LEAVR_DISCO',\t0);\t// 0 - disconnect\ndefine('LEAVR_TIMEOUT',\t1);\t// 1 - timed out\ndefine('LEAVR_LOSTCONN',2);\t// 2 - lost connection\ndefine('LEAVR_KICKED',\t3);\t// 3 - kicked\ndefine('LEAVR_BANNED',\t4);\t// 4 - banned\ndefine('LEAVR_SECURITY',5);\t// 5 - OOS or cheat protection\ndefine('LEAVR_NUM',\t\t6);\n$LEAVR = array(LEAVR_DISCO => 'LEAVR_DISCO', LEAVR_TIMEOUT => 'LEAVR_TIMEOUT', LEAVR_LOSTCONN => 'LEAVR_LOSTCONN', LEAVR_KICKED => 'LEAVR_KICKED', LEAVR_BANNED => 'LEAVR_BANNED', LEAVR_SECURITY => 'LEAVR_SECURITY', LEAVR_NUM => 'LEAVR_NUM');\n\n// Penalty values (VALID means the penalty can now be cleared)\n\ndefine('PENALTY_NONE',\t\t0);\t// 0\ndefine('PENALTY_DT',\t\t1);\t// 1\ndefine('PENALTY_DT_VALID',\t2);\t// 2\ndefine('PENALTY_SG',\t\t3);\t// 3\ndefine('PENALTY_SG_VALID',\t4);\t// 4\ndefine('PENALTY_30',\t\t5);\t// 5\ndefine('PENALTY_45',\t\t6);\t// 6\ndefine('PENALTY_NUM',\t\t7);\n$PENALTY = array(PENALTY_NONE => 'PENALTY_NONE', PENALTY_DT => 'PENALTY_DT', PENALTY_DT_VALID => 'PENALTY_DT_VALID', PENALTY_SG => 'PENALTY_SG', PENALTY_SG_VALID => 'PENALTY_SG_VALID', PENALTY_30 => 'PENALTY_30', PENALTY_45 => 'PENALTY_45', PENALTY_NUM => 'PENALTY_NUM');\n\n// Penalty reasons\n\ndefine('PENR_UNKNOWN',\t\t0);\t// 0 - unknown or cleared penalty\ndefine('PENR_ADMIN',\t\t1);\t// 1 - penalty given by admin\ndefine('PENR_WRONG_WAY',\t2);\t// 2 - wrong way driving\ndefine('PENR_FALSE_START',\t3);\t// 3 - starting before green light\ndefine('PENR_SPEEDING',\t\t4);\t// 4 - speeding in pit lane\ndefine('PENR_STOP_SHORT',\t5);\t// 5 - stop-go pit stop too short\ndefine('PENR_STOP_LATE',\t6);\t// 6 - compulsory stop is too late\ndefine('PENR_NUM',\t\t\t7);\n$PENR = array(PENR_UNKNOWN => 'PENR_UNKNOWN', PENR_ADMIN => 'PENR_ADMIN', PENR_WRONG_WAY => 'PENR_WRONG_WAY', PENR_FALSE_START => 'PENR_FALSE_START', PENR_SPEEDING => 'PENR_SPEEDING', PENR_STOP_SHORT => 'PENR_STOP_SHORT', PENR_STOP_LATE => 'PENR_STOP_LATE', PENR_NUM => 'PENR_NUM');\n\n// Player flags\n\ndefine('PIF_SWAPSIDE',\t\t1);\ndefine('PIF_RESERVED_2',\t2);\ndefine('PIF_RESERVED_4',\t4);\ndefine('PIF_AUTOGEARS',\t\t8);\ndefine('PIF_SHIFTER',\t\t16);\ndefine('PIF_RESERVED_32',\t32);\ndefine('PIF_HELP_B',\t\t64);\ndefine('PIF_AXIS_CLUTCH',\t128);\ndefine('PIF_INPITS',\t\t256);\ndefine('PIF_AUTOCLUTCH',\t512);\ndefine('PIF_MOUSE',\t\t\t1024);\ndefine('PIF_KB_NO_HELP',\t2048);\ndefine('PIF_KB_STABILISED',\t4096);\ndefine('PIF_CUSTOM_VIEW',\t8192);\n$PIF = array(PIF_SWAPSIDE => 'PIF_SWAPSIDE', PIF_RESERVED_2 => 'PIF_RESERVED_2', PIF_RESERVED_4 => 'PIF_RESERVED_4', PIF_AUTOGEARS => 'PIF_AUTOGEARS', PIF_SHIFTER => 'PIF_SHIFTER', PIF_RESERVED_32 => 'PIF_RESERVED_32', PIF_HELP_B => 'PIF_HELP_B', PIF_AXIS_CLUTCH => 'PIF_AXIS_CLUTCH', PIF_INPITS => 'PIF_INPITS', PIF_AUTOCLUTCH => 'PIF_AUTOCLUTCH', PIF_MOUSE => 'PIF_MOUSE', PIF_KB_NO_HELP => 'PIF_KB_NO_HELP', PIF_KB_STABILISED => 'PIF_KB_STABILISED', PIF_CUSTOM_VIEW => 'PIF_CUSTOM_VIEW');\n\n// Tyre compounds (4 byte order : rear L, rear R, front L, front R)\n\ndefine('TYRE_R1',\t\t\t0);\t// 0\ndefine('TYRE_R2',\t\t\t1);\t// 1\ndefine('TYRE_R3',\t\t\t2);\t// 2\ndefine('TYRE_R4',\t\t\t3);\t// 3\ndefine('TYRE_ROAD_SUPER',\t4);\t// 4\ndefine('TYRE_ROAD_NORMAL',\t5);\t// 5\ndefine('TYRE_HYBRID',\t\t6);\t// 6\ndefine('TYRE_KNOBBLY',\t\t7);\t// 7\ndefine('TYRE_NUM',\t\t\t8);\ndefine('NOT_CHANGED',\t\t255);\n$TYRE = array(TYRE_R1 => 'TYRE_R1', TYRE_R2 => 'TYRE_R2', TYRE_R3 => 'TYRE_R3', TYRE_R4 => 'TYRE_R4', TYRE_ROAD_SUPER => 'TYRE_ROAD_SUPER', TYRE_ROAD_NORMAL => 'TYRE_ROAD_NORMAL', TYRE_HYBRID => 'TYRE_HYBRID', TYRE_KNOBBLY => 'TYRE_KNOBBLY', TYRE_NUM => 'TYRE_NUM', NOT_CHANGED => 'NOT_CHANGED');\n\n// Confirmation flags\n\ndefine('CONF_MENTIONED',\t1);\ndefine('CONF_CONFIRMED',\t2);\ndefine('CONF_PENALTY_DT',\t4);\ndefine('CONF_PENALTY_SG',\t8);\ndefine('CONF_PENALTY_30',\t16);\ndefine('CONF_PENALTY_45',\t32);\ndefine('CONF_DID_NOT_PIT',\t64);\ndefine('CONF_DISQ',\tCONF_PENALTY_DT | CONF_PENALTY_SG | CONF_DID_NOT_PIT);\ndefine('CONF_TIME',\tCONF_PENALTY_30 | CONF_PENALTY_45);\n$CONF = array(CONF_MENTIONED => 'CONF_MENTIONED', CONF_CONFIRMED => 'CONF_CONFIRMED', CONF_PENALTY_DT => 'CONF_PENALTY_DT', CONF_PENALTY_SG => 'CONF_PENALTY_SG', CONF_PENALTY_30 => 'CONF_PENALTY_30', CONF_PENALTY_45 => 'CONF_PENALTY_45', CONF_DID_NOT_PIT => 'CONF_DID_NOT_PIT', CONF_DISQ => 'CONF_DISQ', CONF_TIME => 'CONF_TIME');\n\n// Race flags\n\ndefine('HOSTF_CAN_VOTE',\t1);\ndefine('HOSTF_CAN_SELECT',\t2);\ndefine('HOSTF_MID_RACE',\t32);\ndefine('HOSTF_MUST_PIT',\t64);\ndefine('HOSTF_CAN_RESET',\t128);\ndefine('HOSTF_FCV',\t\t\t256);\ndefine('HOSTF_CRUISE',\t\t512);\n$HOSTF = array(HOSTF_CAN_VOTE => 'HOSTF_CAN_VOTE', HOSTF_CAN_SELECT => 'HOSTF_CAN_SELECT', HOSTF_MID_RACE => 'HOSTF_MID_RACE', HOSTF_MUST_PIT => 'HOSTF_MUST_PIT', HOSTF_CAN_RESET => 'HOSTF_CAN_RESET', HOSTF_FCV => 'HOSTF_FCV', HOSTF_CRUISE => 'HOSTF_CRUISE');\n\n// Passengers byte\n\n// bit 0 female\n// bit 1 front\n// bit 2 female\n// bit 3 rear left\n// bit 4 female\n// bit 5 rear middle\n// bit 6 female\n// bit 7 rear right\n\n\n// TRACKING PACKET REQUESTS\n// ========================\n\n// To request players, connections, results or a single NLP or MCI, send an IS_TINY\n\n// In each case, ReqI must be non-zero, and will be returned in the reply packet\n\n// SubT : TINT_NCN - request all connections\n// SubT : TINY_NPL - request all players\n// SubT : TINY_RES - request all results\n// SubT : TINY_NLP - request a single IS_NLP\n// SubT : TINY_MCI - request a set of IS_MCI\n\n\n// AUTOCROSS\n// =========\n\n// When all objects are cleared from a layout, LFS sends this IS_TINY :\n\n// ReqI : 0\n// SubT : TINY_AXC\t\t(AutoX Cleared)\n\n// You can request information about the current layout with this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_AXI\t\t(AutoX Info)\n\n// The information will be sent back in this packet (also sent when a layout is loaded) :\n\nclass IS_AXI extends Struct  // AutoX Info\n{\n\tconst PACK = 'CCCxCCva32';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CAXStart/CNumCP/vNumO/a32LName';\n\n\tprotected $Size = 40;\t\t\t\t# 40\n\tprotected $Type = ISP_AXI;\t\t\t# ISP_AXI\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless this is a reply to an TINY_AXI request\n\tprotected $Zero;\n\n\tpublic $AXStart;\t\t\t\t\t# autocross start position\n\tpublic $NumCP;\t\t\t\t\t\t# number of checkpoints\n\tpublic $NumO;\t\t\t\t\t\t# number of objects\n\n\tpublic $LName;\t\t\t\t\t\t# the name of the layout last loaded (if loaded locally)\n}; function IS_AXI() { return new IS_AXI; }\n\n// On false start or wrong route / restricted area, an IS_PEN packet is sent :\n\n// False start : OldPen = 0 / NewPen = PENALTY_30 / Reason = PENR_FALSE_START\n// Wrong route : OldPen = 0 / NewPen = PENALTY_45 / Reason = PENR_WRONG_WAY\n\n// If an autocross object is hit (2 second time penalty) this packet is sent :\n\nclass IS_AXO extends Struct // AutoX Object\n{\n\tconst PACK = 'CCxC';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = ISP_AXO;\t\t\t# ISP_AXO\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n}; function IS_AXO() { return new IS_AXO; }\n\n\n// CAR TRACKING - car position info sent at constant intervals\n// ============\n\n// IS_NLP - compact, all cars in 1 variable sized packet\n// IS_MCI - detailed, max 8 cars per variable sized packet\n\n// To receive IS_NLP or IS_MCI packets at a specified interval :\n\n// 1) Set the Interval field in the IS_ISI (InSimInit) packet (40, 50, 60... 8000 ms)\n// 2) Set one of the flags ISF_NLP or ISF_MCI in the IS_ISI packet\n\n// If ISF_NLP flag is set, one IS_NLP packet is sent...\n\nclass NodeLap extends Struct // Car info in 6 bytes - there is an array of these in the NLP (below)\n{\n\tconst PACK = 'vvCC';\n\tconst UNPACK = 'vNode/vLap/CPLID/CPosition';\n\n\tpublic $Node;\t\t\t\t\t\t# current path node\n\tpublic $Lap;\t\t\t\t\t\t# current lap\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\tpublic $Position;\t\t\t\t\t# current race position : 0 = unknown, 1 = leader, etc...\n};\n\nclass IS_NLP extends Struct // Node and Lap Packet - variable size\n{\n\tconst PACK = 'CCCC';\n\tconst UNPACK = 'CSize/CType/CReqI/CNumP';\n\n\tprotected $Size;\t\t\t\t\t# 4 + NumP * 6 (PLUS 2 if needed to make it a multiple of 4)\n\tprotected $Type = ISP_NLP;\t\t\t# ISP_NLP\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless this is a reply to an TINY_NLP request\n\tpublic $NumP;\t\t\t\t\t\t# number of players in race\n\n\tpublic $Info = array();\t\t\t\t# node and lap of each player, 1 to 32 of these (NumP)\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\tfor ($i = 0; $i < $this->NumP; $i++)\n\t\t{\n\t\t\t$this->Info[$i] = new NodeLap(substr($rawPacket, 4 + ($i * 6), 6));\n\t\t}\n\n\t\treturn $this;\n\t}\n\n}; function IS_NLP() { return new IS_NLP; }\n\n// If ISF_MCI flag is set, a set of IS_MCI packets is sent...\n\nclass CompCar extends Struct // Car info in 28 bytes - there is an array of these in the MCI (below)\n{\n\tconst PACK = 'vvCCCxVVVvvvs';\n\tconst UNPACK = 'vNode/vLap/CPLID/CPosition/CInfo/CSp3/lX/lY/lZ/vSpeed/vDirection/vHeading/sAngVel';\n\n\tpublic $Node;\t\t\t\t\t\t# current path node\n\tpublic $Lap;\t\t\t\t\t\t# current lap\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\tpublic $Position;\t\t\t\t\t# current race position : 0 = unknown, 1 = leader, etc...\n\tpublic $Info;\t\t\t\t\t\t# flags and other info - see below\n\tprotected $Sp3;\n\tpublic $X;\t\t\t\t\t\t\t# X map (65536 = 1 metre)\n\tpublic $Y;\t\t\t\t\t\t\t# Y map (65536 = 1 metre)\n\tpublic $Z;\t\t\t\t\t\t\t# Z alt (65536 = 1 metre)\n\tpublic $Speed;\t\t\t\t\t\t# speed (32768 = 100 m/s)\n\tpublic $Direction;\t\t\t\t\t# car's motion if Speed > 0 : 0 = world y direction, 32768 = 180 deg\n\tpublic $Heading;\t\t\t\t\t# direction of forward axis : 0 = world y direction, 32768 = 180 deg\n\tpublic $AngVel;\t\t\t\t\t\t# signed, rate of change of heading : (16384 = 360 deg/s)\n};\n\n// NOTE 1) Info byte - the bits in this byte have the following meanings :\n\ndefine('CCI_BLUE',\t\t1);\t\t// this car is in the way of a driver who is a lap ahead\ndefine('CCI_YELLOW',\t2);\t\t// this car is slow or stopped and in a dangerous place\ndefine('CCI_LAG',\t\t32);\t// this car is lagging (missing or delayed position packets)\ndefine('CCI_FIRST',\t\t64);\t// this is the first compcar in this set of MCI packets\ndefine('CCI_LAST',\t\t128);\t// this is the last compcar in this set of MCI packets\n$CCI = array(CCI_BLUE => 'CCI_BLUE', CCI_YELLOW => 'CCI_YELLOW', CCI_LAG => 'CCI_LAG', CCI_FIRST => 'CCI_FIRST', CCI_LAST => 'CCI_LAST');\n\n// NOTE 2) Heading : 0 = world y axis direction, 32768 = 180 degrees, anticlockwise from above\n// NOTE 3) AngVel  : 0 = no change in heading,    8192 = 180 degrees per second anticlockwise\n\nclass IS_MCI extends Struct // Multi Car Info - if more than 8 in race then more than one of these is sent\n{\n\tconst PACK = 'CCCC';\n\tconst UNPACK = 'CSize/CType/CReqI/CNumC';\n\n\tprotected $Size;\t\t\t\t\t# 4 + NumC * 28\n\tprotected $Type = ISP_MCI;\t\t\t# ISP_MCI\n\tpublic $ReqI;\t\t\t\t\t\t# 0 unless this is a reply to an TINY_MCI request\n\tpublic $NumC;\t\t\t\t\t\t# number of valid CompCar Structs in this packet\n\n\tpublic $Info = array();\t\t\t\t# car info for each player, 1 to 8 of these (NumC)\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\tfor ($i = 0; $i < $this->NumC; $i++)\n\t\t{\n\t\t\t$this->Info[$i] = new CompCar(substr($rawPacket, 4 + ($i * 28), 28));\n\t\t}\n\n\t\treturn $this;\n\t}\n}; function IS_MCI() { return new IS_MCI; }\n\n// You can change the rate of NLP or MCI after initialisation by sending this IS_SMALL :\n\n// ReqI : 0\n// SubT : SMALL_NLI\t\t(Node Lap Interval)\n// UVal : interval\t\t(0 means stop, otherwise time interval : 40, 50, 60... 8000 ms)\n\n// CONTACT - reports contacts between two cars if the closing speed is above 0.25 m/s\n// =======\n\nclass CarContact extends Struct\t// Info about one car in a contact - two of these in the IS_CON (below)\n{\n\tconst PACK = 'CCCcCCCCCCccss';\n\tconst UNPACK = 'CPLID/CInfo/CSp2/cSteer/CThrBrk/CCluHan/CGearSp/CSpeed/CDirection/CHeading/cAccelF/cAccelR/sX/sY';\n\n\tpublic $PLID;\n\tpublic $Info;\t\t\t\t\t\t# like Info byte in CompCar (CCI_BLUE / CCI_YELLOW / CCI_LAG)\n\tpublic $Sp2;\t\t\t\t\t\t# spare\n\tpublic $Steer;\t\t\t\t\t\t# front wheel steer in degrees (right positive)\n\n\tpublic $ThrBrk;\t\t\t\t\t\t# high 4 bits : throttle    / low 4 bits : brake (0 to 15)\n\tpublic $CluHan;\t\t\t\t\t\t# high 4 bits : clutch      / low 4 bits : handbrake (0 to 15)\n\tpublic $GearSp;\t\t\t\t\t\t# high 4 bits : gear (15=R) / low 4 bits : spare\n\tpublic $Speed;\t\t\t\t\t\t# m/s\n\n\tpublic $Direction;\t\t\t\t\t# car's motion if Speed > 0 : 0 = world y direction, 128 = 180 deg\n\tpublic $Heading;\t\t\t\t\t# direction of forward axis : 0 = world y direction, 128 = 180 deg\n\tpublic $AccelF;\t\t\t\t\t\t# m/s^2 longitudinal acceleration (forward positive)\n\tpublic $AccelR;\t\t\t\t\t\t# m/s^2 lateral acceleration (right positive)\n\n\tpublic $X;\t\t\t\t\t\t\t# position (1 metre = 16)\n\tpublic $Y;\t\t\t\t\t\t\t# position (1 metre = 16)\n\n\tpublic function getPLID()\t\t\t\t\t\t{ return $this->PLID; }\n\tpublic function getInfO()\t\t\t\t\t\t{ return $this->Info; }\n\n\tpublic function getWheelAngle()\t\t\t\t\t{ return $this->Steer; }\n\n\tpublic function getThrottle()\t\t\t\t\t{ return $this->ThrBrk >> 4; }\n\tpublic function getBrake()\t\t\t\t\t\t{ return $this->ThrBrk & 15; }\n\tpublic function getClutch()\t\t\t\t\t\t{ return $this->CluHan >> 4; }\n\tpublic function getHandbrake()\t\t\t\t\t{ return $this->CluHan & 15; }\n\tpublic function getGear()\t\t\t\t\t\t{ return (($Gear = $this->GearSp >> 4) == 15) ? 'R' : $Gear; }\n\n\tpublic function getSpeed()\t\t\t\t\t\t{ return $this->Speed; }\n\tpublic function getDirection()\t\t\t\t\t{ return $this->Direction; }\n\tpublic function getHeading()\t\t\t\t\t{ return $this->Heading; }\n\tpublic function getAccelerationLongitudinal()\t{ return $this->AccelF; }\n\tpublic function getAccelerationLateral()\t\t{ return $this->AccelR; }\n\tpublic function getX()\t\t\t\t\t\t\t{ return $this->X; }\n\tpublic function getY()\t\t\t\t\t\t\t{ return $this->Y; }\n\n\tpublic function bug()\n\t{\n\t\tprintf(\"%1$08b (%1$-3d)\", $this->GearSp >> 4);\n\t}\n};\n\nclass IS_CON extends Struct // CONtact - between two cars (A and B are sorted by PLID)\n{\n\tconst PACK = 'CCCCvv';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/vSpClose/vTime';\n\n\tprotected $Size = 40;\t\t\t\t# 40\n\tprotected $Type = ISP_CON;\t\t\t# ISP_CON\n\tprotected $ReqI = 0;\t\t\t\t# 0\n\tprotected $Zero;\n\n\tpublic $SpClose;\t\t\t\t\t# high 4 bits : reserved / low 12 bits : closing speed (10 = 1 m/s)\n\tpublic $Time;\t\t\t\t\t\t# looping time stamp (hundredths - time since reset - like TINY_GTH)\n\n\tpublic $A = array();\n\tpublic $B = array();\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\t$this->A = new CarContact(substr($rawPacket, 8, 16));\n\t\t$this->B = new CarContact(substr($rawPacket, 24, 16));\n\n\t\treturn $this;\n\t}\n\t\n\tpublic function getTime()\t\t\t{ return $this->Time; }\n#\tpublic function getSpare()\t\t\t{ return $this->SpClose >> 12; }\n\tpublic function getClosingSpeed()\t{ return ($this->SpClose & 0x0fff) / 10; }\n\tpublic function getA()\t\t\t\t{ return $this->A; }\n\tpublic function getB()\t\t\t\t{ return $this->B; }\n}; function IS_CON() { return new IS_CON; }\n\n// Set the ISP_OBH flag in the IS_ISI to receive object contact reports\n\nclass CarContOBJ extends Struct // 8 bytes : car in a contact with an object\n{\n\tconst PACK = 'CCCxss';\n\tconst UNPACK = 'CDirection/CHeading/CSpeed/CSp3/sX/sY';\n\n\tpublic $Direction;\t\t\t\t\t# car's motion if Speed > 0 : 0 = world y direction, 128 = 180 deg\n\tpublic $Heading;\t\t\t\t\t# direction of forward axis : 0 = world y direction, 128 = 180 deg\n\tpublic $Speed;\t\t\t\t\t\t# m/s\n\tprotected $Sp3;\n\n\tpublic $X;\t\t\t\t\t\t\t# position (1 metre = 16)\n\tpublic $Y;\t\t\t\t\t\t\t# position (1 metre = 16)\n};\n\nclass IS_OBH extends Struct // OBject Hit - car hit an autocross object or an unknown object\n{\n\tconst PACK = 'CCCCvvx8ssxxCC';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/vSpClose/vTime/x8C/sX/sY/xSp0/xSp1/CIndex/COBHFlags';\n\n\tprotected $Size = 24;\t\t\t\t# 24\n\tprotected $Type = ISP_OBH;\t\t\t# ISP_OBH\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $SpClose;\t\t\t\t\t# high 4 bits : reserved / low 12 bits : closing speed (10 = 1 m/s)\n\tpublic $Time;\t\t\t\t\t\t# looping time stamp (hundredths - time since reset - like TINY_GTH)\n\n\tpublic $C;\n\n\tpublic $X;\t\t\t\t\t\t\t# as in ObjectInfo\n\tpublic $Y;\t\t\t\t\t\t\t# as in ObjectInfo\n\n\tprivate $Sp0;\n\tprivate\t$Sp1;\n\tpublic $Index;\t\t\t\t\t\t# AXO_x as in ObjectInfo or zero if it is an unknown object\n\tpublic $OBHFlags;\t\t\t\t\t# see below\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\t$this->C = new CarContOBJ(substr($rawPacket, 8, 8));\n\n\t\treturn $this;\n\t}\n}; function IS_OBH() { return new IS_OBH; }\n\n// OBHFlags byte\n\ndefine('OBH_LAYOUT',\t1);// an added object\ndefine('OBH_CAN_MOVE',\t2);// a movable object\ndefine('OBH_WAS_MOVING',4);// was moving before this hit\ndefine('OBH_ON_SPOT',\t8);// object in original position\n$OBH = array(OBH_LAYOUT => 'OBH_LAYOUT', OBH_CAN_MOVE => 'OBH_CAN_MOVE', OBH_WAS_MOVING => 'OBH_WAS_MOVING', OBH_ON_SPOT => 'OBH_ON_SPOT');\n\n// Set the ISP_HLV flag in the IS_ISI to receive reports of incidents that would violate HLVC\n\nclass IS_HLV extends Struct // Hot Lap Validity - illegal ground / hit wall / speeding in pit lane\n{\n\tconst PACK = 'CCCCCCvx8';\n\tconst UNPACK = 'CSize/CType/CReqI/CPLID/CHLVC/xSp1/vTime/x8C';\n\n\tprotected $Size = 16;\t\t\t\t# 16\n\tprotected $Type = ISP_HLV;\t\t\t# ISP_HLV\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $PLID;\t\t\t\t\t\t# player's unique id\n\n\tpublic $HLVC;\t\t\t\t\t\t# 0 : ground / 1 : wall / 4 : speeding\n\tprivate\t$Sp1;\n\tpublic $Time;\t\t\t\t\t\t# looping time stamp (hundredths - time since reset - like TINY_GTH)\n\n\tpublic $C;\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\t$this->C = new CarContOBJ(substr($rawPacket, 8, 8));\n\n\t\treturn $this;\n\t}\n}; function IS_HLV() { return new IS_HLV; }\n\n\n// AUTOCROSS OBJECTS - reporting / adding / removing\n// =================\n\n// Set the ISF_AXM_LOAD flag in the IS_ISI for info about objects when a layout is loaded.\n// Set the ISF_AXM_EDIT flag in the IS_ISI for info about objects edited by user or InSim.\n\n// You can also add or remove objects by sending IS_AXM packets.\n// Some care must be taken with these - please read the notes below.\n\nclass ObjectInfo extends Struct // Info about a single object - explained in the layout file format\n{\n\tconst PACK = 'sscCCC';\n\tconst UNPACK = 'sX/sY/CZchar/CFlags/CIndex/CHeading';\n\n\tpublic $X;\n\tpublic $Y;\n\tpublic $Zchar;\n\tpublic $Flags;\n\tpublic $Index;\n\tpublic $Heading;\n};\n\nclass IS_AXM extends Struct // AutoX Multiple objects - variable size\n{\n\tconst PACK = 'CCCCCCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CNumO/CUCID/CPMOAction/CPMOFlags/xSp3';\n\n\tprotected $Size;\t\t\t\t\t# 8 + NumO * 8\n\tprotected $Type = ISP_AXM;\t\t\t# ISP_AXM\n\tprotected $ReqI = NULL;\t\t\t\t# 0\n\tpublic $NumO;\t\t\t\t\t\t# number of objects in this packet\n\n\tpublic $UCID = 0;\t\t\t\t\t# unique id of the connection that sent the packet\n\tpublic $PMOAction;\t\t\t\t\t# see below\n\tpublic $PMOFlags;\t\t\t\t\t# see below\n\tprivate $Sp3;\n\n\tpublic $Info = array();\t\t\t\t# info about each object, 0 to 30 of these\n\n\tpublic function pack()\n\t{\n\t\t$this->NumO = count($this->Info);\n\t\t$this->Size = 8 + ($this->NumO * 8);\n\n\t\t$Info = '';\n\t\tforeach ($this->Info as $ObjectInfo)\n\t\t\t$Info .= $ObjectInfo->pack();\n\n\t\treturn parent::pack() . $Info;\n\t}\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\tfor ($i = 0; $i < $this->NumO; $i++)\n\t\t{\n\t\t\t$this->Info[$i] = new ObjectInfo(substr($rawPacket, 8 + ($i * 8), 8));\n\t\t}\n\n\t\treturn $this;\n\t}\n}; function IS_AXM() { return new IS_AXM; }\n\n// Values for PMOAction byte\n\ndefine('PMO_LOADING_FILE',\t0);// 0 - sent by the layout loading system only\ndefine('PMO_ADD_OBJECTS',\t1);// 1 - adding objects (from InSim or editor)\ndefine('PMO_DEL_OBJECTS',\t2);// 2 - delete objects (from InSim or editor)\ndefine('PMO_CLEAR_ALL',\t\t3);// 3 - clear all objects (NumO must be zero)\ndefine('PMO_NUM',\t\t\t4);\n$PMO = array(PMO_LOADING_FILE => 'PMO_LOADING_FILE', PMO_ADD_OBJECTS => 'PMO_ADD_OBJECTS', PMO_DEL_OBJECTS => 'PMO_DEL_OBJECTS', PMO_CLEAR_ALL => 'PMO_CLEAR_ALL', PMO_NUM => 'PMO_NUM');\n\n// Info about the PMOFlags byte (only bit 0 is currently used) :\n\n// If PMOFlags bit 0 is set in a PMO_LOADING_FILE packet, LFS has reached the end of\n// a layout file which it is loading.  The added objects will then be optimised.\n\n// Optimised in this case means that static vertex buffers will be created for all\n// objects, to greatly improve the frame rate.  The problem with this is that when\n// there are many objects loaded, optimisation causes a significant glitch which can\n// be long enough to cause a driver who is cornering to lose control and crash.\n\n// PMOFlags bit 0 can also be set in an IS_AXM with PMOAction of PMO_ADD_OBJECTS.\n// This causes all objects to be optimised.  It is important not to set bit 0 in\n// every packet you send to add objects or you will cause severe glitches on the\n// clients computers.  It is ok to have some objects on the track which are not\n// optimised.  So if you have a few objects that are being removed and added\n// occasionally, the best advice is not to request optimisation at all.  Only\n// request optimisation (by setting bit 0) if you have added so many objects\n// that it is needed to improve the frame rate.\n\n// NOTE 1) LFS makes sure that all objects are optimised when the race restarts.\n// NOTE 2) In the 'more' section of SHIFT+U there is info about optimised objects.\n\n// If you are using InSim to send many packets of objects (for example loading an\n// entire layout through InSim) then you must take care of the bandwidth and buffer\n// overflows.  You must not try to send all the objects at once.  It's probably good\n// to use LFS's method of doing this : send the first packet of objects then wait for\n// the corresponding IS_AXM that will be output when the packet is processed.  Then\n// you can send the second packet and again wait for the IS_AXM and so on.\n\n\n// CAR POSITION PACKETS (Initialising OutSim from InSim - See \"OutSim\" below)\n// ====================\n\n// To request Car Positions from the currently viewed car, send this IS_SMALL :\n\n// ReqI : 0\n// SubT : SMALL_SSP\t\t(Start Sending Positions)\n// UVal : interval\t\t(time between updates - zero means stop sending)\n\n// If OutSim has not been setup in cfg.txt, the SSP packet makes LFS send UDP packets\n// if in game, using the OutSim system as documented near the end of this text file.\n\n// You do not need to set any OutSim values in LFS cfg.txt - OutSim is fully\n// initialised by the SSP packet.\n\n// The OutSim packets will be sent to the UDP port specified in the InSimInit packet.\n\n// NOTE : OutSim packets are not InSim packets and don't have a 4-byte header.\n\n\n// DASHBOARD PACKETS (Initialising OutGauge from InSim - See \"OutGauge\" below)\n// =================\n\n// To request Dashboard Packets from the currently viewed car, send this IS_SMALL :\n\n// ReqI : 0\n// SubT : SMALL_SSG\t\t(Start Sending Gauges)\n// UVal : interval\t\t(time between updates - zero means stop sending)\n\n// If OutGauge has not been setup in cfg.txt, the SSG packet makes LFS send UDP packets\n// if in game, using the OutGauge system as documented near the end of this text file.\n\n// You do not need to set any OutGauge values in LFS cfg.txt - OutGauge is fully\n// initialised by the SSG packet.\n\n// The OutGauge packets will be sent to the UDP port specified in the InSimInit packet.\n\n// NOTE : OutGauge packets are not InSim packets and don't have a 4-byte header.\n\n\n// CAMERA CONTROL\n// ==============\n\n// IN GAME camera control\n// ----------------------\n\n// You can set the viewed car and selected camera directly with a special packet\n// These are the states normally set in game by using the TAB and V keys\n\nclass IS_SCC extends Struct // Set Car Camera - Simplified camera packet (not SHIFT+U mode)\n{\n\tconst PACK = 'CCxxCCxx';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/CViewPLID/CInGameCam/CSp2/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_SCC;\t\t\t# ISP_SCC\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tprotected $Zero;\n\n\tpublic $ViewPLID;\t\t\t\t\t# Unique ID of player to view\n\tpublic $InGameCam;\t\t\t\t\t# InGameCam (as reported in StatePack)\n\tprotected $Sp2;\n\tprotected $Sp3;\n}; function IS_SCC() { return new IS_SCC; }\n\n// NOTE : Set InGameCam or ViewPLID to 255 to leave that option unchanged.\n\n// DIRECT camera control\n// ---------------------\n\n// A Camera Position Packet can be used for LFS to report a camera position and state.\n// An InSim program can also send one to set LFS camera position in game or SHIFT+U mode.\n\n// Type : \"Vec\" : 3 ints (X, Y, Z) - 65536 means 1 metre\n\nclass IS_CPP extends Struct // Cam Pos Pack - Full camera packet (in car OR SHIFT+U mode)\n{\n\tconst PACK = 'CCCxl3vvvCCfvv';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/l3Pos/vH/vP/vR/CViewPLID/CInGameCam/fFOV/CTime/CFlags';\n\n\tprotected $Size = 32;\t\t\t\t# 32\n\tprotected $Type = ISP_CPP;\t\t\t# ISP_CPP\n\tpublic $ReqI;\t\t\t\t\t\t# inStruction : 0 / or reply : ReqI as received in the TINY_SCP\n\tprotected $Zero;\n\n\tpublic $Pos;\t\t\t\t\t\t# Position vector\n\n\tpublic $H;\t\t\t\t\t\t\t# heading - 0 points along Y axis\n\tpublic $P;\t\t\t\t\t\t\t# pitch   - 0 means looking at horizon\n\tpublic $R;\t\t\t\t\t\t\t# roll    - 0 means no roll\n\n\tpublic $ViewPLID;\t\t\t\t\t# Unique ID of viewed player (0 = none)\n\tpublic $InGameCam;\t\t\t\t\t# InGameCam (as reported in StatePack)\n\n\tpublic $FOV;\t\t\t\t\t\t# 4-byte float : FOV in degrees\n\n\tpublic $Time;\t\t\t\t\t\t# Time in ms to get there (0 means instant)\n\tpublic $Flags;\t\t\t\t\t\t# ISS state flags (see below)\n}; function IS_CPP() { return new IS_CPP; }\n\n// The ISS state flags that can be set are :\n\n// ISS_SHIFTU\t\t\t- in SHIFT+U mode\n// ISS_SHIFTU_FOLLOW\t- FOLLOW view\n// ISS_VIEW_OVERRIDE\t- override user view\n\n// On receiving this packet, LFS will set up the camera to match the values in the packet,\n// including switching into or out of SHIFT+U mode depending on the ISS_SHIFTU flag.\n\n// If ISS_VIEW_OVERRIDE is set, the in-car view Heading Pitch and Roll will be taken\n// from the values in this packet.  Otherwise normal in game control will be used.\n\n// Position vector (Vec Pos) - in SHIFT+U mode, Pos can be either relative or absolute.\n\n// If ISS_SHIFTU_FOLLOW is set, it's a following camera, so the position is relative to\n// the selected car.  Otherwise, the position is absolute, as used in normal SHIFT+U mode.\n\n// NOTE : Set InGameCam or ViewPLID to 255 to leave that option unchanged.\n\n// SMOOTH CAMERA POSITIONING\n// --------------------------\n\n// The \"Time\" value in the packet is used for camera smoothing.  A zero Time means instant\n// positioning.  Any other value (milliseconds) will cause the camera to move smoothly to\n// the requested position in that time.  This is most useful in SHIFT+U camera modes or\n// for smooth changes of internal view when using the ISS_VIEW_OVERRIDE flag.\n\n// NOTE : You can use frequently updated camera positions with a longer Time value than\n// the update frequency.  For example, sending a camera position every 100 ms, with a\n// Time value of 1000 ms.  LFS will make a smooth motion from the rough inputs.\n\n// If the requested camera mode is different from the one LFS is already in, it cannot\n// move smoothly to the new position, so in this case the \"Time\" value is ignored.\n\n// GETTING A CAMERA PACKET\n// -----------------------\n\n// To GET a CamPosPack from LFS, send this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_SCP\t\t(Send Cam Pos)\n\n// LFS will reply with a CamPosPack as described above.  You can store this packet\n// and later send back exactly the same packet to LFS and it will try to replicate\n// that camera position.\n\n\n// TIME CONTROL\n// ============\n\n// Request the current time at any point with this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_GTH\t\t(Get Time in Hundredths)\n\n// The time will be sent back in this IS_SMALL :\n\n// ReqI : non-zero\t\t(as received in the request packet)\n// SubT : SMALL_RTP\t\t(Race Time Packet)\n// UVal\t: Time\t\t\t(hundredths of a second since start of race or replay)\n\n// You can stop or start time in LFS and while it is stopped you can send packets to move\n// time in steps.  Time steps are specified in hundredths of a second.\n// Warning : unlike pausing, this is a \"trick\" to LFS and the program is unaware of time\n// passing so you must not leave it stopped because LFS is unusable in that state.\n// This packet is not available in live multiplayer mode.\n\n// Stop and Start with this IS_SMALL :\n\n// ReqI : 0\n// SubT : SMALL_TMS\t\t(TiMe Stop)\n// UVal\t: stop\t\t\t(1 - stop / 0 - carry on)\n\n// When STOPPED, make time step updates with this IS_SMALL :\n\n// ReqI : 0\n// SubT : SMALL_STP\t\t(STeP)\n// UVal : number\t\t(number of hundredths of a second to update)\n\n\n// REPLAY CONTROL\n// ==============\n\n// You can load a replay or set the position in a replay with an IS_RIP packet.\n// Replay positions and lengths are specified in hundredths of a second.\n// LFS will reply with another IS_RIP packet when the request is completed.\n\nclass IS_RIP extends Struct // Replay Information Packet\n{\n\tconst PACK = 'CCCCCCCxVVa64';\n\tconst UNPACK = 'CSize/CType/CReqI/CError/CMPR/CPaused/COptions/CSp3/VCTime/VTTime/a64RName';\n\n\tprotected $Size = 80;\t\t\t\t# 80\n\tprotected $Type = ISP_RIP;\t\t\t# ISP_RIP\n\tpublic $ReqI;\t\t\t\t\t\t# request : non-zero / reply : same value returned\n\tpublic $Error;\t\t\t\t\t\t# 0 or 1 = OK / other values are listed below\n\n\tpublic $MPR;\t\t\t\t\t\t# 0 = SPR / 1 = MPR\n\tpublic $Paused;\t\t\t\t\t\t# request : pause on arrival / reply : paused state\n\tpublic $Options;\t\t\t\t\t# various options - see below\n\tprotected $Sp3;\n\n\tpublic $CTime;\t\t\t\t\t\t# (hundredths) request : destination / reply : position\n\tpublic $TTime;\t\t\t\t\t\t# (hundredths) request : zero / reply : replay length\n\n\tpublic $RName;\t\t\t\t\t\t# zero or replay name - last byte must be zero\n}; function IS_RIP() { return new IS_RIP; }\n\n// NOTE about RName :\n// In a request, replay RName will be loaded.  If zero then the current replay is used.\n// In a reply, RName is the name of the current replay, or zero if no replay is loaded.\n\n// You can request an IS_RIP packet at any time with this IS_TINY :\n\n// ReqI : non-zero\t\t(returned in the reply)\n// SubT : TINY_RIP\t\t(Replay Information Packet)\n\n// Error codes returned in IS_RIP replies :\n\ndefine('RIP_OK',\t\t\t0);\t//  0 - OK : completed inStruction\ndefine('RIP_ALREADY',\t\t1);\t//  1 - OK : already at the destination\ndefine('RIP_DEDICATED',\t\t2);\t//  2 - can't run a replay - dedicated host\ndefine('RIP_WRONG_MODE',\t3);\t//  3 - can't start a replay - not in a suitable mode\ndefine('RIP_NOT_REPLAY',\t4);\t//  4 - RName is zero but no replay is currently loaded\ndefine('RIP_CORRUPTED',\t\t5);\t//  5 - IS_RIP corrupted (e.g. RName does not end with zero)\ndefine('RIP_NOT_FOUND',\t\t6);\t//  6 - the replay file was not found\ndefine('RIP_UNLOADABLE',\t7);\t//  7 - obsolete / future / corrupted\ndefine('RIP_DEST_OOB',\t\t8);\t//  8 - destination is beyond replay length\ndefine('RIP_UNKNOWN',\t\t9);\t//  9 - unknown error found starting replay\ndefine('RIP_USER',\t\t\t10);// 10 - replay search was terminated by user\ndefine('RIP_OOS',\t\t\t10);// 11 - can't reach destination - SPR is out of sync\n$RIP = array(RIP_OK => 'RIP_OK', RIP_ALREADY => 'RIP_ALREADY', RIP_DEDICATED => 'RIP_DEDICATED', RIP_WRONG_MODE => 'RIP_WRONG_MODE', RIP_NOT_REPLAY => 'RIP_NOT_REPLAY', RIP_CORRUPTED => 'RIP_CORRUPTED', RIP_NOT_FOUND => 'RIP_NOT_FOUND', RIP_UNLOADABLE => 'RIP_UNLOADABLE', RIP_DEST_OOB => 'RIP_DEST_OOB', RIP_UNKNOWN => 'RIP_UNKNOWN', RIP_USER => 'RIP_USER', RIP_OOS => 'RIP_OOS');\n\n// Options byte : some options\n\ndefine('RIPOPT_LOOP',\t1);\t// replay will loop if this bit is set\ndefine('RIPOPT_SKINS',\t2);\t// set this bit to download missing skins\n$RIPOPT = array(RIPOPT_LOOP => 'RIPOPT_LOOP', RIPOPT_SKINS => 'RIPOPT_SKINS');\n\n// SCREENSHOTS\n// ===========\n\n// You can instuct LFS to save a screenshot using the IS_SSH packet.\n// The screenshot will be saved as an uncompressed BMP in the data\\shots folder.\n// BMP can be a filename (excluding .bmp) or zero - LFS will create a file name.\n// LFS will reply with another IS_SSH when the request is completed.\n\nclass IS_SSH extends Struct // ScreenSHot\n{\n\tconst PACK = 'CCCCxxxxa32';\n\tconst UNPACK = 'CSize/CType/CReqI/CError/CSp0/CSp1/CSp2/CSp3/a32BMP';\n\n\tprotected $Size = 40;\t\t\t\t# 40\n\tprotected $Type = ISP_SSH;\t\t\t# ISP_SSH\n\tpublic $ReqI;\t\t\t\t\t\t# request : non-zero / reply : same value returned\n\tpublic $Error;\t\t\t\t\t\t# 0 = OK / other values are listed below\n\n\tprotected $Sp0;\t\t\t\t\t\t# 0\n\tprotected $Sp1;\t\t\t\t\t\t# 0\n\tprotected $Sp2;\t\t\t\t\t\t# 0\n\tprotected $Sp3;\t\t\t\t\t\t# 0\n\n\tpublic $BMP;\t\t\t\t\t\t# name of screenshot file - last byte must be zero\n}; function IS_SSH() { return new IS_SSH; }\n\n// Error codes returned in IS_SSH replies :\n\ndefine('SSH_OK',\t\t0);\t//  0 - OK : completed inStruction\ndefine('SSH_DEDICATED',\t1);\t//  1 - can't save a screenshot - dedicated host\ndefine('SSH_CORRUPTED',\t2);\t//  2 - IS_SSH corrupted (e.g. BMP does not end with zero)\ndefine('SSH_NO_SAVE',\t3);\t//  3 - could not save the screenshot\n$SSH = array(SSH_OK => 'SSH_OK', SSH_DEDICATED => 'SSH_DEDICATED', SSH_CORRUPTED => 'SSH_CORRUPTED', SSH_NO_SAVE => 'SSH_NO_SAVE');\n\n// BUTTONS\n// =======\n\n// You can make up to 240 buttons appear on the host or guests (ID = 0 to 239).\n// You should set the ISF_LOCAL flag (in IS_ISI) if your program is not a host control\n// system, to make sure your buttons do not conflict with any buttons sent by the host.\n\n// LFS can display normal buttons in these four screens :\n\n// - main entry screen\n// - game setup screen\n// - in game\n// - SHIFT+U mode\n\n// The recommended area for most buttons is defined by :\n\ndefine('IS_X_MIN',\t0);\ndefine('IS_X_MAX',\t110);\ndefine('IS_Y_MIN',\t30);\ndefine('IS_Y_MAX',\t170);\n$IS = array(IS_X_MIN => 'IS_X_MIN', IS_X_MAX => 'IS_X_MAX', IS_Y_MIN => 'IS_Y_MIN', IS_Y_MAX => 'IS_Y_MAX');\n\n// If you draw buttons in this area, the area will be kept clear to\n// avoid overlapping LFS buttons with your InSim program's buttons.\n// Buttons outside that area will not have a space kept clear.\n// You can also make buttons visible in all screens - see below.\n\n// To delete one button or clear all buttons, send this packet :\n\nclass IS_BFN extends Struct  // Button FunctioN - delete buttons / receive button requests\n{\n\tconst PACK = 'CCxCCCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CSubT/CUCID/CClickID/CInst/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_BFN;\t\t\t# ISP_BFN\n\tprotected $ReqI;\t\t\t\t\t# 0\n\tpublic $SubT;\t\t\t\t\t\t# subtype, from BFN_ enumeration (see below)\n\n\tpublic $UCID;\t\t\t\t\t\t# connection to send to or from (0 = local / 255 = all)\n\tpublic $ClickID;\t\t\t\t\t# ID of button to delete (if SubT is BFN_DEL_BTN)\n\tpublic $Inst;\t\t\t\t\t\t# used internally by InSim\n\tprotected $Sp3;\n}; function IS_BFN() { return new IS_BFN; }\n\n// the fourth byte of IS_BFN packets is one of these\ndefine('BFN_DEL_BTN',\t0);\t//  0 - inStruction     : delete one button (must set ClickID)\ndefine('BFN_CLEAR',\t\t1);\t//  1 - inStruction\t    : clear all buttons made by this insim instance\ndefine('BFN_USER_CLEAR',2);\t//  2 - info            : user cleared this insim instance's buttons\ndefine('BFN_REQUEST',\t3);\t//  3 - user request    : SHIFT+B or SHIFT+I - request for buttons\n$BFN = array(BFN_DEL_BTN => 'BFN_DEL_BTN', BFN_CLEAR => 'BFN_CLEAR', BFN_USER_CLEAR => 'BFN_USER_CLEAR', BFN_REQUEST => 'BFN_REQUEST');\n\n// NOTE : BFN_REQUEST allows the user to bring up buttons with SHIFT+B or SHIFT+I\n\n// SHIFT+I clears all host buttons if any - or sends a BFN_REQUEST to host instances\n// SHIFT+B is the same but for local buttons and local instances\n\n// To send a button to LFS, send this variable sized packet\n\nclass IS_BTN extends Struct // BuTtoN - button header - followed by 0 to 240 characters\n{\n\tconst PACK = 'CCCCCCCCCCCCa240';\n\tconst UNPACK = 'CSize/CType/CReqI/CUCID/CClickID/CInst/CBStyle/CTypeIn/CL/CT/CW/CH/a240Text';\n\n\tprotected $Size = 252;\t\t\t\t# 12 + TEXT_SIZE (a multiple of 4)\n\tprotected $Type = ISP_BTN;\t\t\t# ISP_BTN\n\tpublic $ReqI = 255;\t\t\t\t\t# non-zero (returned in IS_BTC and IS_BTT packets)\n\tpublic $UCID = 255;\t\t\t\t\t# connection to display the button (0 = local / 255 = all)\n\n\tpublic $ClickID = 0;\t\t\t\t# button ID (0 to 239)\n\tpublic $Inst = NULL;\t\t\t\t# some extra flags - see below\n\tpublic $BStyle = NULL;\t\t\t\t# button style flags - see below\n\tpublic $TypeIn = NULL;\t\t\t\t# max chars to type in - see below\n\n\tpublic $L = IS_X_MIN;\t\t\t\t# left   : 0 - 200\n\tpublic $T = IS_Y_MIN;\t\t\t\t# top    : 0 - 200\n\tpublic $W = 0;\t\t\t\t\t\t# width  : 0 - 200\n\tpublic $H = 0;\t\t\t\t\t\t# height : 0 - 200\n\n\tpublic $Text = '';\t\t\t\t\t# 0 to 240 characters of text\n\n\tpublic function pack()\n\t{\n\t\tif (strLen($this->Text) > 239)\n\t\t\t$this->Text = subStr($this->Msg, 0, 239);\n\t\treturn parent::pack();\n\t}\n}; function IS_BTN() { return new IS_BTN; }\n\n// ClickID byte : this value is returned in IS_BTC and IS_BTT packets.\n\n// Host buttons and local buttons are stored separately, so there is no chance of a conflict between\n// a host control system and a local system (although the buttons could overlap on screen).\n\n// Programmers of local InSim programs may wish to consider using a configurable button range and\n// possibly screen position, in case their users will use more than one local InSim program at once.\n\n// TypeIn byte : if set, the user can click this button to type in text.\n\n// Lowest 7 bits are the maximum number of characters to type in (0 to 95)\n// Highest bit (128) can be set to initialise dialog with the button's text\n\n// On clicking the button, a text entry dialog will be opened, allowing the specified number of\n// characters to be typed in.  The caption on the text entry dialog is optionally customisable using\n// Text in the IS_BTN packet.  If the first character of IS_BTN's Text field is zero, LFS will read\n// the caption up to the second zero.  The visible button text then follows that second zero.\n\n// Text : 65-66-67-0 would display button text \"ABC\" and no caption\n\n// Text : 0-65-66-67-0-68-69-70-71-0-0-0 would display button text \"DEFG\" and caption \"ABC\"\n\n// Inst byte : mainly used internally by InSim but also provides some extra user flags\n\ndefine('INST_ALWAYS_ON',\t128);// if this bit is set the button is visible in all screens\n$INST = array(INST_ALWAYS_ON => 'INST_ALWAYS_ON');\n\n// NOTE : You should not use INST_ALWAYS_ON for most buttons.  This is a special flag for buttons\n// that really must be on in all screens (including the garage and options screens).  You will\n// probably need to confine these buttons to the top or bottom edge of the screen, to avoid\n// overwriting LFS buttons.  Most buttons should be defined without this flag, and positioned\n// in the recommended area so LFS can keep a space clear in the main screens.\n\n// BStyle byte : style flags for the button\n\ndefine('ISB_C1',\t\t1);\t\t\t// you can choose a standard\ndefine('ISB_C2',\t\t2);\t\t\t// interface colour using\ndefine('ISB_C4',\t\t4);\t\t\t// these 3 lowest bits - see below\ndefine('ISB_CLICK',\t\t8);\t\t\t// click this button to send IS_BTC\ndefine('ISB_LIGHT',\t\t16);\t\t// light button\ndefine('ISB_DARK',\t\t32);\t\t// dark button\ndefine('ISB_LEFT',\t\t64);\t\t// align text to left\ndefine('ISB_RIGHT',\t\t128);\t\t// align text to right\n\n// colour 0 : light grey\t\t(not user editable)\n// colour 1 : title colour\t\t(default:yellow)\n// colour 2 : unselected text\t(default:black)\n// colour 3 : selected text\t\t(default:white)\n// colour 4 : ok\t\t\t\t(default:green)\n// colour 5 : cancel\t\t\t(default:red)\n// colour 6 : text string\t\t(default:pale blue)\n// colour 7 : unavailable\t\t(default:grey)\n\n// NOTE : If width or height are zero, this would normally be an invalid button.  But in that case if\n// there is an existing button with the same ClickID, all the packet contents are ignored except the\n// Text field.  This can be useful for updating the text in a button without knowing its position.\n// For example, you might reply to an IS_BTT using an IS_BTN with zero W and H to update the text.\n\n// Replies : If the user clicks on a clickable button, this packet will be sent :\n\nclass IS_BTC extends Struct // BuTton Click - sent back when user clicks a button\n{\n\tconst PACK = 'CCCCCCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CUCID/CClickID/CInst/CCFlags/CSp3';\n\n\tprotected $Size = 8;\t\t\t\t# 8\n\tprotected $Type = ISP_BTC;\t\t\t# ISP_BTC\n\tpublic $ReqI;\t\t\t\t\t\t# ReqI as received in the IS_BTN\n\tpublic $UCID;\t\t\t\t\t\t# connection that clicked the button (zero if local)\n\n\tpublic $ClickID;\t\t\t\t\t# button identifier originally sent in IS_BTN\n\tpublic $Inst;\t\t\t\t\t\t# used internally by InSim\n\tpublic $CFlags;\t\t\t\t\t\t# button click flags - see below\n\tprotected $Sp3;\n}; function IS_BTC() { return new IS_BTC; }\n\n// CFlags byte : click flags\n\ndefine('ISB_LMB',\t\t1);\t\t// left click\ndefine('ISB_RMB',\t\t2);\t\t// right click\ndefine('ISB_CTRL',\t\t4);\t\t// ctrl + click\ndefine('ISB_SHIFT',\t\t8);\t\t// shift + click\n$ISB = array(ISB_LMB => 'ISB_LMB', ISB_RMB => 'ISB_RMB', ISB_CTRL => 'ISB_CTRL', ISB_SHIFT => 'ISB_SHIFT');\n\n// If the TypeIn byte is set in IS_BTN the user can type text into the button\n// In that case no IS_BTC is sent - an IS_BTT is sent when the user presses ENTER\n\nclass IS_BTT extends Struct // BuTton Type - sent back when user types into a text entry button\n{\n\tconst PACK = 'CCCCCCCxa96';\n\tconst UNPACK = 'CSize/CType/CReqI/CUCID/CClickID/CInst/CTypeIn/CSp3/a96Text';\n\n\tprotected $Size = 104;\t\t\t\t# 104\n\tprotected $Type = ISP_BTT;\t\t\t# ISP_BTT\n\tpublic $ReqI;\t\t\t\t\t\t# ReqI as received in the IS_BTN\n\tpublic $UCID;\t\t\t\t\t\t# connection that typed into the button (zero if local)\n\n\tpublic $ClickID;\t\t\t\t\t# button identifier originally sent in IS_BTN\n\tpublic $Inst;\t\t\t\t\t\t# used internally by InSim\n\tpublic $TypeIn;\t\t\t\t\t\t# from original button specification\n\tprotected $Sp3;\n\n\tpublic $Text;\t\t\t\t\t\t# typed text, zero to TypeIn specified in IS_BTN\n}; function IS_BTT() { return new IS_BTT; }\n\n\n// OutSim - MOTION SIMULATOR SUPPORT\n// ======\n\n// The user's car in multiplayer or the viewed car in single player or\n// single player replay can output information to a motion system while\n// viewed from an internal view.\n\n// This can be controlled by 5 lines in the cfg.txt file :\n\n// OutSim Mode 0        :0-off 1-driving 2-driving+replay\n// OutSim Delay 1       :minimum delay between packets (100ths of a sec)\n// OutSim IP 0.0.0.0    :IP address to send the UDP packet\n// OutSim Port 0        :IP port\n// OutSim ID 0          :if not zero, adds an identifier to the packet\n\n// Each update sends the following UDP packet :\nclass OutSimPack extends Struct\n{\n\tconst PACK = 'Vf12V3';\n\tconst UNPACK = 'VTime/f3AngVel/fHeading/fPitch/fRoll/f3Accel/f3Vel/V3Pos';\n\tconst LENGTH = 64;\n\n\tpublic $Time;\t\t\t\t\t\t# time in milliseconds (to check order)\n\n\tpublic $AngVel;\t\t\t\t\t\t# 3 floats, angular velocity vector\n\tpublic $Heading;\t\t\t\t\t# anticlockwise from above (Z)\n\tpublic $Pitch;\t\t\t\t\t\t# anticlockwise from right (X)\n\tpublic $Roll;\t\t\t\t\t\t# anticlockwise from front (Y)\n\tpublic $Accel;\t\t\t\t\t\t# 3 floats X, Y, Z\n\tpublic $Vel;\t\t\t\t\t\t# 3 floats X, Y, Z\n\tpublic $Pos;\t\t\t\t\t\t# 3 ints   X, Y, Z (1m = 65536)\n\n\tpublic $ID;\t\t\t\t\t\t\t# optional - only if OutSim ID is specified\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\t$unpack = (strlen($rawPacket) == self::LENGTH) ? $this::UNPACK : $this::UNPACK . '/VID';\n\t\t\n\t\tforeach (unpack($unpack, $rawPacket) as $property => $value)\n\t\t\t$this->$property = $value;\n\n\t\treturn $this;\n\t}\n};\n\n// NOTE 1) X and Y axes are on the ground, Z is up.\n\n// NOTE 2) Motion simulators can be dangerous.  The Live for Speed developers do\n// not support any motion systems in particular and cannot accept responsibility\n// for injuries or deaths connected with the use of such machinery.\n\n\n// OutGauge - EXTERNAL DASHBOARD SUPPORT\n// ========\n\n// The user's car in multiplayer or the viewed car in single player or\n// single player replay can output information to a dashboard system\n// while viewed from an internal view.\n\n// This can be controlled by 5 lines in the cfg.txt file :\n\n// OutGauge Mode 0        :0-off 1-driving 2-driving+replay\n// OutGauge Delay 1       :minimum delay between packets (100ths of a sec)\n// OutGauge IP 0.0.0.0    :IP address to send the UDP packet\n// OutGauge Port 0        :IP port\n// OutGauge ID 0          :if not zero, adds an identifier to the packet\n\n// Each update sends the following UDP packet :\n\nclass OutGaugePack extends Struct\n{\n\tconst PACK = 'Va4vCxfffffffVVfffa16a16';\n\tconst UNPACK = 'VTime/a4Car/vFlags/CGear/CSpareB/fSpeed/fRPM/fTurbo/fEngTemp/fFuel/fOilPressure/fOilTemp/VDashLights/VShowLights/fThrottle/fBrake/fClutch/a16Display1/a16Display2';\n\tconst LENGTH = 92; # Or 96 with ID.\n\n\tpublic $Time;\t\t\t\t\t\t# time in milliseconds (to check order)\n\n\tpublic $Car;\t\t\t\t\t\t# Car name\n\tpublic $Flags;\t\t\t\t\t\t# Info (see OG_x below)\n\tpublic $Gear;\t\t\t\t\t\t# Reverse:0, Neutral:1, First:2...\n\tprotected $SpareB;\n\tpublic $Speed;\t\t\t\t\t\t# M/S\n\tpublic $RPM;\t\t\t\t\t\t# RPM\n\tpublic $Turbo;\t\t\t\t\t\t# BAR\n\tpublic $EngTemp;\t\t\t\t\t# C\n\tpublic $Fuel;\t\t\t\t\t\t# 0 to 1\n\tpublic $OilPressure;\t\t\t\t# BAR\n\tpublic $OilTemp;\t\t\t\t\t# C\n\tpublic $DashLights;\t\t\t\t\t# Dash lights available (see DL_x below)\n\tpublic $ShowLights;\t\t\t\t\t# Dash lights currently switched on\n\tpublic $Throttle;\t\t\t\t\t# 0 to 1\n\tpublic $Brake;\t\t\t\t\t\t# 0 to 1\n\tpublic $Clutch;\t\t\t\t\t\t# 0 to 1\n\tpublic $Display1;\t\t\t\t\t# Usually Fuel\n\tpublic $Display2;\t\t\t\t\t# Usually Settings\n\n\tpublic $ID;\t\t\t\t\t\t\t# optional - only if OutGauge ID is specified\n\t\n\tpublic function unpack($rawPacket)\n\t{\n\t\t$unpack = (strlen($rawPacket) == self::LENGTH) ? $this::UNPACK : $this::UNPACK . '/VID';\n\t\t\n\t\tforeach (unpack($unpack, $rawPacket) as $property => $value)\n\t\t\t$this->$property = $value;\n\n\t\treturn $this;\n\t}\n};\n\n// OG_x - bits for OutGaugePack Flags\n\ndefine('OG_TURBO',\t8192);\t// show turbo gauge\ndefine('OG_KM',\t\t16384);\t// if not set - user prefers MILES\ndefine('OG_BAR',\t32768);\t// if not set - user prefers PSI\n$OG = array(OG_TURBO => 'OG_TURBO', OG_KM => 'OG_KM', OG_BAR => 'OG_BAR');\n\n// DL_x - bits for OutGaugePack DashLights and ShowLights\n\ndefine('DL_SHIFT',\t\t(1 << 1));\t// bit 0\t- shift light\ndefine('DL_FULLBEAM',\t(1 << 2));\t// bit 1\t- full beam\ndefine('DL_HANDBRAKE',\t(1 << 3));\t// bit 2\t- handbrake\ndefine('DL_PITSPEED',\t(1 << 4));\t// bit 3\t- pit speed limiter\ndefine('DL_TC',\t\t\t(1 << 5));\t// bit 4\t- TC active or switched off\ndefine('DL_SIGNAL_L',\t(1 << 6));\t// bit 5\t- left turn signal\ndefine('DL_SIGNAL_R',\t(1 << 7));\t// bit 6\t- right turn signal\ndefine('DL_SIGNAL_ANY',\t(1 << 8));\t// bit 7\t- shared turn signal\ndefine('DL_OILWARN',\t(1 << 9));\t// bit 8\t- oil pressure warning\ndefine('DL_BATTERY',\t(1 << 10));\t// bit 9\t- battery warning\ndefine('DL_ABS',\t\t(1 << 11));\t// bit 10\t- ABS active or switched off\ndefine('DL_SPARE',\t\t(1 << 12));\t// bit 11\ndefine('DL_NUM',\t\t13);\n$DL = array(DL_SHIFT => 'DL_SHIFT', DL_FULLBEAM => 'DL_FULLBEAM', DL_HANDBRAKE => 'DL_HANDBRAKE', DL_PITSPEED => 'DL_PITSPEED', DL_TC => 'DL_TC', DL_SIGNAL_L => 'DL_SIGNAL_L', DL_SIGNAL_R => 'DL_SIGNAL_R', DL_SIGNAL_ANY => 'DL_SIGNAL_ANY', DL_OILWARN => 'DL_OILWARN', DL_BATTERY => 'DL_BATTERY', DL_ABS => 'DL_ABS', DL_SPARE => 'DL_SPARE', DL_NUM => 'DL_NUM');\n\n//////\n#endif\n\n// InSimRelay for LFS InSim version 4 (LFS 0.5X and up)\n//\n// The Relay code below can be seen as an extension to the regular\n// InSim protocol, as the packets are conStructed in the same\n// manner as regular InSim packets.\n//\n// Connect your client to isrelay.lfs.net:47474 with TCP\n// After you are connected you can request a hostlist, so you can see\n// which hosts you can connect to.\n// Then you can send a packet to the Relay to select a host. After that\n// the Relay will send you all insim data from that host.\n\n// Some hosts require a spectator password in order to be selectable.\n\n// You do not need to specify a spectator password if you use a valid administrator password.\n\n// If you connect with an administrator password, you can send just about every\n// regular InSim packet there is available in LFS, just like as if you were connected\n// to the host directly. For a full list, see end of document.\n\n\n\n\n// Packet types used for the Relay\n\ndefine('IRP_ARQ',\t250);\t// Send : request if we are host admin (after connecting to a host)\ndefine('IRP_ARP',\t251);\t// Receive : replies if you are admin (after connecting to a host)\ndefine('IRP_HLR',\t252);\t// Send : To request a hostlist\ndefine('IRP_HOS',\t253);\t// Receive : Hostlist info\ndefine('IRP_SEL',\t254);\t// Send : To select a host\ndefine('IRP_ERR',\t255);\t// Receive : An error number\n$IRP = array(IRP_ARQ => 'IRP_ARQ', IRP_ARP => 'IRP_ARP', IRP_HLR => 'IRP_HLR', IRP_HOS => 'IRP_HOS', IRP_SEL => 'IRP_SEL', IRP_ERR => 'IRP_ERR');\n\n// To request a hostlist from the Relay, send this packet :\n\nclass IR_HLR extends Struct // HostList Request\n{\n\tconst PACK = 'CCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CSp0';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = IRP_HLR;\t\t\t# IRP_HLR\n\tpublic $ReqI;\n\tprotected $Sp0;\n}; function IR_HLR() { return new IR_HLR; }\n\n\n// That will return (multiple) packets containing hostnames and some information about them\n\n// The following Struct is a subpacket of the IR_HOS packet\n\nclass HInfo // Sub packet for IR_HOS. Contains host information\n{\n\tconst PACK = 'a32a6CC';\n\tconst UNPACK = 'a32HName/a6Track/CFlags/CNumConns';\n\n\tpublic $HName;\t\t\t\t\t\t# Name of the host\n\n\tpublic $Track;\t\t\t\t\t\t# Short track name\n\tpublic $Flags;\t\t\t\t\t\t# Info flags about the host - see NOTE 1) below\n\tpublic $NumConns;\t\t\t\t\t# Number of people on the host\n};\n\n// NOTE 1)\n\ndefine('HOS_SPECPASS',\t\t1);\t\t// Host requires a spectator password\ndefine('HOS_LICENSED',\t\t2);\t\t// Bit is set if host is licensed\ndefine('HOS_S1',\t\t\t4);\t\t// Bit is set if host is S1\ndefine('HOS_S2',\t\t\t8);\t\t// Bit is set if host is S2\ndefine('HOS_FIRST',\t\t\t64);\t// Indicates the first host in the list\ndefine('HOS_LAST',\t\t\t128);\t// Indicates the last host in the list\n$HOS = array(HOS_SPECPASS => 'HOS_SPECPASS', HOS_LICENSED => 'HOS_LICENSED', HOS_S1 => 'HOS_S1', HOS_S2 => 'HOS_S2', HOS_FIRST => 'HOS_FIRST', HOS_LAST => 'HOS_LAST');\n\n\nclass IR_HOS extends Struct // Hostlist (hosts connected to the Relay)\n{\n\tconst PACK = 'CCCCa6';\n\tconst UNPACK = 'CSize/CType/CReqI/CNumHosts/a6Info';\n\n\tprotected $Size;\t\t\t\t\t# 4 + NumHosts * 40\n\tprotected $Type = IRP_HOS;\t\t\t# IRP_HOS\n\tpublic $ReqI;\t\t\t\t\t\t# As given in IR_HLR\n\tpublic $NumHosts;\t\t\t\t\t# Number of hosts described in this packet\n\n\tpublic $Info = array();\t\t\t\t# Host info for every host in the Relay. 1 to 6 of these in a IR_HOS\n\n\n\n\tpublic function unpack($rawPacket)\n\t{\n\t\tparent::unpack($rawPacket);\n\n\t\tfor ($i = 0; $i < $this->NumHosts; $i++)\n\t\t{\n\t\t\t$this->Info[$i] = new HInfo(substr($rawPacket, 4 + ($i * 40), 40));\n\t\t}\n\n\t\treturn $this;\n\t}\n}; function IR_HOS() { return new IR_HOS; }\n\n\n// To select a host in the Relay, send this packet :\n\nclass IR_SEL extends Struct // Relay select - packet to select a host, so relay starts sending you data.\n{\n\tconst PACK = 'CCCxa32a16a16';\n\tconst UNPACK = 'CSize/CType/CReqI/CZero/a32HName/a16Admin/a16Spec';\n\n\tprotected $Size = 68;\t\t\t\t# 68\n\tprotected $Type = IRP_SEL;\t\t\t# IRP_SEL\n\tpublic $ReqI;\t\t\t\t\t\t# If non-zero Relay will reply with an IS_VER packet\n\tprotected $Zero;\t\t\t\t\t# 0\n\n\tpublic $HName;\t\t\t\t\t\t# Hostname to receive data from - may be colourcode stripped\n\tpublic $Admin;\t\t\t\t\t\t# Admin password (to gain admin access to host)\n\tpublic $Spec;\t\t\t\t\t\t# Spectator password (if host requires it)\n\n}; function IR_SEL() { return new IR_SEL; }\n\n\n// To request if we are an admin send:\n\nclass IR_ARQ extends Struct // Admin Request\n{\n\tconst PACK = 'CCCx';\n\tconst UNPACK = 'CSize/CType/CReqI/CSp0';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = IRP_ARQ;\t\t\t# IRP_ARQ\n\tpublic $ReqI;\n\tprotected $Sp0;\n}; function IR_ARQ() { return new IR_ARQ; }\n\n\n// Relay will reply to admin status request :\n\nclass IR_ARP extends Struct // Admin Response\n{\n\tconst PACK = 'CCCC';\n\tconst UNPACK = 'CSize/CType/CReqI/CAdmin';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = IRP_ARP;\t\t\t# IRP_ARP\n\tpublic $ReqI;\n\tpublic $Admin;\t\t\t\t\t\t# 0- no admin; 1- admin\n}; function IR_ARP() { return new IR_ARP; }\n\n\n// If you specify a wrong value, like invalid packet / hostname / adminpass / specpass,\n// the Relay returns an error packet :\nclass IR_ERR extends Struct\n{\n\tconst PACK = 'CCCC';\n\tconst UNPACK = 'CSize/CType/CReqI/CErrNo';\n\n\tprotected $Size = 4;\t\t\t\t# 4\n\tprotected $Type = IRP_ERR;\t\t\t# IRP_ERR\n\tpublic $ReqI;\t\t\t\t\t\t# As given in RL_SEL, otherwise 0\n\tpublic $ErrNo;\t\t\t\t\t\t# Error number - see NOTE 2) below\n}; function IR_ERR() { return new IR_ERR; }\n\n// NOTE 2) Error numbers :\n\ndefine('IR_ERR_PACKET',\t\t1);\t// Invalid packet sent by client (wrong Structure / length)\ndefine('IR_ERR_PACKET2',\t2);\t// Invalid packet sent by client (packet was not allowed to be forwarded to host)\ndefine('IR_ERR_HOSTNAME',\t3);\t// Wrong hostname given by client\ndefine('IR_ERR_ADMIN',\t\t4);\t// Wrong admin pass given by client\ndefine('IR_ERR_SPEC',\t\t5);\t// Wrong spec pass given by client\ndefine('IR_ERR_NOSPEC',\t\t6);\t// Spectator pass required, but none given\n$IR = array(IR_ERR_PACKET => 'IR_ERR_PACKET', IR_ERR_PACKET2 => 'IR_ERR_PACKET2', IR_ERR_HOSTNAME => 'IR_ERR_HOSTNAME', IR_ERR_ADMIN => 'IR_ERR_ADMIN', IR_ERR_SPEC => 'IR_ERR_SPEC', IR_ERR_NOSPEC => 'IR_ERR_NOSPEC');\n\n/*\n==============================================\nRegular insim packets that a relay client can send to host :\n\nFor anyone\nTINY_VER\nTINY_PING\nTINY_SCP\nTINY_SST\nTINY_GTH\nTINY_ISM\nTINY_NCN\nTINY_NPL\nTINY_RES\nTINY_REO\nTINY_RST\nTINY_AXI\n\nAdmin only\nTINY_VTC\nISP_MST\nISP_MSX\nISP_MSL\nISP_MTC\nISP_SCH\nISP_BFN\nISP_BTN\n\nThe relay will also accept, but not forward\nTINY_NONE    // for relay-connection maintenance\n*/\n\n/* Start of PRISM PACKET FOOTER */\ndefine('OSP',\t-1);// -1 - info\t\t\t: OutSimPacket - MOTION SIMULATOR SUPPORT\ndefine('OGP',\t-2);// -2 - info\t\t\t: OutGauge - EXTERNAL DASHBOARD SUPPORT\n$SPECIAL = array(OSP => 'OutSimPack', OGP => 'OutGaugePack');\n/* Packet Handler Help */\n$TYPEs = $ISP + $IRP;\nforeach ($TYPEs as $Type => $Name)\n\t$TYPEs[$Type] = substr_replace($Name, '', 2, 1);\n$TYPEs = $SPECIAL + $TYPEs;\n/* End of PRISM PACKET FOOTER */\n\n?>"]],"start1":0,"start2":0,"length1":0,"length2":108894}]],"length":108894}
{"contributors":[],"silentsave":true,"ts":1363202387742,"patch":[[{"diffs":[[0,"cket\n */"],[1,"\n "],[0,"\n\n/* Sta"]],"start1":76,"start2":76,"length1":16,"length2":18}]],"length":108896,"saved":false}
{"ts":1363202389399,"patch":[[{"diffs":[[0,"ket\n */\n"],[-1," "],[0,"\n\n/* Sta"]],"start1":77,"start2":77,"length1":17,"length2":16}]],"length":108895,"saved":false}
{"ts":1363202391102,"patch":[[{"diffs":[[0,"t\n */\n\n\n"],[1,"\n"],[0,"/* Start"]],"start1":79,"start2":79,"length1":16,"length2":17}]],"length":108896,"saved":false}
{"ts":1363202393906,"patch":[[{"diffs":[[0,"et\n */\n\n"],[1,"namepsp"],[0,"\n\n/* Sta"]],"start1":78,"start2":78,"length1":16,"length2":23}]],"length":108903,"saved":false}
{"ts":1363202396052,"patch":[[{"diffs":[[0,"name"],[-1,"psp"],[1,"s"],[0,"\n\n/*"]],"start1":86,"start2":86,"length1":11,"length2":9}]],"length":108901,"saved":false}
{"ts":1363202397789,"patch":[[{"diffs":[[0,"/\n\nnames"],[1,"pace "],[0,"\n\n/* Sta"]],"start1":83,"start2":83,"length1":16,"length2":21}]],"length":108906,"saved":false}
{"ts":1363202402045,"patch":[[{"diffs":[[0,"mespace "],[1,"PRISM\\Module\\"],[0,"\n\n/* Sta"]],"start1":88,"start2":88,"length1":16,"length2":29}]],"length":108919,"saved":false}
{"ts":1363202406902,"patch":[[{"diffs":[[0,"\\Module\\"],[1,"Packet;"],[0,"\n\n/* Sta"]],"start1":101,"start2":101,"length1":16,"length2":23}]],"length":108926,"saved":false}
{"ts":1363202495572,"patch":[[{"diffs":[[0,"\\Packet;"],[1," "],[0,"\n\n/* Sta"]],"start1":108,"start2":108,"length1":16,"length2":17}]],"length":108927,"saved":false}
{"ts":1363202497334,"patch":[[{"diffs":[[0,"Packet; "],[1,"//Am "],[0,"\n\n/* Sta"]],"start1":109,"start2":109,"length1":16,"length2":21}]],"length":108932,"saved":false}
{"ts":1363202499418,"patch":[[{"diffs":[[0,"t; //Am "],[1,"Have Mu"],[0,"\n\n/* Sta"]],"start1":114,"start2":114,"length1":16,"length2":23}]],"length":108939,"saved":false}
{"ts":1363202505519,"patch":[[{"diffs":[[0," Have Mu"],[1,"st Look More Close Damn Si"],[0,"\n\n/* Sta"]],"start1":121,"start2":121,"length1":16,"length2":42}]],"length":108965,"saved":false}
{"ts":1363202508987,"patch":[[{"diffs":[[0,"ose "],[-1,"Damn Si"],[1,"S"],[0,"\n\n/*"]],"start1":144,"start2":144,"length1":15,"length2":9}]],"length":108959,"saved":false}
{"ts":1363202510825,"patch":[[{"diffs":[[0," Close S"],[1,"ize Bi"],[0,"\n\n/* Sta"]],"start1":141,"start2":141,"length1":16,"length2":22}]],"length":108965,"saved":false}
{"ts":1363202512527,"patch":[[{"diffs":[[0," Size Bi"],[1,"g"],[0,"\n\n/* Sta"]],"start1":147,"start2":147,"length1":16,"length2":17}]],"length":108966,"saved":false}
{"contributors":[],"silentsave":false,"ts":1363207695265,"patch":[[{"diffs":[[0,"cket\n */"],[1,"\n\nnamespace PRISM\\Module;"],[0," //Am Ha"]],"start1":76,"start2":76,"length1":16,"length2":41}]],"length":108959,"saved":false}
{"contributors":[],"silentsave":true,"ts":1363274293890,"patch":[[{"diffs":[[0,"t to LFS :\n\n"],[1,"\n\n"],[0,"class IS_ISI"]],"start1":7847,"start2":7847,"length1":24,"length2":26}]],"length":108961,"saved":false}
{"ts":1363274296323,"patch":[[{"diffs":[[0," LFS :\n\n"],[1,"#"],[0,"\n\nclass "]],"start1":7851,"start2":7851,"length1":16,"length2":17}]],"length":108962,"saved":false}
{"ts":1363274299045,"patch":[[{"diffs":[[0,"LFS :\n\n#"],[1,"What is the "],[0,"\n\nclass "]],"start1":7852,"start2":7852,"length1":16,"length2":28}]],"length":108974,"saved":false}
{"ts":1363274302591,"patch":[[{"diffs":[[0," is the "],[1,"long name of this cl"],[0,"\n\nclass "]],"start1":7864,"start2":7864,"length1":16,"length2":36}]],"length":108994,"saved":false}
{"ts":1363274304002,"patch":[[{"diffs":[[0," this cl"],[1,"ass?"],[0,"\n\nclass "]],"start1":7884,"start2":7884,"length1":16,"length2":20}]],"length":108998,"saved":false}
{"ts":1363274311148,"patch":[[{"diffs":[[0,"et\n */\n\n"],[1,"\n\n"],[0,"namespac"]],"start1":78,"start2":78,"length1":16,"length2":18}]],"length":109000,"saved":false}
{"ts":1363274315141,"patch":[[{"diffs":[[0,"et\n */\n\n"],[1,"#Since we are namespacei"],[0,"\n\nnamesp"]],"start1":78,"start2":78,"length1":16,"length2":40}]],"length":109024,"saved":false}
{"ts":1363274317192,"patch":[[{"diffs":[[0,"namespac"],[-1,"e"],[0,"i"],[1,"ng, "],[0,"\n\nnamesp"]],"start1":100,"start2":100,"length1":18,"length2":21}]],"length":109027,"saved":false}
{"contributors":[],"silentsave":true,"ts":1363301232808,"patch":[[{"diffs":[[0,"t\n */\n\n#"],[1," "],[0,"Since we"]],"start1":79,"start2":79,"length1":16,"length2":17}]],"length":109028,"saved":false}
{"ts":1363301240063,"patch":[[{"diffs":[[0,"espacing"],[-1,","],[1," "],[0," \n\nnames"]],"start1":104,"start2":104,"length1":17,"length2":17}]],"length":109028,"saved":false}
{"ts":1363301246501,"patch":[[{"diffs":[[0,"espacing"],[1," shit,"],[0,"  \n\nname"]],"start1":104,"start2":104,"length1":16,"length2":22}]],"length":109034,"saved":false}
{"ts":1363301250549,"patch":[[{"diffs":[[0,"ng shit,"],[1," everything shoul"],[0,"  \n\nname"]],"start1":110,"start2":110,"length1":16,"length2":33}]],"length":109051,"saved":false}
{"ts":1363301252182,"patch":[[{"diffs":[[0,"ng shoul"],[1,"d"],[0,"  \n\nname"]],"start1":127,"start2":127,"length1":16,"length2":17}]],"length":109052,"saved":false}
{"ts":1363301256943,"patch":[[{"diffs":[[0," should "],[1,"have the expanded name "],[0," \n\nnames"]],"start1":129,"start2":129,"length1":16,"length2":39}]],"length":109075,"saved":false}
{"ts":1363301258695,"patch":[[{"diffs":[[0,"ed name "],[1,"for semantic"],[0," \n\nnames"]],"start1":152,"start2":152,"length1":16,"length2":28}]],"length":109087,"saved":false}
{"ts":1363301260510,"patch":[[{"diffs":[[0,"emantic "],[1,"purp "],[0,"\n\nnamesp"]],"start1":165,"start2":165,"length1":16,"length2":21}]],"length":109092,"saved":false}
{"ts":1363301263451,"patch":[[{"diffs":[[0,"tic purp"],[-1," "],[1,"oses\n#"],[0,"\n\nnamesp"]],"start1":169,"start2":169,"length1":17,"length2":22}]],"length":109097,"saved":false}
{"ts":1363301265119,"patch":[[{"diffs":[[0,"rposes\n#"],[1," But I "],[0,"\n\nnamesp"]],"start1":175,"start2":175,"length1":16,"length2":23}]],"length":109104,"saved":false}
{"ts":1363301266732,"patch":[[{"diffs":[[0,"# But I "],[1,"don'"],[0,"\n\nnamesp"]],"start1":182,"start2":182,"length1":16,"length2":20}]],"length":109108,"saved":false}
{"ts":1363301269417,"patch":[[{"diffs":[[0,"t I don'"],[1,"t really know the "],[0,"\n\nnamesp"]],"start1":186,"start2":186,"length1":16,"length2":34}]],"length":109126,"saved":false}
{"ts":1363301272235,"patch":[[{"diffs":[[0,"now the "],[1,"semantic names, "],[0,"\n\nnamesp"]],"start1":204,"start2":204,"length1":16,"length2":32}]],"length":109142,"saved":false}
{"ts":1363301276044,"patch":[[{"diffs":[[0," names, "],[1,"I'm not familiar "],[0,"\n\nnamesp"]],"start1":220,"start2":220,"length1":16,"length2":33}]],"length":109159,"saved":false}
{"ts":1363301282425,"patch":[[{"diffs":[[0,"the "],[-1,"semantic names, I'm not familiar "],[1,"full na"],[0,"\n\nna"]],"start1":208,"start2":208,"length1":41,"length2":15}]],"length":109133,"saved":false}
{"ts":1363301284330,"patch":[[{"diffs":[[0," full na"],[1,"mes "],[0,"\n\nnamesp"]],"start1":211,"start2":211,"length1":16,"length2":20}]],"length":109137,"saved":false}
{"ts":1363301292052,"patch":[[{"diffs":[[0,"l names "],[1,"I'm not familiar enough with this game or "],[0,"\n\nnamesp"]],"start1":215,"start2":215,"length1":16,"length2":58}]],"length":109179,"saved":false}
{"ts":1363301295092,"patch":[[{"diffs":[[0,"game or "],[1,"codebase.\n"],[0,"\n\nnamesp"]],"start1":257,"start2":257,"length1":16,"length2":26}]],"length":109189,"saved":false}
{"ts":1363301298297,"patch":[[{"diffs":[[0,"debase.\n"],[1,"# "],[0,"\n\nnamesp"]],"start1":267,"start2":267,"length1":16,"length2":18}]],"length":109191,"saved":false}
{"ts":1363301301574,"patch":[[{"diffs":[[0,"base.\n# "],[1,"Also, WTF"],[0,"\n\nnamesp"]],"start1":269,"start2":269,"length1":16,"length2":25}]],"length":109200,"saved":false}
{"ts":1363301303318,"patch":[[{"diffs":[[0,"lso, WTF"],[1," Str"],[0,"\n\nnamesp"]],"start1":278,"start2":278,"length1":16,"length2":20}]],"length":109204,"saved":false}
{"ts":1363301305184,"patch":[[{"diffs":[[0," WTF Str"],[1,"c"],[0,"\n\nnamesp"]],"start1":282,"start2":282,"length1":16,"length2":17}]],"length":109205,"saved":false}
{"ts":1363301308804,"patch":[[{"diffs":[[0,"WTF "],[-1,"Strc"],[0,"\n\nna"]],"start1":283,"start2":283,"length1":12,"length2":8}]],"length":109201,"saved":false}
{"ts":1363301314452,"patch":[[{"diffs":[[0,"so, WTF "],[1,"abst"],[0,"\n\nnamesp"]],"start1":279,"start2":279,"length1":16,"length2":20}]],"length":109205,"saved":false}
{"ts":1363301318167,"patch":[[{"diffs":[[0,"WTF abst"],[1,"ract class Str"],[0,"\n\nnamesp"]],"start1":283,"start2":283,"length1":16,"length2":30}]],"length":109219,"saved":false}
{"ts":1363301320862,"patch":[[{"diffs":[[0,"lass Str"],[1,"uct is just wrong"],[0,"\n\nnamesp"]],"start1":297,"start2":297,"length1":16,"length2":33}]],"length":109236,"saved":false}
{"ts":1363301323524,"patch":[[{"diffs":[[0,"st wrong"],[1,"... for be"],[0,"\n\nnamesp"]],"start1":314,"start2":314,"length1":16,"length2":26}]],"length":109246,"saved":false}
{"ts":1363301326727,"patch":[[{"diffs":[[0,". for be"],[1,"ing named "],[0,"\n\nnamesp"]],"start1":324,"start2":324,"length1":16,"length2":26}]],"length":109256,"saved":false}
{"ts":1363301329500,"patch":[[{"diffs":[[0,"g named "],[1,"Struct."],[0,"\n\nnamesp"]],"start1":334,"start2":334,"length1":16,"length2":23}]],"length":109263,"saved":false}
{"ts":1363301331203,"patch":[[{"diffs":[[0," Struct."],[1,"..\n"],[0,"\n\nnamesp"]],"start1":341,"start2":341,"length1":16,"length2":19}]],"length":109266,"saved":false}
{"ts":1363301334547,"patch":[[{"diffs":[[0,"ruct...\n"],[1,"# This must b"],[0,"\n\nnamesp"]],"start1":344,"start2":344,"length1":16,"length2":29}]],"length":109279,"saved":false}
{"ts":1363301336271,"patch":[[{"diffs":[[0,"s must b"],[1,"e fize"],[0,"\n\nnamesp"]],"start1":357,"start2":357,"length1":16,"length2":22}]],"length":109285,"saved":false}
{"ts":1363301339327,"patch":[[{"diffs":[[0,"st be fi"],[-1,"ze"],[1,"x"],[0,"\n\nnamesp"]],"start1":361,"start2":361,"length1":18,"length2":17}]],"length":109284,"saved":false}
{"ts":1363301340965,"patch":[[{"diffs":[[0,"t be fix"],[1,"ed.."],[0,"\n\nnamesp"]],"start1":362,"start2":362,"length1":16,"length2":20}]],"length":109288,"saved":false}
{"ts":1363301343638,"patch":[[{"diffs":[[0," fixed.."],[1,"."],[0,"\n\nnamesp"]],"start1":366,"start2":366,"length1":16,"length2":17}]],"length":109289,"saved":false}
{"ts":1363302440090,"patch":[[{"diffs":[[0,"== NULL)"],[1," {"],[0,"\n\t\t\t$thi"]],"start1":570,"start2":570,"length1":16,"length2":18}]],"length":109291,"saved":false}
{"ts":1363302442216,"patch":[[{"diffs":[[0,"acket);\n"],[1,"            \n"],[0,"\t\treturn"]],"start1":603,"start2":603,"length1":16,"length2":29}]],"length":109304,"saved":false}
{"ts":1363302444173,"patch":[[{"diffs":[[0,"acket);\n"],[-1,"    "],[1,"\t\t}\n"],[0,"        "]],"start1":603,"start2":603,"length1":20,"length2":20}]],"length":109304,"saved":false}
{"ts":1363302449085,"patch":[[{"diffs":[[0,"eturn $this;\n\t}\n"],[1,"    \n"],[0,"\tpublic function"]],"start1":627,"start2":627,"length1":32,"length2":37}]],"length":109309,"saved":false}
{"ts":1363302453323,"patch":[[{"diffs":[[0,"nue;\n\t\t}\n\t}\n"],[1,"    \n"],[0,"\tpublic func"]],"start1":947,"start2":947,"length1":24,"length2":29}]],"length":109314,"saved":false}
{"ts":1363302457200,"patch":[[{"diffs":[[0,"ublic())"],[1," {"],[0,"\n\t\t\t\t$ob"]],"start1":865,"start2":865,"length1":16,"length2":18}]],"length":109316,"saved":false}
{"ts":1363302459847,"patch":[[{"diffs":[[0,"rgi++];\n"],[1,"                \n"],[0,"\t\t\tif ($"]],"start1":909,"start2":909,"length1":16,"length2":33}]],"length":109333,"saved":false}
{"ts":1363302463010,"patch":[[{"diffs":[[0,"+];\n"],[-1,"                "],[1,"\t\t\t}"],[0,"\n\t\t\t"]],"start1":913,"start2":913,"length1":24,"length2":12}]],"length":109321,"saved":false}
{"ts":1363302466030,"patch":[[{"diffs":[[0," $argi)\n"],[1,"            \n"],[0,"\t\t\t\tcont"]],"start1":937,"start2":937,"length1":16,"length2":29}]],"length":109334,"saved":false}
{"ts":1363302468977,"patch":[[{"diffs":[[0,"gi)\n"],[-1,"            \n"],[0,"\t\t\t\t"]],"start1":941,"start2":941,"length1":21,"length2":8}]],"length":109321,"saved":false}
{"ts":1363302470623,"patch":[[{"diffs":[[0,"= $argi)"],[1," {"],[0,"\n\t\t\t\tcon"]],"start1":936,"start2":936,"length1":16,"length2":18}]],"length":109323,"saved":false}
{"ts":1363302474836,"patch":[[{"diffs":[[0,"\t\tcontinue;\n"],[1,"\t\t\t}\n"],[0,"\t\t}\n\t}\n    \n"]],"start1":949,"start2":949,"length1":24,"length2":29}]],"length":109328,"saved":false}
{"ts":1363302479430,"patch":[[{"diffs":[[0,"];\n\t\t\t}\n"],[1,"            \n"],[0,"\t\t\tif ($"]],"start1":914,"start2":914,"length1":16,"length2":29}]],"length":109341,"saved":false}
{"ts":1363302482372,"patch":[[{"diffs":[[0,"perty);\n"],[1,"            \n"],[0,"\t\t\tif ($"]],"start1":842,"start2":842,"length1":16,"length2":29}]],"length":109354,"saved":false}
{"ts":1363302561760,"patch":[[{"diffs":[[0,"tails();\n\t}\n"],[1,"    \n"],[0,"\t// Magic Me"]],"start1":1066,"start2":1066,"length1":24,"length2":29}]],"length":109359,"saved":false}
{"ts":1363302567828,"patch":[[{"diffs":[[0,"is), $name))"],[1," {\n    \t    \n\t\t}"],[0,"\n\t\t\treturn $"]],"start1":1211,"start2":1211,"length1":24,"length2":40}]],"length":109375,"saved":false}
{"ts":1363302569825,"patch":[[{"diffs":[[0,") {\n    "],[-1,"\t "],[0,"   \n\t\t}\n"]],"start1":1222,"start2":1222,"length1":18,"length2":16}]],"length":109373,"saved":false}
{"ts":1363302571535,"patch":[[{"diffs":[[0,"e)) {\n  "],[-1,"     "],[0,"\n\t\t}\n\t\t\t"]],"start1":1220,"start2":1220,"length1":21,"length2":16}]],"length":109368,"saved":false}
{"ts":1363302573915,"patch":[[{"diffs":[[0,"ame)) {\n"],[-1,"  \n"],[0,"\t\t}\n\t\t\tr"]],"start1":1218,"start2":1218,"length1":19,"length2":16}]],"length":109365,"saved":false}
{"ts":1363302576450,"patch":[[{"diffs":[[0,"ame)) {\n"],[-1,"\t\t"],[0,"}\n\t\t\tret"]],"start1":1218,"start2":1218,"length1":18,"length2":16}]],"length":109363,"saved":false}
{"ts":1363302578248,"patch":[[{"diffs":[[0,"ame)) {\n"],[-1,"}\n"],[0,"\t\t\tretur"]],"start1":1218,"start2":1218,"length1":18,"length2":16}]],"length":109361,"saved":false}
{"ts":1363302586371,"patch":[[{"diffs":[[0,"turn;\n\t\t"],[1,"} "],[0,"else"],[1," "],[0,"\n\t\t\tretu"]],"start1":1239,"start2":1239,"length1":20,"length2":23}]],"length":109364,"saved":false}
{"ts":1363302590476,"patch":[[{"diffs":[[0,"\t} else "],[1,"{"],[0,"\n\t\t\tretu"]],"start1":1246,"start2":1246,"length1":16,"length2":17},{"diffs":[[0,">$name;\n"],[1,"\t\t}\n"],[0,"\t}\n\tpubl"]],"start1":1272,"start2":1272,"length1":16,"length2":20}]],"length":109369,"saved":false}
{"ts":1363302597394,"patch":[[{"diffs":[[0," FALSE;\n"],[1,"        \n"],[0,"\t\tif (!p"]],"start1":1167,"start2":1167,"length1":16,"length2":25}]],"length":109378,"saved":false}
{"ts":1363302603555,"patch":[[{"diffs":[[0,"is), $name))"],[1," {"],[0,"\n\t\t\t$this->$"]],"start1":1378,"start2":1378,"length1":24,"length2":26}]],"length":109380,"saved":false}
{"ts":1363302605950,"patch":[[{"diffs":[[0,"ments);\n"],[1,"\t\t}\n"],[0,"\t\treturn"]],"start1":1428,"start2":1428,"length1":16,"length2":20}]],"length":109384,"saved":false}
{"ts":1363302608651,"patch":[[{"diffs":[[0,"ments);\n\t\t}\n"],[1,"        \n"],[0,"\t\treturn $th"]],"start1":1428,"start2":1428,"length1":24,"length2":33}]],"length":109393,"saved":false}
{"ts":1363302612130,"patch":[[{"diffs":[[0,"ame;\n\t\t}\n\t}\n"],[1,"    \n"],[0,"\tpublic func"]],"start1":1284,"start2":1284,"length1":24,"length2":29}]],"length":109398,"saved":false}
{"contributors":[],"silentsave":false,"ts":1363317085444,"patch":[[{"diffs":[[0,"acket = "],[-1,"NULL"],[1,"null"],[0,")\n\t{\n\t\ti"]],"start1":535,"start2":535,"length1":20,"length2":20},{"diffs":[[0,"ket !== "],[-1,"NULL"],[1,"null"],[0,") {\n\t\t\t$"]],"start1":565,"start2":565,"length1":20,"length2":20},{"diffs":[[0,"$argv);\n"],[1,"        \n"],[0,"\t\tforeac"]],"start1":735,"start2":735,"length1":16,"length2":25},{"diffs":[[0,"y => $value)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$RP = n"]],"start1":780,"start2":780,"length1":27,"length2":25},{"diffs":[[0,"eturn = "],[-1,"FALSE"],[1,"false"],[0,";\n      "]],"start1":1167,"start2":1167,"length1":21,"length2":21},{"diffs":[[0,"eturn $this;\n\t}\n"],[1,"    \n"],[0,"\tpublic function"]],"start1":1464,"start2":1464,"length1":32,"length2":37},{"diffs":[[0,">$name);\n\t}\n"],[1,"    \n"],[0,"\tpublic func"]],"start1":1541,"start2":1541,"length1":24,"length2":29},{"diffs":[[0,">$name))"],[1," {"],[0,"\n\t\t\t$thi"]],"start1":1611,"start2":1611,"length1":16,"length2":18},{"diffs":[[0,"e = "],[-1,"NULL"],[1,"null"],[0,";\n"],[1,"\t"],[0,"\t}\n"],[1,"\t}\n    \n"],[0,"\t// "]],"start1":1636,"start2":1636,"length1":17,"length2":26},{"diffs":[[0,"ostId = "],[-1,"NULL"],[1,"null"],[0,")\n\t{\n\t\tg"]],"start1":1701,"start2":1701,"length1":20,"length2":20},{"diffs":[[0,"eturn $this;\n\t}\n"],[1,"    \n"],[0,"\tpublic function"]],"start1":1783,"start2":1783,"length1":32,"length2":37},{"diffs":[[0,"HP_EOL;\n"],[1,"        \n"],[0,"\t\tforeac"]],"start1":1980,"start2":1980,"length1":16,"length2":25},{"diffs":[[0,"perty => $value)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$pkFnkForma"]],"start1":2021,"start2":2021,"length1":35,"length2":33},{"diffs":[[0,"rtyNumber];\n"],[1,"            \n"],[0,"\t\t\tif (getty"]],"start1":2078,"start2":2078,"length1":24,"length2":37},{"diffs":[[0,"'array')"],[-1,"\n\t\t\t"],[1," "],[0,"{\n\t\t\t\t$s"]],"start1":2139,"start2":2139,"length1":20,"length2":17},{"diffs":[[0," . PHP_EOL;\n"],[1,"                \n"],[0,"\t\t\t\tforeach "]],"start1":2195,"start2":2195,"length1":24,"length2":41},{"diffs":[[0,"k => $v)"],[-1,"\n\t\t\t\t"],[1," "],[0,"{\n\t\t\t\t\ti"]],"start1":2258,"start2":2258,"length1":21,"length2":17},{"diffs":[[0," Struct)"],[-1,"\n\t\t\t\t\t"],[1," "],[0,"{\n\t\t\t\t\t\t"]],"start1":2291,"start2":2291,"length1":22,"length2":17},{"diffs":[[0,"\t\t\t}"],[-1,"\n\t\t\t\t\telse\n\t\t\t\t\t"],[1," else "],[0,"{\n\t\t"]],"start1":2376,"start2":2376,"length1":24,"length2":14},{"diffs":[[0,"\t\t\t\t}\n\t\t\t\t}\n"],[1,"                \n"],[0,"\t\t\t\t$str .= "]],"start1":2439,"start2":2439,"length1":24,"length2":41},{"diffs":[[0,"\tbreak;\n\t\t\t}"],[-1,"\n\t\t\t"],[1," "],[0,"elseif ($pro"]],"start1":2506,"start2":2506,"length1":28,"length2":25},{"diffs":[[0," 'Type')"],[-1,"\n\t\t\t"],[1," "],[0,"{\n\t\t\t\t$s"]],"start1":2539,"start2":2539,"length1":20,"length2":17},{"diffs":[[0,"OL;\n\t\t\t}"],[-1,"\n\t\t\telse\n\t\t\t"],[1," else "],[0,"{\n\t\t\t\t$s"]],"start1":2653,"start2":2653,"length1":28,"length2":22},{"diffs":[[0,"P_EOL;\n\t\t\t}\n\t\t}\n"],[1,"        \n"],[0,"\t\treturn \"{$str}"]],"start1":2745,"start2":2745,"length1":32,"length2":41},{"diffs":[[0,"PHP_EOL;\n\t}\n"],[1,"    \n"],[0,"\tpublic func"]],"start1":2797,"start2":2797,"length1":24,"length2":29},{"diffs":[[0,"perty => $value)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$this->$pro"]],"start1":2905,"start2":2905,"length1":35,"length2":33},{"diffs":[[0,"r = -1;\n"],[1,"        \n"],[0,"\t\tforeac"]],"start1":3079,"start2":3079,"length1":16,"length2":25},{"diffs":[[0,"y => $value)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$pkFnkF"]],"start1":3124,"start2":3124,"length1":27,"length2":25},{"diffs":[[0,"Number];\n\t\t\t"],[1,"\n            "],[0,"if ($pkFnkFo"]],"start1":3180,"start2":3180,"length1":24,"length2":37},{"diffs":[[0," == 'x')"],[1," {"],[0,"\n\t\t\t\t$re"]],"start1":3221,"start2":3221,"length1":16,"length2":18},{"diffs":[[0,", 0); # "],[-1,"NULL"],[1,"null"],[0," & 0 are"]],"start1":3255,"start2":3255,"length1":20,"length2":20},{"diffs":[[0,"00), so "],[-1,"NULL"],[1,"null"],[0," == 0.\n\t"]],"start1":3322,"start2":3322,"length1":20,"length2":20},{"diffs":[[0,"= 0.\n\t\t\t"],[1,"} "],[0,"else"],[-1," "],[0,"if (is_a"]],"start1":3336,"start2":3336,"length1":21,"length2":22},{"diffs":[[0,"Format))"],[-1,"\n\t\t\t"],[1," "],[0,"{\n\t\t\t\tli"]],"start1":3369,"start2":3369,"length1":20,"length2":17},{"diffs":[[0,"Format;\n"],[1,"                \n"],[0,"\t\t\t\tif ("]],"start1":3415,"start2":3415,"length1":16,"length2":33},{"diffs":[[0,"lements)"],[1," {"],[0,"\n\t\t\t\t\t$j"]],"start1":3473,"start2":3473,"length1":16,"length2":18},{"diffs":[[0,"ements;\n"],[1,"\t\t\t\t}\n                \n"],[0,"\t\t\t\tfor "]],"start1":3497,"start2":3497,"length1":16,"length2":39},{"diffs":[[0,"i, --$j)"],[-1,"\n\t\t\t\t"],[1," "],[0,"{\n\t\t\t\t\tv"]],"start1":3557,"start2":3557,"length1":21,"length2":17},{"diffs":[[0,"$i]);\n\t\t\t\t}\n"],[1,"                \n"],[0,"\t\t\t\tif ($j >"]],"start1":3664,"start2":3664,"length1":24,"length2":41},{"diffs":[[0,"($j > 0)"],[-1,";"],[1," {"],[0,"\n\t\t\t\t\t$r"]],"start1":3700,"start2":3700,"length1":17,"length2":18},{"diffs":[[0,"\n\t\t\t"],[1,"\t"],[0,"}\n\t\t\t"],[1,"} "],[0,"else"],[1," {"],[0,"\n\t\t\t"]],"start1":3787,"start2":3787,"length1":17,"length2":22},{"diffs":[[0," $value);\n\t\t"],[-1,"}"],[1,"\t}\n\t\t}\n        "],[0,"\n\t\treturn $r"]],"start1":3839,"start2":3839,"length1":25,"length2":39},{"diffs":[[0,"urn $return;\n\t}\n"],[1,"    \n"],[0,"\tpublic function"]],"start1":3872,"start2":3872,"length1":32,"length2":37},{"diffs":[[0," = array();\n"],[1,"        \n"],[0,"\t\tforeach (e"]],"start1":3942,"start2":3942,"length1":24,"length2":33},{"diffs":[[0,"element)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\tfor"]],"start1":4006,"start2":4006,"length1":19,"length2":17},{"diffs":[[0,"+$i) {}\n"],[1,"            \n"],[0,"\t\t\t$data"]],"start1":4060,"start2":4060,"length1":16,"length2":29},{"diffs":[[0,"taType;\n\t\t}\n"],[1,"        \n"],[0,"\t\treturn $re"]],"start1":4185,"start2":4185,"length1":24,"length2":33},{"diffs":[[0,"$return;\n\t}\n"],[1,"    \n"],[0,"\tpublic func"]],"start1":4215,"start2":4215,"length1":24,"length2":29},{"diffs":[[0," = array();\n"],[-1,"\t\t"],[1,"\n        "],[0,"for ($i = 0,"]],"start1":4353,"start2":4353,"length1":26,"length2":33},{"diffs":[[0,"numbers."],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t# I"]],"start1":4482,"start2":4482,"length1":19,"length2":17},{"diffs":[[0,"at[$j]))"],[1," {"],[0,"\n\t\t\t\t$el"]],"start1":4614,"start2":4614,"length1":16,"length2":18},{"diffs":[[0,"\n\t\t\t"],[1,"} "],[0,"else"],[-1,"\n\t\t\t"],[1," "],[0,"{\n\t\t"]],"start1":4655,"start2":4655,"length1":16,"length2":15},{"diffs":[[0,"at{$j}))"],[1," {"],[0,"\n\t\t\t\t\t++"]],"start1":4717,"start2":4717,"length1":16,"length2":18},{"diffs":[[0,"element."],[1,"\n\t\t\t\t}"],[0,"\n\n\t\t\t\t$n"]],"start1":4780,"start2":4780,"length1":16,"length2":22},{"diffs":[[0," == 'A')"],[1," {"],[0," # In th"]],"start1":4892,"start2":4892,"length1":16,"length2":18},{"diffs":[[0,"er;\n\t\t\t\t"],[1,"} "],[0,"else"],[1," {"],[0," # In th"]],"start1":4995,"start2":4995,"length1":20,"length2":24},{"diffs":[[0,"number);"],[1,"\n\t\t\t\t}"],[0,"\n\n\t\t\t\t$i"]],"start1":5093,"start2":5093,"length1":16,"length2":22},{"diffs":[[0,"t.\n\t\t\t}\n\t\t}\n"],[1,"        \n"],[0,"\t\treturn $el"]],"start1":5172,"start2":5172,"length1":24,"length2":33},{"diffs":[[0,"$Zero = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0"]],"start1":8904,"start2":8904,"length1":20,"length2":20},{"diffs":[[0," $Sp0 = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0"]],"start1":9061,"start2":9061,"length1":20,"length2":20},{"diffs":[[0,"ted $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t# 0\n\tpro"]],"start1":28059,"start2":28059,"length1":28,"length2":28},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $UCID"]],"start1":28086,"start2":28086,"length1":36,"length2":36},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $UCID"]],"start1":29283,"start2":29283,"length1":36,"length2":36},{"diffs":[[0,"rotected $Sp2 = "],[-1,"NULL"],[1,"null"],[0,";\n\tprotected $Sp"]],"start1":29431,"start2":29431,"length1":36,"length2":36},{"diffs":[[0,"rotected $Sp3 = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $Msg;"]],"start1":29455,"start2":29455,"length1":36,"length2":36},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $UCID"]],"start1":29835,"start2":29835,"length1":36,"length2":36},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $Msg;"]],"start1":30415,"start2":30415,"length1":36,"length2":36},{"diffs":[[0,"g) > 63)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\tfor"]],"start1":30532,"start2":30532,"length1":19,"length2":17},{"diffs":[[0,">Msg, 63, \"\\n\", "],[-1,"TRUE"],[1,"true"],[0,")) as $Msg)\n\t\t\t\t"]],"start1":30583,"start2":30583,"length1":36,"length2":36},{"diffs":[[0," true)) as $Msg)"],[1," {"],[0,"\n\t\t\t\t$this->Msg("]],"start1":30598,"start2":30598,"length1":32,"length2":34},{"diffs":[[0,"Send();\n"],[1,"\t\t\t}\n            \n"],[0,"\t\t\tretur"]],"start1":30639,"start2":30639,"length1":16,"length2":34},{"diffs":[[0,"return;\n\t\t}\n"],[1,"        \n"],[0,"\t\treturn par"]],"start1":30668,"start2":30668,"length1":24,"length2":33},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $Msg;"]],"start1":31031,"start2":31031,"length1":36,"length2":36},{"diffs":[[0,"g) > 95)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\tfor"]],"start1":31148,"start2":31148,"length1":19,"length2":17},{"diffs":[[0,">Msg, 95, \"\\n\", "],[-1,"TRUE"],[1,"true"],[0,")) as $Msg)\n\t\t\t\t"]],"start1":31199,"start2":31199,"length1":36,"length2":36},{"diffs":[[0," true)) as $Msg)"],[1," {"],[0,"\n\t\t\t\t$this->Msg("]],"start1":31214,"start2":31214,"length1":32,"length2":34},{"diffs":[[0,"Msg)->Send();\n\t\t"],[-1,"}"],[1,"\t}\n\t\t}\n        "],[0,"\n\t\treturn parent"]],"start1":31249,"start2":31249,"length1":33,"length2":47},{"diffs":[[0,"his->Msg) > 127)"],[-1,"\n\t\t"],[0,"{\n\t\t\tforeach(exp"]],"start1":31783,"start2":31783,"length1":35,"length2":32},{"diffs":[[0," 127, \"\\n\", "],[-1,"TRUE"],[1,"true"],[0,")) as $Msg)\n"]],"start1":31846,"start2":31846,"length1":28,"length2":28},{"diffs":[[0,"as $Msg)"],[1," {"],[0,"\n\t\t\t\t$th"]],"start1":31865,"start2":31865,"length1":16,"length2":18},{"diffs":[[0,"Msg)->Send();\n\t\t"],[-1,"}"],[1,"\t}\n\t\t}\n        "],[0,"\n\t\treturn parent"]],"start1":31892,"start2":31892,"length1":33,"length2":47},{"diffs":[[0,"Sound = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# s"]],"start1":32359,"start2":32359,"length1":20,"length2":20},{"diffs":[[0,"rotected $Sp2 = "],[-1,"NULL"],[1,"null"],[0,";\n\tprotected $Sp"]],"start1":32556,"start2":32556,"length1":36,"length2":36},{"diffs":[[0,"rotected $Sp3 = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $Text"]],"start1":32580,"start2":32580,"length1":36,"length2":36},{"diffs":[[0,") > 127)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\tfor"]],"start1":32731,"start2":32731,"length1":19,"length2":17},{"diffs":[[0,", \"\\n\", "],[-1,"TRUE"],[1,"true"],[0,")) as $T"]],"start1":32792,"start2":32792,"length1":20,"length2":20},{"diffs":[[0,"s $Text)"],[1," {"],[0,"\n\t\t\t\t$th"]],"start1":32808,"start2":32808,"length1":16,"length2":18},{"diffs":[[0,"nd();\n\t\t"],[-1,"}"],[1,"\t}\n\t\t}\n        "],[0,"\n\t\tretur"]],"start1":32845,"start2":32845,"length1":17,"length2":31},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $Char"]],"start1":33862,"start2":33862,"length1":36,"length2":36},{"diffs":[[0,"d $Spare2 = "],[-1,"NULL"],[1,"null"],[0,";\n\tprotected"]],"start1":33982,"start2":33982,"length1":28,"length2":28},{"diffs":[[0,"pare3 = "],[-1,"NULL"],[1,"null"],[0,";\n}; fun"]],"start1":34013,"start2":34013,"length1":20,"length2":20},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $Host"]],"start1":34506,"start2":34506,"length1":36,"length2":36},{"diffs":[[0," $Sp1 = "],[-1,"NULL"],[1,"null"],[0,";\n\tprote"]],"start1":34582,"start2":34582,"length1":20,"length2":20},{"diffs":[[0," $Sp2 = "],[-1,"NULL"],[1,"null"],[0,";\n\tprote"]],"start1":34606,"start2":34606,"length1":20,"length2":20},{"diffs":[[0," $Sp3 = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpubl"]],"start1":34630,"start2":34630,"length1":20,"length2":20},{"diffs":[[0,"otected $Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpublic $UCID"]],"start1":37083,"start2":37083,"length1":36,"length2":36},{"diffs":[[0,"I = "],[-1,"TRUE"],[1,"true"],[0,";\t\t\t"]],"start1":39196,"start2":39196,"length1":12,"length2":12},{"diffs":[[0,"$Zero = "],[-1,"NULL"],[1,"null"],[0,";\n\n\tpubl"]],"start1":39270,"start2":39270,"length1":20,"length2":20},{"diffs":[[0,"\tpublic $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0 unless "]],"start1":40505,"start2":40505,"length1":36,"length2":36},{"diffs":[[0,"\tpublic $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":41592,"start2":41592,"length1":36,"length2":36},{"diffs":[[0," 4; ++$Tyre)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$pkClas"]],"start1":43124,"start2":43124,"length1":27,"length2":25},{"diffs":[[0,"perty => $value)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$this->$pro"]],"start1":43258,"start2":43258,"length1":35,"length2":33},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":44218,"start2":44218,"length1":36,"length2":36},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":44560,"start2":44560,"length1":36,"length2":36},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":44856,"start2":44856,"length1":36,"length2":36},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":45859,"start2":45859,"length1":36,"length2":36},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":46498,"start2":46498,"length1":36,"length2":36},{"diffs":[[0,"++$Tyre)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$Pr"]],"start1":46980,"start2":46980,"length1":19,"length2":17},{"diffs":[[0,"acket);\n"],[-1,"\n"],[0,"\t\t$pkCla"]],"start1":53660,"start2":53660,"length1":17,"length2":16},{"diffs":[[0,"rray();\n"],[1,"        \n"],[0,"\t\tfor ($"]],"start1":53690,"start2":53690,"length1":16,"length2":25},{"diffs":[[0," ++$Pos)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\tif "]],"start1":53735,"start2":53735,"length1":19,"length2":17},{"diffs":[[0,"\"] != 0)"],[1," {"],[0,"\n\t\t\t\t$pk"]],"start1":53773,"start2":53773,"length1":16,"length2":18},{"diffs":[[0,"ID{$Pos}\"];\n"],[1,"\t\t\t}\n"],[0,"\t\t\tunset($pk"]],"start1":53825,"start2":53825,"length1":24,"length2":29},{"diffs":[[0,">NumP; $i++)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$this->"]],"start1":64812,"start2":64812,"length1":27,"length2":25},{"diffs":[[0,">NumC; $i++)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$this->"]],"start1":67367,"start2":67367,"length1":27,"length2":25},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":71927,"start2":71927,"length1":36,"length2":36},{"diffs":[[0,"otected $ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0\n\tpublic"]],"start1":73326,"start2":73326,"length1":36,"length2":36},{"diffs":[[0,"$ReqI = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# 0"]],"start1":74696,"start2":74696,"length1":20,"length2":20},{"diffs":[[0,"o = '';\n"],[1,"        \n"],[0,"\t\tforeac"]],"start1":75115,"start2":75115,"length1":16,"length2":25},{"diffs":[[0,"ectInfo)"],[1," {"],[0,"\n\t\t\t$Inf"]],"start1":75162,"start2":75162,"length1":16,"length2":18},{"diffs":[[0,">pack();"],[1,"\n\t\t}"],[0,"\n\n\t\tretu"]],"start1":75197,"start2":75197,"length1":16,"length2":20},{"diffs":[[0,">NumO; $i++)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$this->"]],"start1":75344,"start2":75344,"length1":27,"length2":25},{"diffs":[[0,"$Inst = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# s"]],"start1":92022,"start2":92022,"length1":20,"length2":20},{"diffs":[[0,"Style = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t\t# b"]],"start1":92080,"start2":92080,"length1":20,"length2":20},{"diffs":[[0,"n = "],[-1,"NULL"],[1,"null"],[0,";\t\t\t"]],"start1":92144,"start2":92144,"length1":12,"length2":12},{"diffs":[[0,") > 239)"],[-1,""],[0,""],[1," {"],[0,"\n\t\t\t$thi"]],"start1":92470,"start2":92470,"length1":16,"length2":18},{"diffs":[[0,", 239);\n"],[1,"\t\t}\n        \n"],[0,"\t\treturn"]],"start1":92518,"start2":92518,"length1":16,"length2":29},{"diffs":[[0,"perty => $value)"],[-1,""],[0,""],[1," {"],[0,"\n\t\t\t$this->$prop"]],"start1":99048,"start2":99048,"length1":32,"length2":34},{"diffs":[[0,"operty = $value;"],[1,"\n\t\t}"],[0,"\n\n\t\treturn $this"]],"start1":99080,"start2":99080,"length1":32,"length2":36},{"diffs":[[0," $value)"],[-1,""],[0,""],[1," {"],[0,"\n\t\t\t$thi"]],"start1":101312,"start2":101312,"length1":16,"length2":18},{"diffs":[[0," $value;"],[1,"\n\t\t}"],[0,"\n\n\t\tretu"]],"start1":101344,"start2":101344,"length1":16,"length2":20},{"diffs":[[0,"s; $i++)"],[-1,"\n\t\t"],[1," "],[0,"{\n\t\t\t$th"]],"start1":106254,"start2":106254,"length1":19,"length2":17},{"diffs":[[0,"> $Name)"],[1," {"],[0,"\n\t$TYPEs"]],"start1":109618,"start2":109618,"length1":16,"length2":18},{"diffs":[[0," 2, 1);\n"],[1,"}\n"],[0,"$TYPEs ="]],"start1":109671,"start2":109671,"length1":16,"length2":18}]],"length":109745,"saved":false}
{"ts":1363317135575,"patch":[[{"diffs":[[0,"xed...\n\n"],[1,"# PSR?\n# Major Clusterfuck, Must Fix /w proper names/rearrangement.\n\n"],[0,"namespac"]],"start1":369,"start2":369,"length1":16,"length2":85}]],"length":109814,"saved":false}

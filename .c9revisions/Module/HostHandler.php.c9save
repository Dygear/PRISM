{"ts":1363202146766,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * PHPInSimMod - Connections Module\n * @package PRISM\n * @subpackage Connections\n*/\n\nrequire_once(ROOTPATH . '/modules/prism_sectionhandler.php');\n\ndefine('CONNTYPE_HOST',\t\t\t0);\t\t\t# object is connected directly to a host\ndefine('CONNTYPE_RELAY',\t\t1);\t\t\t# object is connected to host via relay\n\ndefine('KEEPALIVE_TIME',\t\t29);\t\t# the time in seconds of write inactivity, after which we'll send a ping\ndefine('HOST_TIMEOUT', \t\t\t90);\t\t# the time in seconds of silence after we will disconnect from a host\ndefine('HOST_RECONN_TIMEOUT',\t3);\ndefine('HOST_RECONN_TRIES',\t\t5);\n\ndefine('CONN_TIMEOUT',\t\t\t10);\t\t# host long may a connection attempt last\n\ndefine('CONN_NOTCONNECTED',\t\t0);\t\t\t# not connected to the host\ndefine('CONN_CONNECTING',\t\t1);\t\t\t# in the process of connecting to the host\ndefine('CONN_CONNECTED',\t\t2);\t\t\t# connected to a host\ndefine('CONN_VERIFIED',\t\t\t3);\t\t\t# it has been verified that we have a working insim connection\n\ndefine('SOCKTYPE_BEST',\t\t\t0);\ndefine('SOCKTYPE_TCP',\t\t\t1);\ndefine('SOCKTYPE_UDP',\t\t\t2);\n\ndefine('STREAM_READ_BYTES',\t\t8192);\ndefine('STREAM_WRITE_BYTES',\t1400);\n\n/**\n * HostHandler public functions :\n * ->initialise()\t\t\t\t\t\t\t\t\t# (re)loads the config files and (re)connects to the host(s)\n * ->sendPacket($packetClass, $hostId = NULL)\t\t# send a packet to either the last incoming host, or to $hostID\n * ->getHostsInfo()\t\t\t\t\t\t\t\t\t# retreive an array of information about all the hosts\n * ->getHostById(string $hostId)\t\t\t\t\t# get a host object by its hostID\n * ->getHostsByIp(string $ip)\t\t\t\t\t\t# get all hosts with a certain IP\n**/\nclass HostHandler extends SectionHandler\n{\n\tprivate $connvars\t\t= array();\n\tprivate $hosts\t\t\t= array();\t\t\t# Stores references to the hosts we're connected to\n\n\tpublic $state\t\t\t= array();\n\n\tpublic $curHostID\t\t= NULL;\t\t\t\t# Contains the current HostID we are talking to.\n\n\tpublic function &getCurrentHost()\n\t{\n\t\treturn $this->curHostID;\n\t}\n\n\tpublic function __construct()\n\t{\n\t\t$this->iniFile = 'hosts.ini';\n\t}\n\t\n\tpublic function initialise()\n\t{\n\t\tglobal $PRISM;\n\t\t\n\t\tif ($this->loadIniFile($this->connvars))\n\t\t{\n\t\t\tforeach ($this->connvars as $hostID => $v)\n\t\t\t{\n\t\t\t\tif (!is_array($v))\n\t\t\t\t{\n\t\t\t\t\tconsole('Section error in '.$this->iniFile.' file!');\n\t\t\t\t\treturn FALSE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ($PRISM->config->cvars['debugMode'] & PRISM_DEBUG_CORE)\n\t\t\t\tconsole('Loaded '.$this->iniFile);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t# We ask the client to manually input the connection details here.\n\t\t\trequire_once(ROOTPATH . '/modules/prism_interactive.php');\n\t\t\tInteractive::queryHosts($this->connvars);\n\t\t\t\n\t\t\t# Then build a connections.ini file based on these details provided.\n\t\t\tif ($this->createIniFile('InSim Connection Hosts', $this->connvars))\n\t\t\t\tconsole('Generated config/'.$this->iniFile);\n\t\t}\n\n\t\t// Cleanup any existing connections (in case of re-initialise)\n\t\t$this->hosts = array();\n\n\t\t// Populate $this->hosts array from the connections.ini variables we've just read\n\t\t$this->populateHostsFromVars();\n\t\t\n\t\treturn true;\n\t}\n\n\tprivate function populateHostsFromVars()\n\t{\n\t\tglobal $PRISM;\n\t\t\n\t\t$udpPortBuf = array();\t\t// Duplicate udpPort (NLP/MCI or OutGauge port) value check array.\n\t\t\n\t\tforeach ($this->connvars as $hostID => $v)\n\t\t{\n\t\t\tif (isset($v['useRelay']) && $v['useRelay'] > 0)\n\t\t\t{\n\t\t\t\t// This is a Relay connection\n\t\t\t\t$hostName\t\t= isset($v['hostname']) ? substr($v['hostname'], 0, 31) : '';\n\t\t\t\t$adminPass\t\t= isset($v['adminPass']) ? substr($v['adminPass'], 0, 15) : '';\n\t\t\t\t$specPass\t\t= isset($v['specPass']) ? substr($v['specPass'], 0, 15) : '';\n\t\t\t\t$prefix\t\t\t= isset($v['prefix']) ? substr($v['prefix'], 0, 1) : '';\n\n\t\t\t\t// Some value checking - guess we should output some user notices here too if things go wrong.\n\t\t\t\tif ($hostName == '')\n\t\t\t\t\tcontinue;\n\n\t\t\t\t$icVars = array (\n\t\t\t\t\t'connType'\t\t=> CONNTYPE_RELAY, \n\t\t\t\t\t'socketType'\t=> SOCKTYPE_TCP,\n\t\t\t\t\t'id' \t\t\t=> $hostID,\n\t\t\t\t\t'ip'\t\t\t=> $PRISM->config->cvars['relayIP'],\n\t\t\t\t\t'port'\t\t\t=> $PRISM->config->cvars['relayPort'],\n\t\t\t\t\t'hostName'\t\t=> $hostName,\n\t\t\t\t\t'adminPass'\t\t=> $adminPass,\n\t\t\t\t\t'specPass'\t\t=> $specPass,\n\t\t\t\t\t'prefix'\t\t=> $prefix,\n\t\t\t\t\t'pps'\t\t\t=> $PRISM->config->cvars['relayPPS'],\n\t\t\t\t);\t\t\t\t\n\t\t\t\t$ic = new InsimConnection($icVars);\n\t\t\t\t\n\t\t\t\t$this->hosts[$hostID] = $ic;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// This is a direct to host connection\n\t\t\t\t$ip\t\t\t\t= isset($v['ip']) ? $v['ip'] : '';\n\t\t\t\t$port\t\t\t= isset($v['port']) ? (int) $v['port'] : 0;\n\t\t\t\t$udpPort\t\t= isset($v['udpPort']) ? (int) $v['udpPort'] : 0;\n\t\t\t\t$outgaugePort   = isset($v['outgaugePort']) ? (int) $v['outgaugePort'] : 0;\n\t\t\t\t$flags\t\t\t= isset($v['flags']) ? (int) $v['flags'] : 72;\n\t\t\t\t$pps\t\t\t= isset($v['pps']) ? (int) $v['pps'] : 3;\n\t\t\t\t$adminPass\t\t= isset($v['password']) ? substr($v['password'], 0, 15) : '';\n\t\t\t\t$socketType\t\t= isset($v['socketType']) ? (int) $v['socketType'] : SOCKTYPE_TCP;\n\t\t\t\t$prefix\t\t\t= isset($v['prefix']) ? substr($v['prefix'], 0, 1) : '';\n\t\t\t\t\n\t\t\t\t// Some value checking\n\t\t\t\tif ($port < 1 || $port > 65535)\n\t\t\t\t{\n\t\t\t\t\tconsole('Invalid port '.$port.' for '.$hostID);\n\t\t\t\t\tconsole('Host '.$hostID.' will be excluded.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ($udpPort < 0 || $udpPort > 65535)\n\t\t\t\t{\n\t\t\t\t\tconsole('Invalid UDP port '.$udpPort.' for '.$hostID);\n\t\t\t\t\tconsole('Falling back to TCP.');\n\t\t\t\t\t$udpPort = 0;\n\t\t\t\t}\n\t\t\t\tif ($outgaugePort < 0 || $outgaugePort > 65535)\n\t\t\t\t{\n\t\t\t\t\tconsole('Invalid OutGauge port '.$outgaugePort.' for '.$hostID);\n\t\t\t\t\tconsole('Outgauge will not work for host '.$hostID.'.');\n\t\t\t\t\t$outgaugePort = 0;\n\t\t\t\t}\n\t\t\t\tif ($pps < 1 || $pps > 100)\n\t\t\t\t{\n\t\t\t\t\tconsole('Invalid pps '.$pps.' for '.$hostID);\n\t\t\t\t\tconsole('Host '.$hostID.' will be excluded.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ($socketType != SOCKTYPE_TCP && $socketType != SOCKTYPE_UDP)\n\t\t\t\t{\n\t\t\t\t\tconsole('Invalid socket type set for '.$ip.':'.$port);\n\t\t\t\t\tconsole('Host '.$hostID.' will be excluded.');\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Create new ic object\n\t\t\t\t$icVars = array (\n\t\t\t\t\t'connType'\t\t=> CONNTYPE_HOST, \n\t\t\t\t\t'socketType'\t=> $socketType,\n\t\t\t\t\t'id'\t\t\t=> $hostID,\n\t\t\t\t\t'ip'\t\t\t=> $ip,\n\t\t\t\t\t'port'\t\t\t=> $port,\n\t\t\t\t\t'udpPort'\t\t=> $udpPort,\n\t\t\t\t\t'outgaugePort'\t=> $outgaugePort,\n\t\t\t\t\t'flags'\t\t\t=> $flags,\n\t\t\t\t\t'pps'\t\t\t=> $pps,\n\t\t\t\t\t'adminPass'\t\t=> $adminPass,\n\t\t\t\t\t'prefix'\t\t=> $prefix,\n\t\t\t\t);\n\t\t\t\t$ic = new InsimConnection($icVars);\n\n\t\t\t\tif ($ic->getUdpPort() > 0)\n\t\t\t\t{\n\t\t\t\t\tif (in_array($ic->getUdpPort(), $udpPortBuf))\n\t\t\t\t\t{\n\t\t\t\t\t\tconsole('Duplicate udpPort value found! Every host must have its own unique udpPort. Not using additional port for this host.');\n\t\t\t\t\t\t$ic->setUdpPort(0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$udpPortBuf[] = $ic->getUdpPort();\n\t\t\t\t\t\tif (!$ic->createMCISocket())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconsole('Host '.$hostID.' will be excluded.');\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif ($ic->getOutgaugePort() > 0)\n\t\t\t\t{\n\t\t\t\t\tif (in_array($ic->getOutgaugePort(), $udpPortBuf))\n\t\t\t\t\t{\n\t\t\t\t\t\tconsole('Duplicate outgaugePort value found! Every host must have its own unique outgaugePort. Not listening for OutGauge packets from host '.$hostID.'.');\n\t\t\t\t\t\t$ic->setOutgaugePort(0);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$udpPortBuf[] = $ic->getOutgaugePort();\n\t\t\t\t\t\tif (!$ic->createOutgaugeSocket())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconsole('Not listening for OutGauge packets from host '.$hostID.'.');\n\t\t\t\t\t\t\t$ic->setOutgaugePort(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$this->hosts[$hostID] = $ic;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic function getSelectableSockets(array &$sockReads, array &$sockWrites)\n\t{\n\t\tforeach ($this->hosts as $hostID => $host)\n\t\t{\n\t\t\tif ($host->getConnStatus() >= CONN_CONNECTED)\n\t\t\t{\n\t\t\t\t\t$sockReads[] = $host->getSocket();\n\t\t\t\t\t\n\t\t\t\t\t// If the host is lagged, we must check to see when we can write again\n\t\t\t\t\tif ($host->getSendQLen() > 0)\n\t\t\t\t\t\t$sockWrites[] = $host->getSocket();\n\t\t\t}\n\t\t\telse if ($host->getConnStatus() == CONN_CONNECTING)\n\t\t\t{\n\t\t\t\t$sockWrites[] = $host->getSocket();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Should we try to connect?\n\t\t\t\tif ($host->getMustConnect() > -1 && $host->getMustConnect() < time())\n\t\t\t\t{\n\t\t\t\t\tif ($host->connect()) {\n\t\t\t\t\t\tif ($host->getSocketType() == SOCKTYPE_TCP)\n\t\t\t\t\t\t\t$sockWrites[] = $this->hosts[$hostID]->getSocket();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t$sockReads[] = $this->hosts[$hostID]->getSocket();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Treat secundary socketMCI separately. This socket is always open.\n\t\t\tif ($host->getUdpPort() > 0 && is_resource($host->getSocketMCI()))\n\t\t\t\t$sockReads[] = $host->getSocketMCI();\n\t\t\t\n\t\t\t// Treat socketOutgauge separately. This socket is always open.\n\t\t\tif ($host->getOutgaugePort() > 0 && is_resource($host->getSocketOutgauge()))\n\t\t\t\t$sockReads[] = $host->getSocketOutgauge();\n\t\t}\n\t}\n\t\n\tpublic function checkTraffic(array &$sockReads, array &$sockWrites)\n\t{\n\t\tglobal $PRISM;\n\t\t\n\t\t$activity = 0;\n\t\t\n\t\t// Host traffic\n\t\tforeach($this->hosts as $hostID => $host)\n\t\t{\n\t\t\t// Finalise a tcp connection?\n\t\t\tif ($host->getConnStatus() == CONN_CONNECTING && \n\t\t\t\tin_array($host->getSocket(), $sockWrites))\n\t\t\t{\n\t\t\t\t$activity++;\n\t\t\t\t\n\t\t\t\t// Check if remote replied negatively\n\t\t\t\t# Error suppressed, because of the underlying CRT (C Run Time) producing an error on Windows.\n\t\t\t\t$r = array($host->getSocket());\n\t\t\t\t$w = $e = array();\n\t\t\t\t$nr = @stream_select($r, $w, $e, 0);\n\t\t\t\tif ($nr > 0)\n\t\t\t\t{\n\t\t\t\t\t// Experimentation showed that if something happened on this socket at this point,\n\t\t\t\t\t// it is always an indication that the connection failed. We close this socket now.\n\t\t\t\t\t$host->close();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// The socket has become available for writing\n\t\t\t\t\t$host->connectFinish();\n\t\t\t\t}\n\t\t\t\tunset($nr, $r, $w, $e);\n\t\t\t}\n\n\t\t\t// Recover a lagged host?\n\t\t\tif ($host->getConnStatus() >= CONN_CONNECTED && \n\t\t\t\t$host->getSendQLen() > 0 &&\n\t\t\t\tin_array($host->getSocket(), $sockWrites))\n\t\t\t{\n\t\t\t\t$activity++;\n\t\t\t\t\n\t\t\t\t// Flush the sendQ and handle possible overload again\n\t\t\t\t$host->flushSendQ();\n\t\t\t}\n\n\t\t\t// Did the host send us something?\n\t\t\tif (in_array($host->getSocket(), $sockReads))\n\t\t\t{\n\t\t\t\t$activity++;\n\t\t\t\t$data = $packet = '';\n\t\t\t\t\n\t\t\t\t// Incoming traffic from a host\n\t\t\t\t$peerInfo = '';\n\t\t\t\t$data = $host->read($peerInfo);\n\t\t\t\t\n\t\t\t\tif (!$data)\n\t\t\t\t{\n\t\t\t\t\t$host->close();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ($host->getSocketType() == SOCKTYPE_UDP)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Check that this insim packet came from the IP we connected to\n\t\t\t\t\t\t// UDP packet can be sent straight to packet parser\n\t\t\t\t\t\tif ($host->getConnectIP().':'.$host->getPort() == $peerInfo)\n\t\t\t\t\t\t\t$this->handlePacket($data, $hostID);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// TCP Stream requires buffering\n\t\t\t\t\t\t$host->appendToBuffer($data);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t//console('findloop');\n\t\t\t\t\t\t\t$packet = $host->findNextPacket();\n\t\t\t\t\t\t\tif (!$packet)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// Handle the packet here\n\t\t\t\t\t\t\t$this->handlePacket($packet, $hostID);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Did the host send us something on our separate udp port (if we have that active to begin with)?\n\t\t\tif ($host->getUdpPort() > 0 && in_array($host->getSocketMCI(), $sockReads))\n\t\t\t{\n\t\t\t\t$activity++;\n\t\t\t\t\n\t\t\t\t$peerInfo = '';\n\t\t\t\t$data = $host->readMCI($peerInfo);\n\t\t\t\t$exp = explode(':', $peerInfo);\n\t\t\t\tconsole('received '.strlen($data).' bytes on second socket');\n\n\t\t\t\t// Only process the packet if it came from the host's IP.\n\t\t\t\tif ($host->getConnectIP() == $exp[0])\n\t\t\t\t\t$this->handlePacket($data, $hostID);\n\t\t\t}\n\n\t\t\t// Did the host send us something on our outgauge socket? (if we have that active to begin with)\n\t\t\tif ($host->getOutgaugePort() > 0 && in_array($host->getSocketOutgauge(), $sockReads))\n\t\t\t{\n\t\t\t\t$activity++;\n\t\t\t\t\n\t\t\t\t$peerInfo = '';\n\t\t\t\t$data = $host->readOutgauge($peerInfo);\n\t\t\t\t$exp = explode(':', $peerInfo);\n\t\t\t\t//console('received '.strlen($data).' bytes on outgauge socket');\n\n\t\t\t\t// Only process the packet if it came from the host's IP.\n\t\t\t\tif ($host->getConnectIP() == $exp[0])\n\t\t\t\t{\n\t\t\t\t    //echo \"outgauge packet...\\n\";\n\t\t\t\t\t$this->handleOutgaugePacket($data, $hostID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $activity;\n\t}\n\t\n\tpublic function maintenance()\n\t{\n\t\t// InSim Connection maintenance\n\t\t$c = 0;\n\t\t$d = 0;\n\t\tforeach($this->hosts as $hostID => $host)\n\t\t{\n\t\t\t$c++;\n\t\t\tif ($host->getConnStatus() == CONN_NOTCONNECTED)\n\t\t\t{\n\t\t\t\tif ($host->getMustConnect() == -1)\n\t\t\t\t\t$d++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ($host->getConnStatus() == CONN_CONNECTING)\n\t\t\t{\n\t\t\t\t// Check to see if a connection attempt is going to time out.\n\t\t\t\tif ($host->getConnTime() < time() - CONN_TIMEOUT)\n\t\t\t\t{\n\t\t\t\t\tconsole('Connection attempt to '.$host->getIP().':'.$host->getPort().' timed out');\n\t\t\t\t\t$host->close();\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t// Does the connection appear to be dead? (LFS host not sending anything for more than HOST_TIMEOUT seconds\n\t\t\tif ($host->getLastReadTime() < time () - HOST_TIMEOUT)\n\t\t\t{\n\t\t\t\tconsole('Host '.$host->getIP().':'.$host->getPort().' timed out');\n\t\t\t\t$host->close();\n\t\t\t}\n\t\t\t\n\t\t\t// Do we need to keep the connection alive with a ping?\n\t\t\tif ($host->getLastWriteTime() < time () - KEEPALIVE_TIME)\n\t\t\t{\n\t\t\t\t$ISP = new IS_TINY();\n\t\t\t\t$ISP->SubT = TINY_NONE;\n\t\t\t\t$host->writePacket($ISP);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Are all hosts dead?\n\t\tif ($c == $d)\n\t\t{\n\t\t\tconsole('We cannot seem to successfully connect to any hosts. Exiting');\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate function handlePacket(&$rawPacket, &$hostID)\n\t{\n\t\tglobal $PRISM, $TYPEs, $TINY, $SMALL;\n\t\t\n\t\t// Check packet size\n\t\tif ((strlen($rawPacket) % 4) > 0)\n\t\t{\n\t\t\t// Packet size is not a multiple of 4\n\t\t\tconsole('WARNING : packet with invalid size ('.strlen($rawPacket).') from '.$hostID);\n\t\t\t\n\t\t\t// Let's clear the buffer to be sure, because remaining data cannot be trusted at this point.\n\t\t\t$this->hosts[$hostID]->clearBuffer();\n\t\t\t\n\t\t\t// Do we want to do anything else at this point?\n\t\t\t// Count errors? Disconnect host?\n\t\t\t// My preference would go towards counting the amount of times this error occurs and hang up after perhaps 3 errors.\n\t\t\t\n\t\t\treturn;\n\t\t}\n\n\t\t$this->curHostId = $hostID; # To make sure we always know what host we are talking to, makeing the sendPacket function useful everywhere.\n\t\t\n\t\t# Parse Packet Header\n\t\t$pH = unpack('CSize/CType/CReqI/CSubT', $rawPacket);\n\t\tif (isset($TYPEs[$pH['Type']]))\n\t\t{\n\t\t\tif ($PRISM->config->cvars['debugMode'] & (PRISM_DEBUG_CORE + PRISM_DEBUG_MODULES))\n\t\t\t{\n\t\t\t\tswitch ($pH['Type'])\n\t\t\t\t{\n\t\t\t\t\tcase ISP_TINY:\n\t\t\t\t\t\tconsole(\"< ${TINY[$pH['SubT']]} Packet from {$hostID}.\");\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase ISP_SMALL:\n\t\t\t\t\t\tconsole(\"< ${SMALL[$pH['SubT']]} Packet from {$hostID}.\");\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole(\"< ${TYPEs[$pH['Type']]} Packet from {$hostID}.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t$packet = new $TYPEs[$pH['Type']]($rawPacket);\n\t\t\t$this->inspectPacket($packet, $hostID);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconsole(\"Unknown Type Byte of ${pH['Type']}, with reported size of ${pH['Size']} Bytes and actual size of \" . strlen($rawPacket) . ' Bytes.');\n\t\t}\n\t}\n\n\tprivate function handleOutgaugePacket(&$rawPacket, $hostID)\n\t{\n\t\t# Check packet size (without and with optional ID)\n\t\t$packetLen = strlen($rawPacket);\n\t\tif ($packetLen != OutGaugePack::LENGTH AND $packetLen != OutGaugePack::LENGTH + 4)\n\t\t\treturn console(\"WARNING : outgauge packet of invalid size ({$packetLen})\");\n\t\n\t\t# Parse packet\n\t\t$packet = new OutGaugePack($rawPacket);\n\n\t\t# Pass to outguage processor\n\t\t$this->inspectPacket($packet, $hostID);\n\t}\n\t\n\t// inspectPacket is used to act upon certain packets like error messages\n\t// We need these packets for proper basic PRISM connection functionality\n\t//\n\tprivate function inspectPacket(Struct &$packet, &$hostID)\n\t{\n\t\tglobal $PRISM;\n\n\t\t$this->curHostID = $hostID;\n\t\tswitch($packet->Type)\n\t\t{\n\t\t\tcase ISP_VER :\n\t\t\t\t// When receiving ISP_VER we can conclude that we now have a working insim connection.\n\t\t\t\tif ($this->hosts[$hostID]->getConnStatus() != CONN_VERIFIED)\n\t\t\t\t{\n\t\t\t\t\t// Because we can receive more than one ISP_VER, we only set this the first time\n\t\t\t\t\t$this->hosts[$hostID]->setConnStatus(CONN_VERIFIED);\n\t\t\t\t\t$this->hosts[$hostID]->setConnTime(time());\n\t\t\t\t\t$this->hosts[$hostID]->setConnTries(0);\n\t\t\t\t\t// Here we setup the state for the connection.\n\t\t\t\t\t$this->state[$hostID] = new StateHandler($packet);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase IRP_ERR :\n\t\t\t\tswitch($packet->ErrNo)\n\t\t\t\t{\n\t\t\t\t\tcase IR_ERR_PACKET :\n\t\t\t\t\t\tconsole('Invalid packet sent by client (wrong structure / length)');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IR_ERR_PACKET2 :\n\t\t\t\t\t\tconsole('Invalid packet sent by client (packet was not allowed to be forwarded to host)');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IR_ERR_HOSTNAME :\n\t\t\t\t\t\tconsole('Wrong hostname given by client');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IR_ERR_ADMIN :\n\t\t\t\t\t\tconsole('Wrong admin pass given by client');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IR_ERR_SPEC :\n\t\t\t\t\t\tconsole('Wrong spec pass given by client');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase IR_ERR_NOSPEC :\n\t\t\t\t\t\tconsole('Spectator pass required, but none given');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault :\n\t\t\t\t\t\tconsole('Unknown error received from relay ('.$packet->ErrNo.')');\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Because of the error we close the connection to the relay.\n\t\t\t\t$this->hosts[$hostID]->close(true);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase ISP_PLL :\n\t\t\tcase ISP_CNL :\n\t\t\tcase ISP_CPR :\n\t\t\t\t$PRISM->plugins->dispatchPacket($packet, $hostID);\n\t\t\t\t$this->state[$hostID]->dispatchPacket($packet);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t$this->state[$hostID]->dispatchPacket($packet);\n\t\t\t\t$PRISM->plugins->dispatchPacket($packet, $hostID);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tpublic function sendPacket(Struct $packetClass, $hostId = NULL)\n\t{\n\t\tif ($hostId === NULL)\n\t\t\t$hostId = $this->curHostID;\n\t\t\n\t\t$host = $this->hosts[$hostId];\n\t\t\n\t\tif ($host->isRelay())\n\t\t{\n\t\t\tif (!$host->isAdmin() &&\n\t\t\t\t(\n\t\t\t\t\t($packetClass instanceof IS_TINY && $packetClass->SubT == TINY_VTC)\n\t\t\t\t\t|| $packetClass instanceof IS_MST\n\t\t\t\t\t|| $packetClass instanceof IS_MSX\n\t\t\t\t\t|| $packetClass instanceof IS_MSL\n\t\t\t\t\t|| $packetClass instanceof IS_MTC\n\t\t\t\t\t|| $packetClass instanceof IS_SCH\n\t\t\t\t\t|| $packetClass instanceof IS_BFN\n\t\t\t\t\t|| $packetClass instanceof IS_BTN\n\t\t\t\t)\n\t\t\t)\n\t\t\t{\n\t\t\t\ttrigger_error('Attempted to send invalid packet to relay host, packet not allowed to be forwarded without admin privileges.', E_USER_WARNING);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t\telse if (\n\t\t\t\t$packetClass instanceof IS_TINY\n\t\t\t\t&& ($packetClass->SubT == TINY_NLP\n\t\t\t\t|| $packetClass->SubT == TINY_MCI\n\t\t\t\t|| $packetClass->SubT == TINY_RIP)\n\t\t\t)\n\t\t\t{\n\t\t\t\ttrigger_error('Attempted to send invalid packet to relay host, packet request makes no sense in this context.', E_USER_WARNING);\n\t\t\t\treturn FALSE;\n\t\t\t}\n\t\t}\n\t\t\n\t\tglobal $PRISM, $TYPEs, $TINY, $SMALL;\n\t\tif ($PRISM->config->cvars['debugMode'] & (PRISM_DEBUG_CORE + PRISM_DEBUG_MODULES))\n\t\t{\n\t\t\tswitch ($packetClass->Type)\n\t\t\t{\n\t\t\t\tcase ISP_TINY:\n\t\t\t\t\tconsole(\"> ${TINY[$packetClass->SubT]} Packet to {$hostId}.\");\n\t\t\t\tbreak;\n\t\t\t\tcase ISP_SMALL:\n\t\t\t\t\tconsole(\"> ${SMALL[$packetClass->SubT]} Packet to {$hostId}.\");\n\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole(\"> ${TYPEs[$packetClass->Type]} Packet to {$hostId}.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn $host->writePacket($packetClass);\n\t}\n\t\n\tpublic function &getHostsInfo()\n\t{\n\t\t$info = array();\n\t\tforeach ($this->hosts as $hostID => $host)\n\t\t{\n\t\t\t$info[] = array(\n\t\t\t\t'id'\t\t\t=> $hostID,\n\t\t\t\t'ip'\t\t\t=> $host->getIP(),\n\t\t\t\t'port'\t\t\t=> $host->getPort(),\n\t\t\t\t'useRelay'\t\t=> $host->isRelay(),\n\t\t\t\t'hostname'\t\t=> $host->getHostname(),\n\t\t\t\t'udpPort'\t\t=> $host->getUdpPort(),\n\t\t\t\t'flags'\t\t\t=> $host->getFlags(),\n\t\t\t\t'isAdmin'\t\t=> $host->isAdmin(),\n\t\t\t\t'connStatus'\t=> $host->getConnStatus(),\n\t\t\t\t'socketType'\t=> $host->getSocketType(),\n\t\t\t);\n\t\t}\n\t\treturn $info;\n\t}\n\t\n\tpublic function getHostById($hostId = NULL)\n\t{\n\t\tif ($hostId == NULL)\n\t\t\t$hostId = $this->getCurrentHost();\n\n\t\tif (isset($this->hosts[$hostId]))\n\t\t\treturn $this->hosts[$hostId];\n\n\t\treturn NULL;\n\t}\n\t\n\tpublic function getHostsByIp($ip)\n\t{\n\t\t$hosts = array();\n\t\tforeach ($this->hosts as $hostID => $host)\n\t\t{\n\t\t\tif ($ip == $host->getIP())\n\t\t\t\t$hosts[$hostID] = $host;\n\t\t}\n\t\treturn (count($hosts)) ? $hosts : null;\n\t}\n\n\tpublic function getStateById($hostId = NULL)\n\t{\n\t\tif ($hostId == NULL)\n\t\t\t$hostId = $this->getCurrentHost();\n\n\t\tif (isset($this->state[$hostId]))\n\t\t\treturn $this->state[$hostId];\n\n\t\treturn NULL;\n\t}\n}\n\nclass InsimConnection\n{\n\tprivate $connType;\n\tprivate $socketType;\n\t\n\tprivate $socket;\n\tprivate $socketMCI;\t\t\t\t\t\t# secondary, udp socket to listen on, if udpPort > 0\n\t\t\t\t\t\t\t\t\t\t\t# note that this follows the exact theory of how insim deals with tcp and udp sockets\n\t\t\t\t\t\t\t\t\t\t\t# see InSim.txt in LFS distributions for more info\n\tprivate $socketOutgauge;\t\t\t\t# separate udp socket to listen on for outgauge packets, if outgaugePort > 0\n\t\n\tprivate $connStatus\t\t= CONN_NOTCONNECTED;\n\t\n\t// Counters and timers\n\tprivate $mustConnect\t= 0;\n\tprivate $connTries\t\t= 0;\n\tprivate $connTime\t\t= 0;\n\tprivate $lastReadTime\t= 0;\n\tprivate $lastWriteTime\t= 0;\n\t\n\t// TCP stream buffer\n\tprivate $streamBuf\t\t= '';\n\tprivate $streamBufLen\t= 0;\n\t\n\t// send queue used in emergency cases (if host appears lagged or overflown with packets)\n\tprivate $sendQ\t\t\t= '';\n\tprivate $sendQLen\t\t= 0;\n\tprivate $sendWindow\t\t= STREAM_WRITE_BYTES;\t// dynamic window size\n\n\t// connection & host info\n\tprivate $id\t\t\t\t= '';\t\t\t# the section id from the ini file\n\tprivate $ip\t\t\t\t= '';\t\t\t# ip or hostname to connect to\n\tprivate $connectIP\t\t= '';\t\t\t# the actual ip used to connect\n\tprivate $port\t\t\t= 0;\t\t\t# the port\n\tprivate $flags\t\t\t= 72;\t\t\t# Defaults to ISF_MSO_COLS (8) & ISF_CON (64) options on.\n\tprivate $udpPort\t\t= 0;\t\t\t# the secundary udp port to listen on for NLP/MCI packets, in case the main port is tcp\n\tprivate $outgaugePort\t= 0;\t\t\t# the outgauge udp port to listen on\n\tprivate $adminPass\t\t= '';\t\t\t# adminpass for both relay and direct usage\n\tprivate $specPass\t\t= '';\t\t\t# specpass for relay usage\n\tprivate $pps\t\t\t= 3;\t\t\n\tprivate $hostName\t\t= '';\t\t\t# the hostname. Can be populated by user in case of relay.\n\n\tpublic function __construct(array &$icVars)\n\t{\n    global $PRISM;\n    \n\t\t$this->connType\t\t= ($icVars['connType'] == CONNTYPE_RELAY) ? CONNTYPE_RELAY : CONNTYPE_HOST;\n\t\t$this->socketType\t= ($icVars['socketType'] == SOCKTYPE_UDP) ? SOCKTYPE_UDP : SOCKTYPE_TCP;\n\t\t$this->id\t\t\t= $icVars['id'];\n\t\t$this->ip\t\t\t= $icVars['ip'];\n\t\t$this->port\t\t\t= $icVars['port'];\n\t\t$this->flags\t\t= $icVars['flags'];\n\t\t$this->pps\t\t\t= $icVars['pps'];\n\t\t$this->adminPass\t= $icVars['adminPass'];\n\t\t$this->prefix\t\t= ($icVars['prefix'] == '') ? $PRISM->config->cvars['prefix'] : $icVars['prefix'];\n\n\t\t$this->udpPort\t\t= isset($icVars['udpPort']) ? $icVars['udpPort'] : 0;\n\t\t$this->outgaugePort\t= isset($icVars['outgaugePort']) ? $icVars['outgaugePort'] : 0;\n\t\t$this->hostName\t\t= isset($icVars['hostName']) ? $icVars['hostName'] : '';\n\t\t$this->specPass\t\t= isset($icVars['specPass']) ? $icVars['specPass'] : '';\n\t}\n\t\n\tpublic function __destruct()\n\t{\n\t\t$this->close(TRUE);\n\t\tif ($this->socketMCI)\n\t\t\tfclose($this->socketMCI);\n\t\tif ($this->socketOutgauge)\n\t\t\tfclose($this->socketOutgauge);\n\t}\n\t\n\tpublic function &getSocket()\n\t{\n\t\treturn $this->socket;\n\t}\n\t\n\tpublic function &getSocketMCI()\n\t{\n\t\treturn $this->socketMCI;\n\t}\n\t\n\tpublic function &getSocketOutgauge()\n\t{\n\t\treturn $this->socketOutgauge;\n\t}\n\t\n\tpublic function &getSocketType()\n\t{\n\t\treturn $this->socketType;\n\t}\n\t\n\tpublic function &getConnStatus()\n\t{\n\t\treturn $this->connStatus;\n\t}\n\t\n\tpublic function setConnStatus($connStatus)\n\t{\n\t\t$this->connStatus = $connStatus;\n\t}\n\t\n\tpublic function &getMustConnect()\n\t{\n\t\treturn $this->mustConnect;\n\t}\n\t\n\tpublic function setConnTries($connTries)\n\t{\n\t\t$this->connTries = $connTries;\n\t}\n\t\n\tpublic function setConnTime($connTime)\n\t{\n\t\t$this->connTime = $connTime;\n\t}\n\n\tpublic function &getConnTime()\n\t{\n\t\treturn $this->connTime;\n\t}\n\t\n\tpublic function &getLastReadTime()\n\t{\n\t\treturn $this->lastReadTime;\n\t}\n\t\n\tpublic function &getLastWriteTime()\n\t{\n\t\treturn $this->lastWriteTime;\n\t}\n\t\n\tpublic function &getConnectIP()\n\t{\n\t\treturn $this->connectIP;\n\t}\n\t\n\tpublic function &getIP()\n\t{\n\t\treturn $this->ip;\n\t}\n\t\n\tpublic function &getPort()\n\t{\n\t\treturn $this->port;\n\t}\n\t\n\tpublic function &getUdpPort()\n\t{\n\t\treturn $this->udpPort;\n\t}\n\t\n\tpublic function &getOutgaugePort()\n\t{\n\t\treturn $this->outgaugePort;\n\t}\n\t\n\tpublic function &getFlags()\n\t{\n\t\treturn $this->flags;\n\t}\n\n\tpublic function &getPPS()\n\t{\n\t\treturn $this->pps;\n\t}\n\n\tpublic function isAdmin()\n\t{\n\t\treturn ($this->adminPass != '') ? TRUE : FALSE;\n\t}\n\t\n\tpublic function isRelay()\n\t{\n\t\treturn ($this->connType == CONNTYPE_RELAY) ? TRUE : FALSE;\n\t}\n\t\n\tpublic function &getHostname()\n\t{\n\t\treturn $this->hostName;\n\t}\n\t\n\tpublic function setUdpPort($udpPort)\n\t{\n\t\t// Set the new value\n\t\t$this->udpPort = $udpPort;\n\n\t\t// Should we reinit the udp listening socket?\n\t\t$this->closeMCISocket();\n\t\t$this->createMCISocket();\n\t}\n\t\n\tpublic function setOutgaugePort($outgaugePort)\n\t{\n\t\t// Set the new value\n\t\t$this->outgaugePort = $outgaugePort;\n\n\t\t// Should we reinit the udp listening socket?\n\t\t$this->closeOutgaugeSocket();\n\t\t$this->createOutgaugeSocket();\n\t}\n\t\t\n\tpublic function &getSendQLen()\n\t{\n\t\treturn $this->sendQLen;\n\t}\n\t\n\tpublic function connect()\n\t{\n\t\t// If we're already connected, then we'll assume this is a forced reconnect, so we'll close\n\t\t$this->close(FALSE, TRUE);\n\t\t\n\t\t// Figure out the proper IP address. We do this every time we connect in case of dynamic IP addresses.\n\t\t$this->connectIP = getIP($this->ip);\n\t\tif (!$this->connectIP)\n\t\t{\n\t\t\tconsole('Cannot connect to host, Invalid IP : '.$this->ip.':'.$this->port);\n\t\t\t$this->socket\t\t= NULL;\n\t\t\t$this->connStatus\t= CONN_NOTCONNECTED;\n\t\t\t$this->mustConnect\t= -1;\t\t\t\t\t// Something completely failed - we will no longer try this connection\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tif ($this->socketType == SOCKTYPE_UDP)\n\t\t\t$this->connectUDP();\n\t\telse\n\t\t\t$this->connectTCP();\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic function connectUDP()\n\t{\n\t\t// Create UDP socket\n\t\t$this->socket = @stream_socket_client('udp://'.$this->connectIP.':'.$this->port, $sockErrNo, $sockErrStr);\n\t\tif ($this->socket === FALSE || $sockErrNo)\n\t\t{\n\t\t\tconsole ('Error opening UDP socket for '.$this->connectIP.':'.$this->port.' : '.$sockErrStr);\n\t\t\t$this->socket\t\t= NULL;\n\t\t\t$this->connStatus\t= CONN_NOTCONNECTED;\n\t\t\t$this->mustConnect\t= -1;\t\t\t\t\t// Something completely failed - we will no longer try this connection\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\t// We set the connection time here, so we can track how long we're trying to connect\n\t\t$this->connTime = time();\n\t\n\t\tconsole('Connecting to '.$this->ip.':'.$this->port.' ... #'.($this->connTries + 1));\n\t\t$this->connectFinish();\n\t\t$this->lastReadTime = time() - HOST_TIMEOUT + 10;\n\t\t\n\t\treturn TRUE;\t\t\n\t}\n\t\n\tpublic function connectTCP()\n\t{\n\t\t// If we're already connected, then we'll assume this is a forced reconnect, so we'll close\n\t\t$this->close(FALSE, TRUE);\n\t\n\t\t// Here we create the socket and initiate the connection. This is done asynchronously.\n\t\t$this->socket = @stream_socket_client('tcp://'.$this->connectIP.':'.$this->port, \n\t\t\t\t\t\t\t\t\t\t\t\t$sockErrNo, \n\t\t\t\t\t\t\t\t\t\t\t\t$sockErrStr, \n\t\t\t\t\t\t\t\t\t\t\t\tCONN_TIMEOUT, \n\t\t\t\t\t\t\t\t\t\t\t\tSTREAM_CLIENT_CONNECT | STREAM_CLIENT_ASYNC_CONNECT);\n\t\tif ($this->socket === FALSE || $sockErrNo)\n\t\t{\n\t\t\tconsole ('Error opening TCP socket for '.$this->connectIP.':'.$this->port.' : '.$sockErrStr);\n\t\t\t$this->socket\t\t= NULL;\n\t\t\t$this->connStatus\t= CONN_NOTCONNECTED;\n\t\t\t$this->mustConnect\t= -1;\t\t\t\t\t// Something completely failed - we will no longer try this connection\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\t// Set socket status to 'SYN sent'\n\t\t$this->connStatus = CONN_CONNECTING;\n\t\t// We set the connection time here, so we can track how long we're trying to connect\n\t\t$this->connTime = time();\n\t\t\n\t\tstream_set_blocking($this->socket, 0);\n\t\t\n\t\tconsole('Connecting to '.$this->ip.':'.$this->port.' ... #'.($this->connTries + 1));\n\t\t\n\t\treturn TRUE;\t\t\n\t}\n\t\n\tpublic function connectFinish()\n\t{\n\t\t// Here we finalise the connection cycle. Send an init packet to start the insim stream and while at it, detect if the socket is real.\n\t\t$this->connStatus\t= CONN_CONNECTED;\n\t\t\n\t\tif ($this->connType == CONNTYPE_HOST)\n\t\t{\n\t\t\t// Send IS_ISI packet\n\t\t\t$ISP\t\t\t= new IS_ISI();\n\t\t\t$ISP->ReqI\t\t= TRUE;\n\t\t\t$ISP->UDPPort\t= (isset($this->udpPort) && $this->udpPort > 0) ? $this->udpPort : 0;\n\t\t\t$ISP->Flags\t\t= (isset($this->flags)) ? $this->flags : ISF_MSO_COLS & ISF_CON;\n\t\t\t$ISP->Prefix\t= (isset($this->prefix)) ? ord($this->prefix) : ord('!');\n\t\t\t$ISP->Interval\t= round(1000 / $this->pps);\n\t\t\t$ISP->Admin\t\t= $this->adminPass;\n\t\t\t$ISP->IName\t\t= 'PRISM v' . PHPInSimMod::VERSION;\n\t\t\t$this->writePacket($ISP);\n\t\t}\n\t\telse if ($this->connType == CONNTYPE_RELAY)\n\t\t{\n\t\t\t// Send IR_SEL packet\n\t\t\t$SEL\t\t\t= new IR_SEL();\n\t\t\t$SEL->ReqI\t\t= TRUE;\n\t\t\t$SEL->HName\t\t= $this->hostName;\n\t\t\t$SEL->Admin\t\t= $this->adminPass;\n\t\t\t$SEL->Spec\t\t= $this->specPass;\n\t\t\t$this->writePacket($SEL);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// I'm not sure what we connected to. Shouldn't be possible. Permanently close.\n\t\t\t$this->close(TRUE);\n\t\t}\n\t\t\n\t\tconsole('Connected to '.$this->ip.':'.$this->port);\n\t}\n\t\n\tpublic function createMCISocket()\n\t{\n\t\t$this->closeMCISocket();\n\t    if ($this->udpPort == 0)\n\t        return TRUE;\n\t\t\n\t\t$this->socketMCI = @stream_socket_server('udp://0.0.0.0:'.$this->udpPort, $errNo, $errStr, STREAM_SERVER_BIND);\n\t\tif (!$this->socketMCI || $errNo > 0)\n\t\t{\n\t\t\tconsole ('Error opening additional UDP socket to listen on : '.$errStr);\n\t\t\t$this->socketMCI\t= NULL;\n\t\t\t$this->udpPort\t\t= 0;\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tconsole('Listening for NLP/MCI on secundary UDP port '.$this->udpPort);\n\t\t\n\t\treturn TRUE;\n\t}\n\t\n\tprivate function closeMCISocket()\n\t{\n\t\tif (is_resource($this->socketMCI))\n\t\t\tfclose($this->socketMCI);\n\t\t$this->socketMCI = NULL;\n\t}\n\t\n\tpublic function createOutgaugeSocket()\n\t{\n\t    $this->closeOutgaugeSocket();\n\t    if ($this->outgaugePort == 0)\n\t        return TRUE;\n\t\t\n\t\t$this->socketOutgauge = @stream_socket_server('udp://0.0.0.0:'.$this->outgaugePort, $errNo, $errStr, STREAM_SERVER_BIND);\n\t\tif (!$this->socketOutgauge || $errNo > 0)\n\t\t{\n\t\t\tconsole ('Error opening OutGauge UDP socket to listen on : '.$errStr);\n\t\t\t$this->socketOutgauge\t= NULL;\n\t\t\t$this->outgaugePort\t\t= 0;\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\tconsole('Listening for OutGauge packets on UDP port '.$this->outgaugePort);\n\t\t\n\t\treturn TRUE;\n\t}\n\t\n\tprivate function closeOutgaugeSocket()\n\t{\n\t\tif (is_resource($this->socketOutgauge))\n\t\t\tfclose($this->socketOutgauge);\n\t\t$this->socketOutgauge = NULL;\n\t}\n\t\n\t// $permanentClose\t- set to TRUE to close this connection once and for all.\n\t// $quick\t\t\t- set to TRUE to bypass the reconnection mechanism. If TRUE this disconnect would not count towards the reconnection counter.\n\t//\n\tpublic function close($permanentClose = FALSE, $quick = FALSE)\n\t{\n\t\tif (is_resource($this->socket))\n\t\t{\n\t\t\tif ($this->connStatus == CONN_VERIFIED && $this->connType == CONNTYPE_HOST)\n\t\t\t{\n\t\t\t\t// Send goodbye packet to host\n\t\t\t\t$ISP\t\t= new IS_TINY();\n\t\t\t\t$ISP->SubT\t= TINY_CLOSE;\n\t\t\t\t$this->writePacket($ISP);\n\t\t\t}\n\t\n\t\t\tfclose($this->socket);\n\t\t\tconsole('Closed connection to '.$this->ip.':'.$this->port);\n\t\t}\n\t\t\n\t\t// (re)set some variables.\n\t\t$this->socket\t\t\t= NULL;\n\t\t$this->connStatus\t\t= CONN_NOTCONNECTED;\n\t\t$this->lastReadTime\t\t= 0;\n\t\t$this->lastWriteTime\t= 0;\n\t\t$this->clearBuffer();\n\t\t$this->sendQReset();\n\t\t\n\t\tif ($quick)\n\t\t\treturn;\n\t\t\n\t\tif (!$permanentClose)\n\t\t{\n\t\t\tif (++$this->connTries < HOST_RECONN_TRIES)\n\t\t\t\t$this->mustConnect = time() + HOST_RECONN_TIMEOUT;\n\t\t\telse\n\t\t\t{\n\t\t\t\tconsole('Cannot seem to connect to '.$this->ip.':'.$this->port.' - giving up ...');\n\t\t\t\t$this->mustConnect = -1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\t$this->mustConnect = -1;\n\t}\n\t\n\tpublic function writePacket(Struct &$packet)\n\t{\n\t\tif ($this->socketType\t== SOCKTYPE_UDP)\n\t\t\treturn $this->writeUDP($packet->pack());\n\t\telse\n\t\t\treturn $this->writeTCP($packet->pack());\n\t}\n\t\n\tpublic function writeUDP($data)\n\t{\n\t\t$this->lastWriteTime = time();\n\t\tif (($bytes = @fwrite($this->socket, $data)) === FALSE)\n\t\t\tconsole('UDP: Error sending packet through socket.');\n\t\treturn $bytes;\n\t}\n\t\n\tpublic function writeTCP($data, $sendQPacket = FALSE)\n\t{\n\t\t$bytes = 0;\n\t\t\n\t\tif ($this->connStatus < CONN_CONNECTED)\n\t\t\treturn $bytes;\n\t\n\t\tif ($sendQPacket == TRUE)\n\t\t{\n\t\t\t// This packet came from the sendQ. We just try to send this and don't bother too much about error checking.\n\t\t\t// That's done from the sendQ flushing code.\n\t\t\tif (($bytes = @fwrite($this->socket, $data)) === FALSE)\n\t\t\t\tconsole('TCP: Error sending packet through socket.');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif ($this->sendQLen == 0)\n\t\t\t{\n\t\t\t\t// It's Ok to send packet\n\t\t\t\tif (($bytes = @fwrite($this->socket, $data)) === FALSE)\n\t\t\t\t\tconsole('TCP: Error sending packet through socket.');\n\t\t\t\t$this->lastWriteTime = time();\n\t\t\n\t\t\t\tif (!$bytes || $bytes != strlen($data))\n\t\t\t\t{\n\t\t\t\t\t$this->addPacketToSendQ (substr($data, $bytes));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Host is lagged\n\t\t\t\t$this->addPacketToSendQ ($data);\n\t\t\t}\n\t\t}\n\t\n\t\treturn $bytes;\n\t}\n\t\n\tprivate function addPacketToSendQ($data)\n\t{\n\t\t$this->sendQ .= $data;\n\t\t$this->sendQLen += strlen($data);\n\t}\n\n\tpublic function flushSendQ()\n\t{\n\t\t// Send chunk of data\n\t\t$bytes = $this->writeTCP(substr($this->sendQ, 0, $this->sendWindow), TRUE);\n\t\t\n\t\t// Dynamic window sizing\n\t\tif ($bytes == $this->sendWindow)\n\t\t\t$this->sendWindow += STREAM_WRITE_BYTES;\n\t\telse\n\t\t{\n\t\t\t$this->sendWindow -= STREAM_WRITE_BYTES;\n\t\t\tif ($this->sendWindow < STREAM_WRITE_BYTES)\n\t\t\t\t$this->sendWindow = STREAM_WRITE_BYTES;\n\t\t}\n\n\t\t// Update the sendQ\n\t\t$this->sendQ = substr($this->sendQ, $bytes);\n\t\t$this->sendQLen -= $bytes;\n\n\t\t// Cleanup / reset timers\n\t\tif ($this->sendQLen == 0)\n\t\t{\n\t\t\t// All done flushing - reset queue variables\n\t\t\t$this->sendQReset();\n\t\t}\n\n\t\tif ($bytes > 0)\n\t\t\t$this->lastWriteTime\t= time();\n\t\t//console('Bytes sent : '.$bytes.' - Bytes left : '.$this->sendQLen.' - '.$this->ip);\n\t}\n\t\n\tprivate function sendQReset()\n\t{\n\t\t$this->sendQ\t\t\t= '';\n\t\t$this->sendQLen\t\t\t= 0;\n\t\t$this->lastActivity\t\t= time();\n\t}\n\t\t\t\n\tpublic function read(&$peerInfo)\n\t{\n\t\t$this->lastReadTime = time();\n\t\treturn stream_socket_recvfrom($this->socket, STREAM_READ_BYTES, 0, $peerInfo);\n\t}\n\t\n\tpublic function readMCI(&$peerInfo)\n\t{\n\t\t$this->lastReadTime = time();\n\t\treturn stream_socket_recvfrom($this->socketMCI, STREAM_READ_BYTES, 0, $peerInfo);\n\t}\n\t\n\tpublic function readOutgauge(&$peerInfo)\n\t{\n\t\t$this->lastReadTime = time();\n\t\treturn stream_socket_recvfrom($this->socketOutgauge, STREAM_READ_BYTES, 0, $peerInfo);\n\t}\n\t\n\tpublic function appendToBuffer(&$data)\n\t{\n\t\t$this->streamBuf\t.= $data;\n\t\t$this->streamBufLen\t= strlen ($this->streamBuf);\n\t}\n\t\n\tpublic function clearBuffer()\n\t{\n\t\t$this->streamBuf\t= '';\n\t\t$this->streamBufLen\t= 0;\n\t}\n\t\n\tpublic function findNextPacket()\n\t{\n\t\tif ($this->streamBufLen == 0)\n\t\t\treturn FALSE;\n\t\t\n\t\t$sizebyte = ord($this->streamBuf[0]);\n\t\tif ($sizebyte == 0)\n\t\t{\n\t\t\treturn FALSE;\n\t\t}\n\t\telse if ($this->streamBufLen < $sizebyte)\n\t\t{\n\t\t\t//console('Split packet ...');\n\t\t\treturn FALSE;\n\t\t}\n\t\t\n\t\t// We should have a whole packet in the buffer now\n\t\t$packet\t\t\t\t\t= substr($this->streamBuf, 0, $sizebyte);\n\t\t$packetType\t\t\t\t= ord($packet[1]);\n\t\n\t\t// Cleanup streamBuffer\n\t\t$this->streamBuf\t\t= substr($this->streamBuf, $sizebyte);\n\t\t$this->streamBufLen\t\t= strlen($this->streamBuf);\n\t\t\n\t\treturn $packet;\n\t}\n}\n\n?>\n"]],"start1":0,"start2":0,"length1":0,"length2":34766}]],"length":34766}
{"contributors":[],"silentsave":true,"ts":1363202084492,"patch":[[{"diffs":[[0,"ons\n*/\n\n"],[1,"//"],[0,"require_"]],"start1":87,"start2":87,"length1":16,"length2":18}]],"length":34768,"saved":false}
{"ts":1363202088440,"patch":[[{"diffs":[[0,"ons\n*/\n\n"],[1,"\n"],[0,"//requir"]],"start1":87,"start2":87,"length1":16,"length2":17}]],"length":34769,"saved":false}
{"ts":1363202091936,"patch":[[{"diffs":[[0,"ons\n*/\n\n"],[1,"namespace \n"],[0,"\n//requi"]],"start1":87,"start2":87,"length1":16,"length2":27}]],"length":34780,"saved":false}
{"ts":1363202093753,"patch":[[{"diffs":[[0,"mespace "],[1,"PRISM\\"],[0,"\n\n//requ"]],"start1":97,"start2":97,"length1":16,"length2":22}]],"length":34786,"saved":false}
{"ts":1363202095795,"patch":[[{"diffs":[[0,"e PRISM\\"],[1,"Module\\"],[0,"\n\n//requ"]],"start1":103,"start2":103,"length1":16,"length2":23}]],"length":34793,"saved":false}
{"ts":1363202103392,"patch":[[{"diffs":[[0,"\\Module\\"],[1,"Hosts"],[0,"\n\n//requ"]],"start1":110,"start2":110,"length1":16,"length2":21}]],"length":34798,"saved":false}
{"ts":1363202104578,"patch":[[{"diffs":[[0,"le\\Hosts"],[1,";"],[0,"\n\n//requ"]],"start1":115,"start2":115,"length1":16,"length2":17}]],"length":34799,"saved":false}
{"ts":1363202111707,"patch":[[{"diffs":[[0,"Hosts;\n\n"],[1,"\n\n"],[0,"//requir"]],"start1":118,"start2":118,"length1":16,"length2":18}]],"length":34801,"saved":false}
{"ts":1363202113754,"patch":[[{"diffs":[[0,"Hosts;\n\n"],[1,"use "],[0,"\n\n//requ"]],"start1":118,"start2":118,"length1":16,"length2":20}]],"length":34805,"saved":false}
{"ts":1363202115768,"patch":[[{"diffs":[[0,"s;\n\nuse "],[1,"PRISM\\Mo"],[0,"\n\n//requ"]],"start1":122,"start2":122,"length1":16,"length2":24}]],"length":34813,"saved":false}
{"ts":1363202117112,"patch":[[{"diffs":[[0,"PRISM\\Mo"],[1,"dule"],[0,"\n\n//requ"]],"start1":130,"start2":130,"length1":16,"length2":20}]],"length":34817,"saved":false}
{"ts":1363202119014,"patch":[[{"diffs":[[0,"M\\Module"],[1,"\\"],[0,"\n\n//requ"]],"start1":134,"start2":134,"length1":16,"length2":17}]],"length":34818,"saved":false}
{"ts":1363202124638,"patch":[[{"diffs":[[0,"\\Module\\"],[1,"SectionHandler;"],[0,"\n\n//requ"]],"start1":135,"start2":135,"length1":16,"length2":31}]],"length":34833,"saved":false}
{"ts":1363202130505,"patch":[[{"diffs":[[0,"andler;\n"],[-1,"\n"],[0,"//requir"]],"start1":151,"start2":151,"length1":17,"length2":16}]],"length":34832,"saved":false}
{"ts":1363202174478,"patch":[[{"diffs":[[0,"ule\\Host"],[-1,"s"],[1,"Han"],[0,";\n\nuse P"]],"start1":114,"start2":114,"length1":17,"length2":19}]],"length":34834,"saved":false}
{"ts":1363202176054,"patch":[[{"diffs":[[0,"\\HostHan"],[1,"dler"],[0,";\n\nuse P"]],"start1":117,"start2":117,"length1":16,"length2":20}]],"length":34838,"saved":false}
{"contributors":[],"silentsave":true,"ts":1363203337472,"patch":[[{"diffs":[[0,"ons\n*/\n\n"],[1,"namespace PRISM\\Module\\HostHandler;\n\nuse PRISM\\Module\\SectionHandler;\n//"],[0,"require_"]],"start1":87,"start2":87,"length1":16,"length2":88},{"diffs":[[0,"ler.php');\n\n"],[1,"/\n"],[0,"define('CONN"]],"start1":218,"start2":218,"length1":24,"length2":26}]],"length":34840,"saved":false}
{"ts":1363203340000,"patch":[[{"diffs":[[0,"hp');\n\n/"],[1,"**"],[0,"\ndefine("]],"start1":223,"start2":223,"length1":16,"length2":18}]],"length":34842,"saved":false}
{"ts":1363203341973,"patch":[[{"diffs":[[0,"');\n\n/**"],[1,"/"],[0,"\ndefine("]],"start1":225,"start2":225,"length1":16,"length2":17}]],"length":34843,"saved":false}
{"ts":1363203343605,"patch":[[{"diffs":[[0,"p');\n\n/*"],[1,"\n"],[0,"*/\ndefin"]],"start1":224,"start2":224,"length1":16,"length2":17}]],"length":34844,"saved":false}
{"ts":1363203347519,"patch":[[{"diffs":[[0,"p');\n\n/*"],[1,"*\n * "],[0,"\n*/\ndefi"]],"start1":224,"start2":224,"length1":16,"length2":21}]],"length":34849,"saved":false}
{"ts":1363203353103,"patch":[[{"diffs":[[0,"\n/**\n * "],[1,"If your package needs to define global variables, their names should start with a single underscore followed by the package name and another underscore. For example, the PEAR package uses a global variable called $_PEAR_destructor_object_list.\n\n"],[0,"\n*/\ndefi"]],"start1":229,"start2":229,"length1":16,"length2":261}]],"length":35094,"saved":false}
{"ts":1363203354678,"patch":[[{"diffs":[[0,"t_list.\n"],[-1,"\n\n"],[0,"*/\ndefin"]],"start1":473,"start2":473,"length1":18,"length2":16}]],"length":35092,"saved":false}
{"ts":1363203364674,"patch":[[{"diffs":[[0,"iables, "],[1,"\n * "],[0,"their na"]],"start1":279,"start2":279,"length1":16,"length2":20}]],"length":35096,"saved":false}
{"ts":1363203369725,"patch":[[{"diffs":[[0,"rscore. "],[1,"\n * "],[0,"For exam"]],"start1":386,"start2":386,"length1":16,"length2":20}]],"length":35100,"saved":false}
{"ts":1363203380010,"patch":[[{"diffs":[[0,"les, \n *"],[-1," "],[0,"their na"]],"start1":282,"start2":282,"length1":17,"length2":16}]],"length":35099,"saved":false}
{"ts":1363203381161,"patch":[[{"diffs":[[0,"ables, \n"],[-1," *"],[0,"their na"]],"start1":280,"start2":280,"length1":18,"length2":16}]],"length":35097,"saved":false}
{"ts":1363203382785,"patch":[[{"diffs":[[0,"iables, "],[-1,"\n"],[0,"their na"]],"start1":279,"start2":279,"length1":17,"length2":16}]],"length":35096,"saved":false}
{"ts":1363203389755,"patch":[[{"diffs":[[0,"ld start"],[1,"\n *"],[0," with a "]],"start1":303,"start2":303,"length1":16,"length2":19}]],"length":35099,"saved":false}
{"ts":1363203397856,"patch":[[{"diffs":[[0,"variable"],[1,","],[0," called "]],"start1":441,"start2":441,"length1":16,"length2":17}]],"length":35100,"saved":false}
{"ts":1363203402021,"patch":[[{"diffs":[[0,"ariable,"],[1,"\n *"],[0," called "]],"start1":442,"start2":442,"length1":16,"length2":19}]],"length":35103,"saved":false}
{"ts":1363204389792,"patch":[[{"diffs":[[0,"dule"],[-1,"\\HostHandler"],[0,";\n\nu"]],"start1":113,"start2":113,"length1":20,"length2":8}]],"length":35091,"saved":false}
{"ts":1363204403217,"patch":[[{"diffs":[[0,"ce PRISM"],[-1,"\\Module"],[0,";\n\nuse P"]],"start1":102,"start2":102,"length1":23,"length2":16}]],"length":35084,"saved":false}
{"ts":1363204407409,"patch":[[{"diffs":[[0,"ce PRISM"],[1,"\\Mo"],[0,";\n\nuse P"]],"start1":102,"start2":102,"length1":16,"length2":19}]],"length":35087,"saved":false}
{"ts":1363204409039,"patch":[[{"diffs":[[0,"PRISM\\Mo"],[1,"dule"],[0,";\n\nuse P"]],"start1":105,"start2":105,"length1":16,"length2":20}]],"length":35091,"saved":false}
{"ts":1363207220504,"patch":[[{"diffs":[[0," called "],[-1,"$"],[0,"_PEAR_de"]],"start1":441,"start2":441,"length1":17,"length2":16}]],"length":35090,"saved":false}

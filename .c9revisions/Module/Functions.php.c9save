{"ts":1363201768599,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n\nfunction console($line, $EOL = true)\n{\n\t// Add log to file\n\t// Effected by PRISM_LOG_MODE && PRISM_LOG_FILE_MODE\n\techo $line . (($EOL) ? PHP_EOL : '');\n}\n\nfunction get_dir_structure($path, $recursive = TRUE, $ext = NULL)\n{\n\t$return = NULL;\n\tif (!is_dir($path))\n\t{\n\t\ttrigger_error('$path is not a directory!', E_USER_WARNING);\n\t\treturn FALSE;\n\t}\n\tif ($handle = opendir($path))\n\t{\n\t\twhile (FALSE !== ($item = readdir($handle)))\n\t\t{\n\t\t\tif ($item != '.' && $item != '..')\n\t\t\t{\n\t\t\t\tif (is_dir($path . $item))\n\t\t\t\t{\n\t\t\t\t\tif ($recursive)\n\t\t\t\t\t{\n\t\t\t\t\t\t$return[$item] = get_dir_structure($path . $item . '/', $recursive, $ext);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$return[$item] = array();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ($ext != null && strrpos($item, $ext) !== FALSE)\n\t\t\t\t\t{\n\t\t\t\t\t\t$return[] = $item;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclosedir($handle);\n\t}\n\treturn $return;\n}\n\n// check if path1 is part of path2 (ie. if path1 is a base path of path2)\nfunction isDirInDir($path1, $path2)\n{\n\t$p1 = explode('/', $path1);\n\t$p2 = explode('/', $path2);\n\t\n\tforeach ($p1 as $index => $part)\n\t{\n\t\tif ($part === '')\n\t\t\tcontinue;\n\t\tif (!isset($p2[$index]) || $part != $p2[$index])\n\t\t\treturn false;\n\t}\n\t\n\treturn true;\n}\n\nfunction findPHPLocation($windows = false)\n{\n\t$phpLocation = '';\n\t\n\tif ($windows)\n\t{\n\t\tconsole('Trying to find the location of php.exe');\n\n\t\t// Search in current dir first.\n\t\t$exp = explode(\"\\r\\n\", shell_exec('dir /s /b php.exe'));\n\t\tif (preg_match('/^.*\\\\\\php\\.exe$/', $exp[0]))\n\t\t{\n\t\t\t$phpLocation = $exp[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Do a recursive search on this whole drive.\n\t\t\tchdir('/');\n\t\t\t$exp = explode(\"\\r\\n\", shell_exec('dir /s /b php.exe'));\n\t\t\tif (preg_match('/^.*\\\\\\php\\.exe$/', $exp[0]))\n\t\t\t\t$phpLocation = $exp[0];\n\t\t\tchdir(ROOTPATH);\n\t\t}\n\t}\n\telse\n\t{\n\t\t$exp = explode(' ', shell_exec('whereis php'));\n\t\t$count = count($exp);\n\t\tif ($count == 1)\t\t\t\t// Some *nix's output is only the path\n\t\t\t$phpLocation = $exp[0];\n\t\telse if ($count > 1)\t\t\t// FreeBSD for example has more info on the line, like :\n\t\t\t$phpLocation = $exp[1];\t\t// php: /user/local/bin/php /usr/local/man/man1/php.1.gz\n\t}\n\t\n\treturn $phpLocation;\n}\n\nfunction validatePHPFile($file)\n{\n\t// Validate script\n\t$fileContents = file_get_contents($file);\n\tif (!eval('return true;'.preg_replace(array('/^<\\?(php)?/', '/\\?>$/'), '', $fileContents)))\n\t\treturn array(false, array('Errors parsing '.$file));\n\t\t\n\t// Validate any require_once or include_once files.\n//\t$matches = array();\n//\tpreg_match_all('/(include_once|require_once)\\s*\\([\"\\']+(.*)[\"\\']+\\)/', $fileContents, $matches);\n//\n//\tforeach ($matches[2] as $include)\n//\t{\n//\t\tconsole($include);\n//\t\t$result = validatePHPFile($include);\n//\t\tif ($result[0] == false)\n//\t\t\treturn $result;\n//\t}\n\n\treturn array(true, array());\n}\n\nfunction flagsToInteger($flagsString = '')\n{\n\t# We don't have anything to parse.\n\tif ($flagsString == '')\n\t\treturn FALSE;\n\n\t$flagsBitwise = 0;\n\tfor ($chrPointer = 0, $strLen = strlen($flagsString); $chrPointer < $strLen; ++$chrPointer)\n\t{\n\t\t# Convert this charater to it's ASCII int value.\n\t\t$char = ord($flagsString{$chrPointer});\n\n\t\t# We only want a (ASCII = 97) through z (ASCII 122), nothing else.\n\t\tif ($char < 97 || $char > 122)\n\t\t\tcontinue;\n\n\t\t# Check we have already set that flag, if so skip it!\n\t\tif ($flagsBitwise & (1 << ($char - 97)))\n\t\t\tcontinue;\n\n\t\t# Add the value to our $flagBitwise intager.\n\t\t$flagsBitwise += (1 << ($char - 97));\n\t}\n\treturn $flagsBitwise;\n}\n\nfunction flagsToString($flagsBitwise = 0)\n{\n\t$flagsString = '';\n\tif ($flagsBitwise == 0)\n\t\treturn $flagsString;\n\n\t# This makes sure we only handle the flags we know by unsetting any unknown bits.\n\t$flagsBitwise = $flagsBitwise & ADMIN_ALL;\n\n\t# Converts bits to the char forms.\n\tfor ($i = 0; $i < 26; ++$i)\n\t\t$flagsString .= ($flagsBitwise & (1 << $i)) ? chr($i + 97) : NULL;\n\n\treturn $flagsString;\n}\n\ndefine('RAND_ASCII', 1);\ndefine('RAND_ALPHA', 2);\ndefine('RAND_NUMERIC', 4);\ndefine('RAND_HEX', 8);\ndefine('RAND_BINARY', 16);\nfunction createRandomString($len, $type = RAND_ASCII)\n{\n\t$out = '';\n\tfor ($a=0; $a<$len; $a++)\n\t{\n\t\tif ($type & RAND_ALPHA)\n\t\t{\n\t\t\t$out .= rand(0,1) ? chr(rand(65, 90)) : chr(rand(97, 122));\n\t\t}\n\t\telse if ($type & RAND_NUMERIC)\n\t\t{\n\t\t\t$out .= chr(rand(48, 57));\n\t\t}\n\t\telse if ($type & RAND_HEX)\n\t\t{\n\t\t\t$out .= sprintf('%02x', rand(0, 255));\n\t\t}\n\t\telse if ($type & RAND_BINARY)\n\t\t{\n\t\t\t$out .= chr(rand(0, 255));\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$out .= chr(rand(32, 127));\n\t\t}\n\t}\n\treturn $out;\n}\n\nfunction ucwordsByChar($string, $delimiter)\n{\n\t$out = '';\n\tforeach (explode($delimiter, $string) as $k => $v)\n\t{\n\t\tif ($k > 0)\n\t\t\t$out .= $delimiter;\n\t\t$out .= ucfirst($v);\n\t}\n\treturn $out;\n}\n\nfunction getIP(&$ip)\n{\n\tif (verifyIP($ip))\n\t\treturn $ip;\n\telse\n\t{\n\t\t$tmp_ip = @gethostbyname($ip);\n\t\tif (verifyIP($tmp_ip))\n\t\t\treturn $tmp_ip;\n\t}\n\t\n\treturn FALSE;\n}\n\nfunction verifyIP(&$ip)\n{\n\treturn filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4);\n}\n\nfunction timeToString($int, $fraction=1000)\n{\n\t$seconds = floor($int / $fraction);\n\t$fractions = $int - floor($seconds * $fraction);\n\t$seconds -= ($hours = floor($seconds / 3600)) * 3600;\n\t$seconds -= ($minutes = floor($seconds / 60)) * 60;\n\t\n\tif ($hours > 0)\n\t{\n\t\treturn sprintf('%d:%02d:%02d.%0'.(strlen($fraction) - 1).'d', $hours, $minutes, $seconds, $fractions);\n\t}\n\telse\n\t{\n\t\treturn sprintf('%d:%02d.%0'.(strlen($fraction) - 1).'d', $minutes, $seconds, $fractions);\n\t}\n}\n\nfunction timeToStr($time, $fraction=1000)\n{\n\treturn preg_replace('/^(0+:)+/', '', timeToString($time, $fraction));\n}\n\nfunction sortByKey($key)\n{\n\treturn function ($left, $right) use ($key)\n\t{\n\t\tif ($left[$key] == $right[$key])\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn ($left[$key] < $right[$key]) ? -1 : 1;\n\t};\n}\n\nfunction sortByProperty($property)\n{\n\treturn function ($left, $right) use ($property)\n\t{\n\t\tif ($left->$property == $right->$property)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn ($left->$property < $right->$property) ? -1 : 1;\n\t};\n}\n\nclass Msg2Lfs\n{\n    public $PLID = 0;\n    public $UCID = 0;\n    public $Text = '';\n    public $Sound = SND_SILENT;\n    \n    public function __construct($text = '')\n    {\n        $this->Text = $text;\n        return $this;\n    }\n    \n    public function &__call($name, array $arguments)\n    {\n    \tif (property_exists(get_class($this), $name))\n    \t\t$this->$name = array_shift($arguments);\n    \treturn $this;\n    }\n    \n    public function send($hostId = NULL)\n    {\n        if ($this->Text == '') { return; }\n        \n    \tglobal $PRISM;\n    \n        // Decide what IS packet to use to send this message\n        if (($PRISM->hosts->getStateById($hostId)->State & ISS_MULTI) === 0)\n        {\n            // Single player\n            IS_MSL()->Msg($this->Text)->Sound($this->Sound)->send();\n        }\n        else\n        {\n            // Multi player\n            if ($this->PLID > 0)\n                IS_MTC()->PLID($this->PLID)->Text($this->Text)->Sound($this->Sound)->send();\n            else if ($this->UCID > 0)\n                IS_MTC()->UCID($this->UCID)->Text($this->Text)->Sound($this->Sound)->send();\n            else\n                IS_MSX()->Msg($this->Text)->send();\n        }\n    \n    \treturn $this;\n    }\n}; function Msg2Lfs() { return new Msg2Lfs; }\n?>"]],"start1":0,"start2":0,"length1":0,"length2":7143}]],"length":7143}
{"contributors":[],"silentsave":true,"ts":1363201809721,"patch":[[{"diffs":[[0," = NULL)"],[1," //"],[0,"\n{\n\t$ret"]],"start1":219,"start2":219,"length1":16,"length2":19}]],"length":7146,"saved":false}
{"ts":1363201813898,"patch":[[{"diffs":[[0,"NULL) //"],[1,"PHP Now has shit t"],[0,"\n{\n\t$ret"]],"start1":222,"start2":222,"length1":16,"length2":34}]],"length":7164,"saved":false}
{"ts":1363201817927,"patch":[[{"diffs":[[0,"s shit t"],[1,"o deal with this...?"],[0,"\n{\n\t$ret"]],"start1":240,"start2":240,"length1":16,"length2":36}]],"length":7184,"saved":false}
{"ts":1363201819439,"patch":[[{"diffs":[[0," this..."],[-1,"?"],[0,"\n{\n\t$ret"]],"start1":259,"start2":259,"length1":17,"length2":16}]],"length":7183,"saved":false}
{"ts":1363201837514,"patch":[[{"diffs":[[0,"ile\n\t// "],[-1,"E"],[0,"ffected "]],"start1":62,"start2":62,"length1":17,"length2":16}]],"length":7182,"saved":false}
{"ts":1363201839805,"patch":[[{"diffs":[[0,"ile\n\t// "],[1,"A"],[0,"ffected "]],"start1":62,"start2":62,"length1":16,"length2":17}]],"length":7183,"saved":false}
{"ts":1363201864814,"patch":[[{"diffs":[[0,"<?php\n\n"],[1,"\n"],[0,"function"]],"start1":0,"start2":0,"length1":15,"length2":16}]],"length":7184,"saved":false}
{"ts":1363201866241,"patch":[[{"diffs":[[0,"<?php\n\n"],[1,"name\n"],[0,"\nfunctio"]],"start1":0,"start2":0,"length1":15,"length2":20}]],"length":7189,"saved":false}
{"ts":1363201868094,"patch":[[{"diffs":[[0,"hp\n\nname"],[1,"space P"],[0,"\n\nfuncti"]],"start1":3,"start2":3,"length1":16,"length2":23}]],"length":7196,"saved":false}
{"ts":1363201871034,"patch":[[{"diffs":[[0,"espace P"],[1,"RISM\\"],[0,"\n\nfuncti"]],"start1":10,"start2":10,"length1":16,"length2":21}]],"length":7201,"saved":false}
{"ts":1363201873145,"patch":[[{"diffs":[[0,"e PRISM\\"],[1,"Module\\Fun"],[0,"\n\nfuncti"]],"start1":15,"start2":15,"length1":16,"length2":26}]],"length":7211,"saved":false}
{"ts":1363201874816,"patch":[[{"diffs":[[0,"dule\\Fun"],[1,"ctions;"],[0,"\n\nfuncti"]],"start1":25,"start2":25,"length1":16,"length2":23}]],"length":7218,"saved":false}
{"contributors":[],"silentsave":true,"ts":1363300623574,"patch":[[{"diffs":[[0,"dule"],[-1,"\\Functions;"],[1,";\n\n"],[0,"\n\nfu"]],"start1":25,"start2":25,"length1":19,"length2":11}]],"length":7210,"saved":false}
{"ts":1363300629587,"patch":[[{"diffs":[[0,"odule;\n\n"],[1,"# Thin"],[0,"\n\nfuncti"]],"start1":24,"start2":24,"length1":16,"length2":22}]],"length":7216,"saved":false}
{"ts":1363300631049,"patch":[[{"diffs":[[0,";\n\n# Thi"],[-1,"n"],[1,"s "],[0,"\n\nfuncti"]],"start1":29,"start2":29,"length1":17,"length2":18}]],"length":7217,"saved":false}
{"ts":1363300635959,"patch":[[{"diffs":[[0,"\n# This "],[1,"needs to be dealt with, "],[0,"\n\nfuncti"]],"start1":31,"start2":31,"length1":16,"length2":40}]],"length":7241,"saved":false}
{"ts":1363300642217,"patch":[[{"diffs":[[0,"t with, "],[1,"it's currently not a module..."],[0,"\n\nfuncti"]],"start1":55,"start2":55,"length1":16,"length2":46}]],"length":7271,"saved":false}
